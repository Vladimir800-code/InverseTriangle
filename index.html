<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Triangle Solver ‚Äî Inverse Geometry Tool</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
    .container { display: flex; margin: 20px 0; gap: 20px; flex-wrap: wrap; }
    .panel { background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .visualization-panel { flex: 2; min-width: 500px; position: relative; }
    .control-panel { flex: 1; min-width: 300px; display: flex; flex-direction: column; }
    h1, h2, h3 { color: #2c3e50; margin-top: 0; }
    h1 { font-size: 24px; margin-bottom: 10px; }
    h2 { font-size: 20px; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
    .param-group { margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
    .param-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
    .param-label { min-width: 40px; font-weight: bold; color: #2c3e50; }
    select.param-select { flex: 2; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: border-color 0.3s; }
    select.param-select:focus { border-color: #3498db; outline: none; }
    input.param-value { flex: 1; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; text-align: right; min-width: 80px; }
    input.param-value:focus { border-color: #3498db; outline: none; }
    .slider-container { flex: 2; display: flex; flex-direction: column; gap: 5px; }
    .slider-row { display: flex; align-items: center; gap: 10px; }
    .slider-value { min-width: 50px; text-align: right; font-weight: bold; color: #2c3e50; font-size: 13px; }
    input.param-slider { flex: 1; height: 6px; border-radius: 3px; background: #ddd; outline: none; -webkit-appearance: none; }
    input.param-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
    input.param-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
    
    /* –ß–µ–∫–±–æ–∫—Å—ã —Ñ–∏–∫—Å–∞—Ü–∏–∏ */
    .fix-checkbox-container { display: flex; align-items: center; margin-left: 5px; }
    .fix-checkbox-label { font-size: 12px; color: #7f8c8d; margin-left: 4px; white-space: nowrap; }
    input.fix-checkbox { width: 16px; height: 16px; cursor: pointer; }
    .param-row.fixed .param-select,
    .param-row.fixed .param-value,
    .param-row.fixed .slider-value { opacity: 0.7; background-color: #f5f5f5; }
    
    .button-group { display: flex; gap: 10px; margin-top: 20px; }
    button { padding: 12px 20px; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; flex: 1; }
    #solveBtn { background: #2ecc71; color: white; }
    #solveBtn:hover { background: #27ae60; transform: translateY(-2px); }
    #solveBtn:disabled { background: #95a5a6; cursor: not-allowed; transform: none; }
    #randomBtn { background: #3498db; color: white; }
    #randomBtn:hover { background: #2980b9; transform: translateY(-2px); }
    #randomParamsBtn { background: #9b59b6; color: white; }
    #randomParamsBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #randomParamsBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
    #clearBtn { background: #e74c3c; color: white; }
    #clearBtn:hover { background: #c0392b; transform: translateY(-2px); }
    #testBtn { background: #9b59b6; color: white; flex: 0.5; }
    #testBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #validateBtn { background: #f39c12; color: white; flex: 0.5; }
    #validateBtn:hover { background: #d68910; transform: translateY(-2px); }
    #debugBtn { background: #34495e; color: white; flex: 0.5; }
    #debugBtn:hover { background: #2c3e50; transform: translateY(-2px); }
    #solveAllBtn { background: #9b59b6; color: white; flex: 0.5; }
    #solveAllBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #solveAllBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
    #checkBtn { background: #f39c12; color: white; flex: 0.5; }
    #checkBtn:hover { background: #d68910; transform: translateY(-2px); }
    #feasibilityBtn { background: #1abc9c; color: white; flex: 0.5; }
    #feasibilityBtn:hover { background: #16a085; transform: translateY(-2px); }
    .type-btn { padding: 8px 12px; font-size: 14px; flex: 0.33; }
    .progress-container { margin-top: 20px; background: #ecf0f1; border-radius: 10px; overflow: hidden; height: 20px; display: none; }
    #progressBar { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); width: 0%; transition: width 0.5s; }
    #progressText { display: block; text-align: center; margin-top: 5px; font-size: 14px; color: #7f8c8d; }
    .result-info { margin-top: 20px; padding: 15px; background: #e8f6f3; border-radius: 8px; border-left: 4px solid #1abc9c; }
    .result-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
    .result-label { font-weight: bold; color: #2c3e50; }
    .result-value { color: #16a085; font-weight: bold; }
    .result-row.angle-coords { font-size: 13px; color: #7f8c8d; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #ddd; }
    .result-row.angle-coords .result-label { color: #7f8c8d; font-weight: normal; }
    .result-row.angle-coords .result-value { color: #9b59b6; font-weight: bold; }
    .result-row.triangle-type { font-size: 13px; color: #7f8c8d; font-style: italic; }
    .table-container { margin-top: 20px; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th { background: #34495e; color: white; padding: 8px; text-align: left; position: sticky; top: 0; }
    td { padding: 6px 8px; border-bottom: 1px solid #ddd; }
    tr:nth-child(even) { background: #f8f9fa; }
    tr:hover { background: #e3f2fd; }
    td.invalid { background-color: #ffeaea; color: #e74c3c; }
    td.valid { background-color: #e8f6f3; }
    .chart-container { width: 100%; height: 500px; margin-bottom: 20px; position: relative; }
    canvas { width: 100% !important; height: 100% !important; }
    .scale-control { position: absolute; right: 20px; bottom: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 10; width: 200px; }
    .scale-control h4 { margin: 0 0 8px 0; font-size: 14px; color: #2c3e50; }
    .scale-slider { width: 100%; margin: 5px 0; }
    .scale-value { font-size: 12px; color: #7f8c8d; text-align: center; margin-top: 5px; }
    .info-box { background: #fff8e1; border-left: 4px solid #ffb300; padding: 10px 15px; margin-bottom: 15px; border-radius: 4px; font-size: 14px; }
    .error-message { color: #e74c3c; font-size: 14px; margin-top: 10px; padding: 10px; background: #ffeaea; border-radius: 6px; border-left: 4px solid #e74c3c; }
    .error-message.hidden { display: none; }
    .validation-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
    .validation-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .validation-ok { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
    .validation-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
    .validation-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
    .debug-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #34495e; }
    .debug-row { display: flex; justify-content: space-between; margin: 3px 0; font-size: 12px; font-family: monospace; }
    .debug-label { color: #2c3e50; }
    .debug-value { color: #9b59b6; font-weight: bold; }
    .solutions-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #9b59b6; }
    .solutions-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .solutions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-top: 10px; }
    .solution-thumb { background: white; border-radius: 6px; padding: 10px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; text-align: center; }
    .solution-thumb:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-color: #3498db; }
    .solution-thumb.active { border-color: #2ecc71; background: #e8f6f3; }
    .solution-thumb.mirror .thumb-title::after { content: " ü™û"; font-size: 10px; }
    .solution-thumb .thumb-title { font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #2c3e50; }
    .solution-thumb .thumb-info { font-size: 10px; color: #7f8c8d; }
    .solution-actions { display: flex; gap: 5px; margin-top: 8px; }
    .solution-btn { padding: 4px 8px; font-size: 10px; border-radius: 3px; border: none; cursor: pointer; flex: 1; }
    .view-btn { background: #3498db; color: white; }
    .animate-btn { background: #9b59b6; color: white; }
    .solution-navigation { display: flex; justify-content: center; gap: 10px; margin-top: 15px; }
    .nav-btn { padding: 6px 12px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; background: #34495e; color: white; }
    .nav-btn:hover { background: #2c3e50; }
    .solution-indicator { display: inline-block; margin-left: 10px; font-size: 14px; color: #9b59b6; font-weight: bold; }
    .compatibility-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
    .compatibility-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .status-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
    .status-message { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .status-info { background: #d1ecf1; color: #0c5460; border-left: 3px solid #17a2b8; }
    .status-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
    .status-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
    .status-success { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
    .floating-message { 
      position: fixed; 
      top: 20px; 
      right: 20px; 
      padding: 15px; 
      border-radius: 8px; 
      color: white; 
      font-weight: bold; 
      z-index: 1000; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
      animation: fadeIn 0.3s; 
      max-width: 400px; 
      max-height: 300px; 
      overflow-y: auto; 
      line-height: 1.4; 
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 900px) {
      .container { flex-direction: column; }
      .visualization-panel, .control-panel { min-width: 100%; }
      .scale-control { position: relative; right: auto; bottom: auto; width: 100%; margin-top: 10px; }
      .solutions-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
      .param-row { flex-wrap: wrap; }
      .fix-checkbox-container { margin-left: auto; }
    }
  </style>
</head>
<body>
  <h1>üî∫ Triangle Solver ‚Äî Inverse Geometry Calculator</h1>
  <div class="info-box">
    <strong>–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞:</strong> –¢–µ–ø–µ—Ä—å –≤–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏, —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ –∞–¥–∞–ø—Ç–∏–≤–Ω—É—é –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é.
    <span id="allSolutionsInfo" style="display: none; color: #9b59b6; margin-left: 10px;">
      | –ù–∞–π–¥–µ–Ω–æ —Ä–µ—à–µ–Ω–∏–π: <span id="solutionsCount">0</span>
    </span>
  </div>
  
  <div class="container">
    <div class="panel visualization-panel">
      <h2>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ 
        <span id="solutionIndicator" class="solution-indicator"></span>
      </h2>
      <div class="chart-container">
        <canvas id="triangleChart"></canvas>
        <div class="scale-control">
          <h4 style="margin: 0 0 8px 0;">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±:</h4>
          <input type="range" class="scale-slider" id="yScale" min="40" max="200" step="10">
          <div class="scale-value">
            –ú–∞—Å—à—Ç–∞–±: <span id="yScaleLabel" class="percent"></span>%
          </div>
        </div>
      </div>
      <div class="result-info">
        <div class="result-row">
          <span class="result-label">–°—Ç–∞—Ç—É—Å:</span>
          <span id="statusText" class="result-value">–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</span>
        </div>
        <div class="result-row">
          <span class="result-label">–¢–æ—á–Ω–æ—Å—Ç—å:</span>
          <span id="accuracyText" class="result-value">-</span>
        </div>
        <div class="result-row">
          <span class="result-label">–ò—Ç–µ—Ä–∞—Ü–∏–π:</span>
          <span id="iterationsText" class="result-value">0</span>
        </div>
        <div class="result-row">
          <span class="result-label">–ú–∞—Å—à—Ç–∞–± (R):</span>
          <span id="scaleText" class="result-value">1.00</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª A (Œ±):</span>
          <span id="angleAText" class="result-value">-</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª B (Œ≤):</span>
          <span id="angleBText" class="result-value">-</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª C (Œ≥):</span>
          <span id="angleCText" class="result-value">-</span>
        </div>
        <div class="result-row triangle-type">
          <span class="result-label">–¢–∏–ø:</span>
          <span id="triangleTypeText" class="result-value">-</span>
        </div>
      </div>
      
      <div id="statusPanel" class="status-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–°—Ç–∞—Ç—É—Å –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</h4>
        <div id="statusMessages"></div>
      </div>
      
      <div id="debugPanel" class="debug-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–û—Ç–ª–∞–¥–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</h4>
        <div id="debugResults"></div>
      </div>
    </div>
    
    <div class="panel control-panel">
      <h2>–ó–∞–¥–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h2>
      
      <div class="param-group">
        <div class="param-row" id="paramRow1">
          <div class="param-label">1.</div>
          <select class="param-select" id="param1">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value1" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam1" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam1" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer1" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue1">0</span>
            <input type="range" class="param-slider" id="slider1" min="0" max="100" step="0.1">
          </div>
        </div>
        
        <div class="param-row" id="paramRow2">
          <div class="param-label">2.</div>
          <select class="param-select" id="param2">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value2" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam2" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam2" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer2" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue2">0</span>
            <input type="range" class="param-slider" id="slider2" min="0" max="100" step="0.1">
          </div>
        </div>
        
        <div class="param-row" id="paramRow3">
          <div class="param-label">3.</div>
          <select class="param-select" id="param3">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value3" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam3" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam3" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer3" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue3">0</span>
            <input type="range" class="param-slider" id="slider3" min="0" max="100" step="0.1">
          </div>
        </div>
      </div>
      
      <div class="button-group">
        <button id="solveBtn" onclick="startSolvingEnhanced()">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
        <button id="randomBtn" onclick="generateRandomProblem()">–°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–∞—á–∞</button>
        <button id="randomParamsBtn" onclick="randomizeNonFixedParameters()" disabled>–°–ª—É—á–∞–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</button>
        <button id="clearBtn" onclick="clearAll()">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      
      <div class="button-group" style="margin-top: 10px;">
        <button id="solveAllBtn" onclick="findAllSolutionsEnhanced()">–í—Å–µ —Ä–µ—à–µ–Ω–∏—è</button>
        <button id="checkBtn" onclick="checkCompatibility()">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å</button>
        <button id="feasibilityBtn" onclick="checkPracticalFeasibilityUI()">–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞</button>
        <button id="testBtn" onclick="testAndDisplayFormulas()">–¢–µ—Å—Ç —Ñ–æ—Ä–º—É–ª</button>
        <button id="validateBtn" onclick="validateCurrentTriangleEnhanced()">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="debugBtn" onclick="debugCoordinates()">–û—Ç–ª–∞–¥–∫–∞</button>
      </div>
      
      <div class="button-group" style="margin-top: 10px;">
        <button onclick="generateTriangleByType('equilateral')" class="type-btn" style="background: #2ecc71;">
          –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π
        </button>
        <button onclick="generateTriangleByType('right')" class="type-btn" style="background: #e74c3c;">
          –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π
        </button>
        <button onclick="generateTriangleByType('isosceles')" class="type-btn" style="background: #3498db;">
          –†–∞–≤–Ω–æ–±–µ–¥—Ä–µ–Ω–Ω—ã–π
        </button>
      </div>
      
      <div id="errorMessage" class="error-message hidden">
        <!-- –°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
      </div>
      
      <div id="statusMessagesInline" class="status-panel" style="margin-top: 20px; display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–°–æ–æ–±—â–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã</h4>
        <div id="inlineStatusContent"></div>
      </div>
      
      <div class="progress-container" id="progressContainer">
        <div id="progressBar"></div>
      </div>
      <span id="progressText">–ì–æ—Ç–æ–≤–æ</span>
      
      <div id="compatibilityPanel" class="compatibility-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h4>
        <div id="compatibilityResults"></div>
      </div>
      
      <div id="validationPanel" class="validation-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–µ–æ–º–µ—Ç—Ä–∏–∏</h4>
        <div id="validationResults"></div>
      </div>
      
      <div class="info-box" style="margin-top: 20px;">
        <strong>–ü–æ–¥—Å–∫–∞–∑–∫–∞:</strong> –í—ã–±–µ—Ä–∏—Ç–µ 3 —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–∑—É–Ω–∫–∏ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤—Ä—É—á–Ω—É—é. –û—Ç–º–µ—Ç—å—Ç–µ ¬´–ó–∞–∫—Ä–µ–ø–∏—Ç—å¬ª –¥–ª—è —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ù–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å" –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞.
      </div>
    </div>
  </div>
  
  <div id="solutionsPanel" class="solutions-panel" style="display: none;">
    <div class="solutions-header">
      <h3 style="margin: 0;">–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è (<span id="solutionsCountDisplay">0</span>)</h3>
      <div>
        <button onclick="showPreviousSolution()" class="nav-btn">‚óÄ –ü—Ä–µ–¥—ã–¥—É—â–µ–µ</button>
        <button onclick="showNextSolution()" class="nav-btn">–°–ª–µ–¥—É—é—â–µ–µ ‚ñ∂</button>
        <button onclick="closeSolutionsPanel()" class="nav-btn" style="background: #e74c3c;">‚úï –ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
    <div class="info-box" style="margin: 10px 0; padding: 8px; font-size: 13px;">
      <strong>–í—Å–µ —Ä–µ—à–µ–Ω–∏—è –∫–æ–Ω–≥—Ä—É—ç–Ω—Ç–Ω—ã –∏–ª–∏ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã.</strong> –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–º–µ—á–µ–Ω—ã ü™û. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –º–∏–Ω–∏–∞—Ç—é—Ä—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.
    </div>
    <div id="solutionsGrid" class="solutions-grid"></div>
    <div class="solution-navigation">
      <button onclick="showSolution(0)" class="nav-btn">–ü–µ—Ä–≤–æ–µ</button>
      <button onclick="showSolution(allSolutions.length-1)" class="nav-btn">–ü–æ—Å–ª–µ–¥–Ω–µ–µ</button>
    </div>
  </div>
  
  <div class="panel" style="margin-top: 20px;">
    <h2>–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞</h2>
    <div class="table-container">
      <table id="allParamsTable">
        <thead>
          <tr>
            <th>‚Ññ</th>
            <th>–ù–∞–∑–≤–∞–Ω–∏–µ</th>
            <th>–û–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ</th>
            <th>–ó–Ω–∞—á–µ–Ω–∏–µ</th>
            <th>–ü—Ä–æ–≤–µ—Ä–∫–∞</th>
          </tr>
        </thead>
        <tbody id="paramsTableBody">
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let allParameters = [];
    let selectedParameters = {};
    let currentSolution = null;
    let chart = null;
    let allSolutions = [];
    let currentSolutionIndex = 0;
    let isFindingAll = false;
    let currentStatusMessages = [];
    let autoCalculateTimer = null; // –¢–∞–π–º–µ—Ä –¥–ª—è –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç–∞
    
    const paramRanges = {
      'sideAB': { min: 0.1, max: 5.0, step: 0.01 },
      'sideBC': { min: 0.1, max: 5.0, step: 0.01 },
      'sideAC': { min: 0.1, max: 5.0, step: 0.01 },
      'angleA': { min: 10, max: 170, step: 0.1 },
      'angleB': { min: 10, max: 170, step: 0.1 },
      'angleC': { min: 10, max: 170, step: 0.1 },
      'altitudeA': { min: 0.05, max: 5.0, step: 0.01 },
      'altitudeB': { min: 0.05, max: 5.0, step: 0.01 },
      'altitudeC': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorA': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorB': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorC': { min: 0.05, max: 5.0, step: 0.01 },
      'medianA': { min: 0.05, max: 5.0, step: 0.01 },
      'medianB': { min: 0.05, max: 5.0, step: 0.01 },
      'medianC': { min: 0.05, max: 5.0, step: 0.01 },
      'inradius': { min: 0.01, max: 2.5, step: 0.01 },
      'area': { min: 0.01, max: 6.25, step: 0.01 },
      'circumradius': { min: 0.5, max: 5.0, step: 0.01 }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
      initParameters();
      initChart();
      setupEventListeners();
      initVerticalScaleControl();
      document.getElementById('solveAllBtn').disabled = true;
      setupFixCheckboxes();
      setupEnhancedEventListeners();
    });
    
    function initParameters() {
      allParameters = [
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ AB', designation: 'c', key: 'sideAB' },
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ BC', designation: 'a', key: 'sideBC' },
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ AC', designation: 'b', key: 'sideAC' },
        { name: '–£–≥–æ–ª A', designation: 'Œ±', key: 'angleA' },
        { name: '–£–≥–æ–ª B', designation: 'Œ≤', key: 'angleB' },
        { name: '–£–≥–æ–ª C', designation: 'Œ≥', key: 'angleC' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ A', designation: 'h‚Çê', key: 'altitudeA' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ B', designation: 'h’¢', key: 'altitudeB' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ C', designation: 'hùí∏', key: 'altitudeC' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ A', designation: 'l‚Çê', key: 'bisectorA' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ B', designation: 'l’¢', key: 'bisectorB' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ C', designation: 'lùí∏', key: 'bisectorC' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ A', designation: 'm‚Çê', key: 'medianA' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ B', designation: 'm’¢', key: 'medianB' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ C', designation: 'mùí∏', key: 'medianC' },
        { name: '–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π', designation: 'r', key: 'inradius' },
        { name: '–ü–ª–æ—â–∞–¥—å', designation: 'S', key: 'area' },
        { name: '–†–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π', designation: 'R', key: 'circumradius' }
      ];
      
      fillParameterSelects();
      setupSliders();
      updateAllParamsTable();
    }
    
    function fillParameterSelects() {
      const selects = ['param1', 'param2', 'param3'];
      
      selects.forEach((selectId, index) => {
        const select = document.getElementById(selectId);
        select.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>';
        
        allParameters.forEach(param => {
          const option = document.createElement('option');
          option.value = param.key;
          option.textContent = `${param.designation} - ${param.name}`;
          select.appendChild(option);
        });
        
        select.addEventListener('change', function() {
          updateSliderForParam(index + 1, this.value);
          validateParameterSelection();
          updateRandomParamsButtonState();
          clearStatusMessages();
          
          // –ê–≤—Ç–æ—Ä–∞—Å—á–µ—Ç –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≤—ã–±–æ—Ä–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ (–µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω)
          setTimeout(() => {
            const isFixed = document.getElementById(`fixParam${index + 1}`).checked;
            if (this.value && !isFixed && validateParameterSelection()) {
              triggerAutoCalculate();
            }
          }, 100);
        });
      });
    }
    
    function setupSliders() {
      for (let i = 1; i <= 3; i++) {
        const slider = document.getElementById(`slider${i}`);
        const valueDisplay = document.getElementById(`sliderValue${i}`);
        const input = document.getElementById(`value${i}`);
        const select = document.getElementById(`param${i}`);
        const fixCheckbox = document.getElementById(`fixParam${i}`);
        
        if (slider && valueDisplay && input) {
          // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –º–æ–∂–Ω–æ –ª–∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç
          const canAutoCalculate = () => {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—ã–±—Ä–∞–Ω –∏ –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω
            const paramKey = select.value;
            const isFixed = fixCheckbox && fixCheckbox.checked;
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –≤—ã–±—Ä–∞–Ω –∏ –Ω–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω
            return paramKey && !isFixed && validateParameterSelection();
          };
          
          // –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç–∞
          const triggerAutoCalculate = () => {
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä
            if (autoCalculateTimer) {
              clearTimeout(autoCalculateTimer);
            }
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á–µ—Ç —á–µ—Ä–µ–∑ 300–º—Å (–¥–µ–±–∞—É–Ω—Å–∏–Ω–≥)
            autoCalculateTimer = setTimeout(() => {
              if (canAutoCalculate()) {
                console.log(`–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç: –ø–∞—Ä–∞–º–µ—Ç—Ä ${i} –∏–∑–º–µ–Ω–µ–Ω`);
                startSolvingEnhanced();
              }
            }, 300);
          };
          
          // –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ slider + –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç
          slider.addEventListener('input', function() {
            const paramKey = document.getElementById(`param${i}`).value;
            if (!paramKey) return;
            
            const range = paramRanges[paramKey];
            if (!range) return;
            
            const normalizedValue = parseFloat(this.value);
            const realValue = range.min + (range.max - range.min) * (normalizedValue / 100);
            
            let displayValue;
            if (paramKey.includes('angle')) {
              displayValue = realValue.toFixed(1) + '¬∞';
              input.value = realValue.toFixed(1);
            } else {
              displayValue = realValue.toFixed(3);
              input.value = realValue.toFixed(3);
            }
            
            valueDisplay.textContent = displayValue;
            validateParameterSelection();
            clearStatusMessages();
            
            // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –ó–ê–ü–£–°–ö –†–ê–°–ß–ï–¢–ê –¥–ª—è –Ω–µ–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            if (canAutoCalculate()) {
              triggerAutoCalculate();
            }
          });
          
          // –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ input + –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç  
          input.addEventListener('input', function() {
            const paramKey = document.getElementById(`param${i}`).value;
            if (!paramKey) return;
            
            const range = paramRanges[paramKey];
            if (!range) return;
            
            const inputValue = parseFloat(this.value);
            if (isNaN(inputValue)) return;
            
            const clampedValue = Math.max(range.min, Math.min(range.max, inputValue));
            
            if (Math.abs(inputValue - clampedValue) > 0.001) {
              this.value = clampedValue.toFixed(paramKey.includes('angle') ? 1 : 3);
            }
            
            const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
            
            slider.value = normalizedValue;
            
            let displayValue;
            if (paramKey.includes('angle')) {
              displayValue = clampedValue.toFixed(1) + '¬∞';
            } else {
              displayValue = clampedValue.toFixed(3);
            }
            
            valueDisplay.textContent = displayValue;
            validateParameterSelection();
            clearStatusMessages();
            
            // –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ô –ó–ê–ü–£–°–ö –†–ê–°–ß–ï–¢–ê –¥–ª—è –Ω–µ–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            if (canAutoCalculate()) {
              triggerAutoCalculate();
            }
          });
          
          // –î–ª—è select —É–∂–µ –µ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤ fillParameterSelects()
        }
      }
    }
    
    function updateSliderForParam(paramIndex, paramKey) {
      const sliderContainer = document.getElementById(`sliderContainer${paramIndex}`);
      const slider = document.getElementById(`slider${paramIndex}`);
      const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
      const input = document.getElementById(`value${paramIndex}`);
      
      if (!paramKey) {
        sliderContainer.style.display = 'none';
        input.value = '';
        document.getElementById(`fixParam${paramIndex}`).checked = false;
        return;
      }
      
      const range = paramRanges[paramKey];
      if (!range) {
        sliderContainer.style.display = 'none';
        return;
      }
      
      sliderContainer.style.display = 'flex';
      
      let initialValue;
      if (input.value && !isNaN(parseFloat(input.value))) {
        initialValue = parseFloat(input.value);
        initialValue = Math.max(range.min, Math.min(range.max, initialValue));
      } else {
        initialValue = (range.min + range.max) / 2;
      }
      
      if (paramKey.includes('angle')) {
        input.value = initialValue.toFixed(1);
      } else {
        input.value = initialValue.toFixed(3);
      }
      
      const normalizedValue = ((initialValue - range.min) / (range.max - range.min)) * 100;
      
      slider.value = normalizedValue;
      
      let displayValue;
      if (paramKey.includes('angle')) {
        displayValue = initialValue.toFixed(1) + '¬∞';
      } else {
        displayValue = initialValue.toFixed(3);
      }
      
      valueDisplay.textContent = displayValue;
    }
    
    function validateParameterSelection() {
      const params = [];
      const values = {};
      let isValid = true;
      
      hideErrorMessage();
      hideCompatibilityPanel();
      
      for (let i = 1; i <= 3; i++) {
        const select = document.getElementById(`param${i}`);
        const input = document.getElementById(`value${i}`);
        const paramKey = select.value;
        const value = parseFloat(input.value);
        
        if (paramKey && !isNaN(value)) {
          if (params.includes(paramKey)) {
            isValid = false;
            showErrorMessage(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(paramKey)} –≤—ã–±—Ä–∞–Ω –¥–≤–∞–∂–¥—ã!`, true);
            break;
          }
          
          if (!validateParameterValue(paramKey, value)) {
            isValid = false;
            break;
          }
          
          params.push(paramKey);
          values[paramKey] = value;
        } else if (paramKey || input.value) {
          isValid = false;
        }
      }
      
      if (params.length === 3) {
        selectedParameters = values;
        document.getElementById('solveBtn').disabled = false;
        document.getElementById('solveAllBtn').disabled = false;
        document.getElementById('statusText').textContent = '–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å—á—ë—Ç—É';
        document.getElementById('statusText').style.color = '#2ecc71';
      } else {
        selectedParameters = {};
        document.getElementById('solveBtn').disabled = true;
        document.getElementById('solveAllBtn').disabled = true;
        document.getElementById('statusText').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ 3 —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞';
        document.getElementById('statusText').style.color = '#7f8c8d';
      }
      
      updateRandomParamsButtonState();
      return isValid;
    }
    
    function validateParameterValue(paramKey, value) {
      if (paramKey.includes('angle')) {
        if (value < 10 || value > 170) {
          showErrorMessage(`–£–≥–æ–ª ${getParameterName(paramKey)} –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–∂–¥—É 10¬∞ –∏ 170¬∞!`, true);
          return false;
        }
      } else if (value <= 0) {
        showErrorMessage(`${getParameterName(paramKey)} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π!`, true);
        return false;
      }
      
      const range = paramRanges[paramKey];
      if (range) {
        if (value < range.min || value > range.max) {
          showErrorMessage(`${getParameterName(paramKey)} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ ${range.min} - ${range.max}!`, true);
          return false;
        }
      }
      
      return true;
    }
    
    function getParameterName(key) {
      const param = allParameters.find(p => p.key === key);
      return param ? `${param.designation} (${param.name})` : key;
    }
    
    // ========== –£–°–û–í–ï–†–®–ï–ù–°–¢–í–ê–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
    function checkParameterCompatibility(params) {
        const checks = [];
        const Œµ = 1e-6;
        
        // –°–±–æ—Ä –≤—Å–µ—Ö –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        const knownSides = {
            a: params.sideBC,
            b: params.sideAC,
            c: params.sideAB
        };
        
        const knownAngles = {
            A: params.angleA,
            B: params.angleB,
            C: params.angleC
        };
        
        const knownHeights = {
            ha: params.altitudeA,
            hb: params.altitudeB,
            hc: params.altitudeC
        };
        
        const knownMedians = {
            ma: params.medianA,
            mb: params.medianB,
            mc: params.medianC
        };
        
        const knownBisectors = {
            la: params.bisectorA,
            lb: params.bisectorB,
            lc: params.bisectorC
        };
        
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ø–æ —Ç—Ä–µ–º —Å—Ç–æ—Ä–æ–Ω–∞–º
        if (params.sideAB && params.sideBC && params.sideAC) {
            const a = params.sideBC;
            const b = params.sideAC;
            const c = params.sideAB;
            
            const triangleInequality1 = a + b > c;
            const triangleInequality2 = a + c > b;
            const triangleInequality3 = b + c > a;
            
            if (!triangleInequality1) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: a(${a.toFixed(3)}) + b(${b.toFixed(3)}) > c(${c.toFixed(3)})`
                });
            }
            if (!triangleInequality2) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: a(${a.toFixed(3)}) + c(${c.toFixed(3)}) > b(${b.toFixed(3)})`
                });
            }
            if (!triangleInequality3) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: b(${b.toFixed(3)}) + c(${c.toFixed(3)}) > a(${a.toFixed(3)})`
                });
            }
        }
        
        // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–º–º—ã —É–≥–ª–æ–≤
        const definedAngles = [];
        let definedAnglesSum = 0;
        const angleLetters = ['A', 'B', 'C'];
        
        angleLetters.forEach(letter => {
            const angle = knownAngles[letter];
            if (angle !== undefined) {
                definedAngles.push(letter);
                definedAnglesSum += angle;
            }
        });
        
        if (definedAngles.length >= 2) {
            if (definedAnglesSum >= 180 - Œµ) {
                checks.push({
                    type: 'error',
                    message: `–°—É–º–º–∞ –∑–∞–¥–∞–Ω–Ω—ã—Ö —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –º–µ–Ω—å—à–µ 180¬∞`
                });
            }
        }
        
        if (definedAngles.length === 3) {
            const angleError = Math.abs(definedAnglesSum - 180);
            if (angleError > 1) {
                checks.push({
                    type: 'error',
                    message: `–°—É–º–º–∞ –≤—Å–µ—Ö —Ç—Ä–µ—Ö —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–∞–≤–Ω–∞ 180¬∞ (¬±1¬∞). –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: ${angleError.toFixed(2)}¬∞`
                });
            } else if (angleError > 0.1) {
                checks.push({
                    type: 'warning',
                    message: `–°—É–º–º–∞ —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –Ω–µ–º–Ω–æ–≥–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç 180¬∞. –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: ${angleError.toFixed(2)}¬∞`
                });
            }
        }
        
        // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–æ—Ä–µ–º—ã —Å–∏–Ω—É—Å–æ–≤ –¥–ª—è –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–∞—Ä —Å—Ç–æ—Ä–æ–Ω–∞-–ø—Ä–æ—Ç–∏–≤–æ–ª–µ–∂–∞—â–∏–π —É–≥–æ–ª
        const sineLawPairs = [];
        
        if (knownSides.a && knownAngles.A) sineLawPairs.push({ side: knownSides.a, angle: knownAngles.A, ratio: null });
        if (knownSides.b && knownAngles.B) sineLawPairs.push({ side: knownSides.b, angle: knownAngles.B, ratio: null });
        if (knownSides.c && knownAngles.C) sineLawPairs.push({ side: knownSides.c, angle: knownAngles.C, ratio: null });
        
        if (sineLawPairs.length >= 2) {
            sineLawPairs.forEach(pair => {
                pair.ratio = pair.side / Math.sin(pair.angle * Math.PI / 180);
            });
            
            const ratios = sineLawPairs.map(p => p.ratio);
            const maxRatio = Math.max(...ratios);
            const minRatio = Math.min(...ratios);
            const ratioError = (maxRatio - minRatio) / ((maxRatio + minRatio) / 2);
            
            if (ratioError > 0.1) {
                const ratioStr = sineLawPairs.map(p => p.ratio.toFixed(3)).join(', ');
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–∞ —Ç–µ–æ—Ä–µ–º–∞ —Å–∏–Ω—É—Å–æ–≤. –û—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω–∞/sin(—É–≥–ª–∞) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–≤–Ω—ã. –ü–æ–ª—É—á–µ–Ω–æ: ${ratioStr}`
                });
            }
        }
        
        // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–π –≤—ã—Å–æ—Ç, –º–µ–¥–∏–∞–Ω –∏ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å
        const vertexChecks = [
            { vertex: 'A', side: 'a', height: knownHeights.ha, median: knownMedians.ma, bisector: knownBisectors.la },
            { vertex: 'B', side: 'b', height: knownHeights.hb, median: knownMedians.mb, bisector: knownBisectors.lb },
            { vertex: 'C', side: 'c', height: knownHeights.hc, median: knownMedians.mc, bisector: knownBisectors.lc }
        ];
        
        vertexChecks.forEach(check => {
            const sideKey = `side${check.vertex === 'A' ? 'BC' : check.vertex === 'B' ? 'AC' : 'AB'}`;
            const oppositeSide = params[sideKey];
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Å–æ—Ç—ã
            if (check.height && oppositeSide) {
                if (check.height > oppositeSide + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–í—ã—Å–æ—Ç–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.height.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã (${oppositeSide.toFixed(3)})`
                    });
                }
                
                // –í—ã—Å–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π
                if (check.height <= 0) {
                    checks.push({
                        type: 'error',
                        message: `–í—ã—Å–æ—Ç–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.height.toFixed(3)}) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π`
                    });
                }
            }
            
            // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ú–µ–¥–∏–∞–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã
            if (check.median && check.height) {
                if (check.median < check.height - Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã (${check.height.toFixed(3)}). –í —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ –º–µ–¥–∏–∞–Ω–∞ –≤—Å–µ–≥–¥–∞ ‚â• –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã.`
                    });
                }
            }
            
            // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã
            if (check.bisector && check.height) {
                if (check.bisector < check.height - Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.bisector.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã (${check.height.toFixed(3)}). –í —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –≤—Å–µ–≥–¥–∞ ‚â• –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã.`
                    });
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –ú–µ–¥–∏–∞–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É –¥–≤—É—Ö –¥—Ä—É–≥–∏—Ö —Å—Ç–æ—Ä–æ–Ω
            if (check.median && knownSides.b && knownSides.c && check.vertex === 'A') {
                const maxMedian = 0.5 * (knownSides.b + knownSides.c);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã A (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω b –∏ c (${maxMedian.toFixed(3)})`
                    });
                }
            }
            if (check.median && knownSides.a && knownSides.c && check.vertex === 'B') {
                const maxMedian = 0.5 * (knownSides.a + knownSides.c);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã B (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω a –∏ c (${maxMedian.toFixed(3)})`
                });
                }
            }
            if (check.median && knownSides.a && knownSides.b && check.vertex === 'C') {
                const maxMedian = 0.5 * (knownSides.a + knownSides.b);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã C (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω a –∏ b (${maxMedian.toFixed(3)})`
                    });
                }
            }
        });
        
        // 5. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–¥–∏—É—Å–æ–≤ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π
        if (params.inradius && params.circumradius) {
            if (params.inradius > params.circumradius) {
                checks.push({
                    type: 'error',
                    message: `–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ (${params.inradius.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ —Ä–∞–¥–∏—É—Å–∞ –æ–ø–∏—Å–∞–Ω–Ω–æ–π (${params.circumradius.toFixed(3)})`
                });
            }
            
            // –î–ª—è –æ—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: R ‚â• 2r
            if (params.inradius > 0 && params.circumradius > 0) {
                if (params.circumradius < 2 * params.inradius) {
                    // –ü—Ä–æ–≤–µ—Ä–∏–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Ç—É–ø–æ—É–≥–æ–ª—å–Ω—ã–º
                    let isObtuse = false;
                    if (params.angleA > 90 || params.angleB > 90 || params.angleC > 90) {
                        isObtuse = true;
                    }
                    
                    if (!isObtuse) {
                        checks.push({
                            type: 'warning',
                            message: `–î–ª—è –æ—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ R ‚â• 2r. –£ –≤–∞—Å R=${params.circumradius.toFixed(3)}, r=${params.inradius.toFixed(3)}`
                        });
                    }
                }
            }
        }
        
        // 6. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–æ—â–∞–¥–∏
        if (params.area) {
            if (params.area <= 0) {
                checks.push({
                    type: 'error',
                    message: `–ü–ª–æ—â–∞–¥—å (${params.area.toFixed(3)}) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π`
                });
            }
            
            // –ï—Å–ª–∏ –∑–∞–¥–∞–Ω—ã —Å—Ç–æ—Ä–æ–Ω—ã, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º—É–ª—É –ì–µ—Ä–æ–Ω–∞
            if (params.sideAB && params.sideBC && params.sideAC) {
                const a = params.sideBC;
                const b = params.sideAC;
                const c = params.sideAB;
                const p = (a + b + c) / 2;
                const heronArea = Math.sqrt(p * (p - a) * (p - b) * (p - c));
                
                if (heronArea > 0) {
                    const areaError = Math.abs(params.area - heronArea) / params.area;
                    if (areaError > 0.1) {
                        checks.push({
                            type: 'error',
                            message: `–ó–∞–¥–∞–Ω–Ω–∞—è –ø–ª–æ—â–∞–¥—å (${params.area.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–ª–æ—â–∞–¥–∏ –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ì–µ—Ä–æ–Ω–∞ (${heronArea.toFixed(3)})`
                        });
                    }
                }
            }
        }
        
        // 7. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–æ—Ä–µ–º—ã –∫–æ—Å–∏–Ω—É—Å–æ–≤
        if (params.sideAB && params.sideBC && params.angleC) {
            const c = params.sideAB;
            const a = params.sideBC;
            const Œ≥ = params.angleC * Math.PI / 180;
            const b_calculated = Math.sqrt(a*a + c*c - 2*a*c*Math.cos(Œ≥));
            
            if (params.sideAC && Math.abs(params.sideAC - b_calculated) / Math.max(params.sideAC, b_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ AC (${params.sideAC.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${b_calculated.toFixed(3)}`
                });
            }
        }
        
        if (params.sideBC && params.sideAC && params.angleA) {
            const a = params.sideBC;
            const b = params.sideAC;
            const Œ± = params.angleA * Math.PI / 180;
            const c_calculated = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(Œ±));
            
            if (params.sideAB && Math.abs(params.sideAB - c_calculated) / Math.max(params.sideAB, c_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ AB (${params.sideAB.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${c_calculated.toFixed(3)}`
                });
            }
        }
        
        if (params.sideAB && params.sideAC && params.angleB) {
            const c = params.sideAB;
            const b = params.sideAC;
            const Œ≤ = params.angleB * Math.PI / 180;
            const a_calculated = Math.sqrt(b*b + c*c - 2*b*c*Math.cos(Œ≤));
            
            if (params.sideBC && Math.abs(params.sideBC - a_calculated) / Math.max(params.sideBC, a_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ BC (${params.sideBC.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${a_calculated.toFixed(3)}`
                });
            }
        }
        
        // 8. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
        if (definedAngles.length === 3) {
            if (params.angleA < 1 || params.angleB < 1 || params.angleC < 1) {
                checks.push({
                    type: 'warning',
                    message: '–£–≥–ª—ã —Å–ª–∏—à–∫–æ–º –º–∞–ª—ã (< 1¬∞), —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π'
                });
            }
            
            if (params.angleA > 179 || params.angleB > 179 || params.angleC > 179) {
                checks.push({
                    type: 'warning',
                    message: '–£–≥–ª—ã —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–∏ –∫ 180¬∞, —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π'
                });
            }
        }
        
        // 9. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
        if (params.circumradius && params.inradius) {
            // –î–ª—è —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: R = 2r
            const ratio = params.circumradius / params.inradius;
            if (Math.abs(ratio - 2) < 0.01) {
                // –ü—Ä–æ–≤–µ—Ä–∏–º, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª–∏ —ç—Ç–æ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
                if (params.angleA && params.angleB && params.angleC) {
                    const isEquilateral = Math.abs(params.angleA - 60) < 1 && 
                                         Math.abs(params.angleB - 60) < 1 && 
                                         Math.abs(params.angleC - 60) < 1;
                    if (!isEquilateral) {
                        checks.push({
                            type: 'warning',
                            message: `–û—Ç–Ω–æ—à–µ–Ω–∏–µ R/r ‚âà 2 —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–æ –¥–ª—è —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞, –Ω–æ –∑–∞–¥–∞–Ω–Ω—ã–µ —É–≥–ª—ã –Ω–µ —Ä–∞–≤–Ω—ã 60¬∞`
                        });
                    }
                }
            }
        }
        
        // 10. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã–µ" –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –≤—ã—Å–æ—Ç
        if (knownHeights.ha && knownHeights.hb && knownHeights.hc) {
            // –î–ª—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞:
            // 1/h‚Çê + 1/h’¢ > 1/hùí∏ –∏ —Ç.–¥.
            const invSumAB = 1/knownHeights.ha + 1/knownHeights.hb;
            const invC = 1/knownHeights.hc;
            
            if (invSumAB <= invC + Œµ) {
                checks.push({
                    type: 'error',
                    message: `–ù–µ–≤—ã–ø–æ–ª–Ω–∏–º–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –≤—ã—Å–æ—Ç: 1/h‚Çê + 1/h’¢ > 1/hùí∏ –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è`
                });
            }
        }
        
        return {
            passed: !checks.some(c => c.type === 'error'),
            warnings: checks.filter(c => c.type === 'warning'),
            errors: checks.filter(c => c.type === 'error'),
            allChecks: checks
        };
    }
    
    // ========== –ü–†–û–í–ï–†–ö–ê –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ô –†–ï–ê–õ–ò–ó–£–ï–ú–û–°–¢–ò ==========
    function checkPracticalFeasibility(params) {
      const Œµ = 0.1; // –ü–æ—Ä–æ–≥ —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const warnings = [];
      const errors = [];
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–µ —É–≥–ª—ã
      ['angleA', 'angleB', 'angleC'].forEach(angleKey => {
        if (params[angleKey]) {
          const angle = params[angleKey];
          if (angle < Œµ) {
            errors.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –º–∞–ª (<${Œµ}¬∞)`);
          } else if (angle > 180 - Œµ) {
            errors.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ 180¬∞`);
          } else if (angle < 1) {
            warnings.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) –æ—á–µ–Ω—å –º–∞–ª, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
          } else if (angle > 179) {
            warnings.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) –æ—á–µ–Ω—å –±–ª–∏–∑–æ–∫ –∫ 180¬∞, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
          }
        }
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è
      if (params.inradius && params.circumradius) {
        const ratio = params.inradius / params.circumradius;
        if (ratio > 0.9) {
          warnings.push(`–û—Ç–Ω–æ—à–µ–Ω–∏–µ r/R (${ratio.toFixed(3)}) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ 1, —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π`);
        }
        if (ratio < 0.001) {
          warnings.push(`–û—Ç–Ω–æ—à–µ–Ω–∏–µ r/R (${ratio.toFixed(6)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–π —Å—Ç–æ—Ä–æ–Ω
      if (params.sideAB && params.sideBC && params.sideAC) {
        const sides = [params.sideBC, params.sideAC, params.sideAB];
        const maxSide = Math.max(...sides);
        const minSide = Math.min(...sides);
        const ratio = maxSide / minSide;
        
        if (ratio > 100) {
          warnings.push(`–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ (${ratio.toFixed(1)}:1), –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
        } else if (ratio > 50) {
          warnings.push(`–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ (${ratio.toFixed(1)}:1)`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
      Object.entries(params).forEach(([key, value]) => {
        if (value && Math.abs(value) < 1e-6 && !key.includes('angle')) {
          warnings.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —Ç–æ—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π`);
        }
        
        if (value && Math.abs(value) > 1e6) {
          warnings.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π –¥–ª—è —Ç–æ—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π`);
        }
      });
      
      return {
        feasible: errors.length === 0,
        errors: errors,
        warnings: warnings,
        allIssues: [...errors, ...warnings]
      };
    }
    
    // ========== –ê–î–ê–ü–¢–ò–í–ù–´–ô –ê–õ–ì–û–†–ò–¢–ú –û–¢–ñ–ò–ì–ê –° –ê–í–¢–û–ù–ê–°–¢–†–û–ô–ö–û–ô ==========
    
    // –ö–ª–∞—Å—Å –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SA
    class AutoSAConfigurator {
      static analyzeProblem(targetParams) {
        const analysis = {
          // –°–ª–æ–∂–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á–∏
          complexity: this.estimateComplexity(targetParams),
          
          // –¢–∏–ø—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
          hasAngles: this.hasParameterType(targetParams, 'angle'),
          hasSides: this.hasParameterType(targetParams, 'side'),
          hasSpecial: this.hasSpecialParameters(targetParams),
          
          // –ú–∞—Å—à—Ç–∞–± –∑–Ω–∞—á–µ–Ω–∏–π
          valueRanges: this.getValueRanges(targetParams),
          
          // –û–∂–∏–¥–∞–µ–º–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
          expectedBehavior: this.predictBehavior(targetParams)
        };
        
        return analysis;
      }
      
      static estimateComplexity(params) {
        let score = 0;
        const weights = {
          angle: 1,      // –ü—Ä–æ—Å—Ç—ã–µ
          side: 2,       // –°—Ä–µ–¥–Ω–∏–µ
          area: 3,       // –°–ª–æ–∂–Ω—ã–µ
          radius: 3,     // –°–ª–æ–∂–Ω—ã–µ
          altitude: 4,   // –û—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã–µ
          median: 5,     // –û—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã–µ
          bisector: 6    // –°–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ
        };
        
        Object.keys(params).forEach(key => {
          const type = this.getParamType(key);
          score += weights[type] || 2;
        });
        
        if (score <= 4) return 'low';
        if (score <= 8) return 'medium';
        return 'high';
      }
      
      static getParamType(key) {
        if (key.includes('angle')) return 'angle';
        if (key.includes('side')) return 'side';
        if (key.includes('altitude')) return 'altitude';
        if (key.includes('median')) return 'median';
        if (key.includes('bisector')) return 'bisector';
        if (key === 'area') return 'area';
        if (key === 'inradius' || key === 'circumradius') return 'radius';
        return 'other';
      }
      
      static hasParameterType(params, type) {
        return Object.keys(params).some(key => this.getParamType(key) === type);
      }
      
      static hasSpecialParameters(params) {
        return Object.keys(params).some(key => 
          this.getParamType(key) === 'altitude' || 
          this.getParamType(key) === 'median' || 
          this.getParamType(key) === 'bisector'
        );
      }
      
      static getValueRanges(params) {
        const ranges = {};
        Object.keys(params).forEach(key => {
          ranges[key] = {
            value: params[key],
            type: this.getParamType(key),
            normalized: this.normalizeValue(key, params[key])
          };
        });
        return ranges;
      }
      
      static normalizeValue(key, value) {
        if (key.includes('angle')) {
          return value / 180; // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–æ–≤
        } else if (key === 'circumradius') {
          return value / 5.0; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–¥–∏—É—Å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ
        } else if (key.includes('side')) {
          return value / 5.0; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
        }
        return value / 10.0; // –û–±—â–∏–π —Å–ª—É—á–∞–π
      }
      
      static predictBehavior(params) {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω–∞—Å–∫–æ–ª—å–∫–æ "—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞" –∑–∞–¥–∞—á–∞
        let sensitivity = 0;
        let nonlinearity = 0;
        
        if (this.hasSpecialParameters(params)) {
          sensitivity += 2; // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –±–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã
          nonlinearity += 1;
        }
        
        if (this.hasParameterType(params, 'angle') && this.hasParameterType(params, 'side')) {
          sensitivity += 1; // –°–º–µ—à–∞–Ω–Ω—ã–µ —Ç–∏–ø—ã —Å–ª–æ–∂–Ω–µ–µ
        }
        
        return {
          sensitivity: Math.min(3, sensitivity),
          nonlinearity: Math.min(2, nonlinearity),
          expectedStagnation: sensitivity > 1 ? 'high' : 'low'
        };
      }
      
      static generateConfig(analysis, timeBudgetMs = 5000) {
        const baseConfig = {
          // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã SA
          initialTemperature: 1000,
          coolingSchedule: 'exponential',
          coolingRate: 0.985,
          minTemperature: 0.01,
          maxIterations: 10000,
          
          // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ü–µ–ø–∏ –ú–∞—Ä–∫–æ–≤–∞
          markovChainLength: 100,
          innerIterations: 10,
          
          // –†–∞–∑–º–µ—Ä—ã —à–∞–≥–æ–≤ (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö –¥–ª—è —É–≥–ª–æ–≤, –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –¥–ª—è –¥—Ä—É–≥–∏—Ö)
          stepSizes: {
            Œ±: 0.15,  // ~8.6¬∞
            Œ≤: 0.15,
            R: 0.08   // 8% –æ—Ç —Ä–∞–¥–∏—É—Å–∞
          },
          
          // –ê–¥–∞–ø—Ç–∞—Ü–∏—è
          adaptiveSteps: true,
          adaptationRate: 0.99,
          minStepSize: 0.001,
          
          // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∏
          enableRestarts: true,
          restartAfterStagnation: 500,
          restartProbability: 0.3,
          
          // –õ–æ–∫–∞–ª—å–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ
          localRefinement: true,
          refinementThreshold: 2.0
        };
        
        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞
        switch (analysis.complexity) {
          case 'low':
            baseConfig.initialTemperature = 500;
            baseConfig.coolingRate = 0.96;
            baseConfig.markovChainLength = 50;
            baseConfig.maxIterations = 3000;
            baseConfig.stepSizes = { Œ±: 0.2, Œ≤: 0.2, R: 0.1 };
            break;
            
          case 'high':
            baseConfig.initialTemperature = 2000;
            baseConfig.coolingRate = 0.995;
            baseConfig.markovChainLength = 200;
            baseConfig.maxIterations = 20000;
            baseConfig.stepSizes = { Œ±: 0.1, Œ≤: 0.1, R: 0.05 };
            baseConfig.enableRestarts = true;
            baseConfig.restartAfterStagnation = 300;
            break;
            
          default: // medium
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            break;
        }
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏
        if (analysis.hasSpecial) {
          baseConfig.initialTemperature *= 1.5;
          baseConfig.coolingRate = 0.99;
          baseConfig.markovChainLength = 150;
        }
        
        if (!analysis.hasAngles && analysis.hasSides) {
          // –¢–æ–ª—å–∫–æ —Å—Ç–æ—Ä–æ–Ω—ã - –ø—Ä–æ—â–µ –ø–æ–∏—Å–∫
          baseConfig.stepSizes.Œ± *= 1.5;
          baseConfig.stepSizes.Œ≤ *= 1.5;
        }
        
        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
        const estimatedMsPerIter = 0.3;
        const affordableIterations = timeBudgetMs / estimatedMsPerIter;
        if (affordableIterations < baseConfig.maxIterations) {
          baseConfig.maxIterations = Math.floor(affordableIterations * 0.9);
          // –£—Å–∫–æ—Ä—è–µ–º –æ—Ö–ª–∞–∂–¥–µ–Ω–∏–µ –¥–ª—è –º–µ–Ω—å—à–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
          baseConfig.coolingRate = Math.max(0.95, baseConfig.coolingRate * 0.99);
        }
        
        return baseConfig;
      }
      
      static calibrateInitialTemperature(targetParams, samples = 20) {
        // –ë—ã—Å—Ç—Ä–∞—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
        let totalPositiveDelta = 0;
        let positiveCount = 0;
        
        const currentState = {
          Œ±: Math.random() * Math.PI,
          Œ≤: Math.random() * Math.PI,
          R: 1.0
        };
        
        currentState.params = calculateAllParamsFromAngles(currentState.Œ±, currentState.Œ≤, currentState.R);
        currentState.error = calculateErrorWithScale(currentState.params, targetParams);
        
        for (let i = 0; i < samples; i++) {
          const neighbor = this.generateRandomNeighbor(currentState, { Œ±: 0.2, Œ≤: 0.2, R: 0.1 });
          neighbor.params = calculateAllParamsFromAngles(neighbor.Œ±, neighbor.Œ≤, neighbor.R);
          neighbor.error = calculateErrorWithScale(neighbor.params, targetParams);
          
          const delta = neighbor.error - currentState.error;
          if (delta > 0) {
            totalPositiveDelta += delta;
            positiveCount++;
          }
        }
        
        if (positiveCount === 0) return 1000; // –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        const avgPositiveDelta = totalPositiveDelta / positiveCount;
        
        // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–æ–ª–∂–Ω–∞ –¥–∞–≤–∞—Ç—å ~80% –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–∏–Ω—è—Ç–∏—è —Å—Ä–µ–¥–Ω–µ–≥–æ —É—Ö—É–¥—à–µ–Ω–∏—è
        const desiredAcceptance = 0.8;
        const T0 = -avgPositiveDelta / Math.log(desiredAcceptance);
        
        return Math.max(100, Math.min(5000, T0));
      }
      
      static generateRandomNeighbor(state, stepSizes) {
        const neighbor = { ...state };
        
        // –°–ª—É—á–∞–π–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ —Å –Ω–æ—Ä–º–∞–ª—å–Ω—ã–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º
        neighbor.Œ± += (Math.random() - 0.5) * 2 * stepSizes.Œ±;
        neighbor.Œ≤ += (Math.random() - 0.5) * 2 * stepSizes.Œ≤;
        neighbor.R += (Math.random() - 0.5) * 2 * stepSizes.R;
        
        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
        neighbor.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, neighbor.Œ±));
        neighbor.Œ≤ = Math.max(0.01, Math.min(Math.PI - neighbor.Œ± - 0.01, neighbor.Œ≤));
        neighbor.R = Math.max(0.001, Math.min(10.0, neighbor.R));
        
        return neighbor;
      }
    }
    
    // –û—Å–Ω–æ–≤–Ω–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º –æ—Ç–∂–∏–≥–∞
    class AdaptiveSimulatedAnnealing {
      constructor(targetParams, progressCallback) {
        this.targetParams = targetParams;
        this.progressCallback = progressCallback;
        
        // –ê–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á–∏ –∏ –∞–≤—Ç–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞
        this.analysis = AutoSAConfigurator.analyzeProblem(targetParams);
        this.config = AutoSAConfigurator.generateConfig(this.analysis);
        
        // –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
        this.config.initialTemperature = AutoSAConfigurator.calibrateInitialTemperature(targetParams);
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        this.currentState = this.initializeState();
        this.bestState = { ...this.currentState };
        this.temperature = this.config.initialTemperature;
        
        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        this.iterations = 0;
        this.acceptedMoves = 0;
        this.improvements = 0;
        this.stagnationCounter = 0;
        this.lastImprovementIteration = 0;
        
        // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        this.currentStepSizes = { ...this.config.stepSizes };
        this.acceptanceHistory = [];
      }
      
      initializeState() {
        // –ù–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        const strategies = [
          // –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π
          () => ({ Œ±: Math.PI/3, Œ≤: Math.PI/3, R: 1.0 }),
          
          // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π
          () => ({ Œ±: Math.PI/2, Œ≤: Math.PI/4, R: 1.0 }),
          
          // –û—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω—ã–π
          () => ({ Œ±: Math.PI*0.4, Œ≤: Math.PI*0.4, R: 1.0 }),
          
          // –°–ª—É—á–∞–π–Ω—ã–π
          () => ({
            Œ±: 0.1 + Math.random() * (Math.PI - 0.2),
            Œ≤: 0.1 + Math.random() * (Math.PI - 0.2),
            R: 0.5 + Math.random() * 2.0
          })
        ];
        
        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        const initFunc = strategies[Math.floor(Math.random() * strategies.length)];
        const state = initFunc();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º
        state.Œ≤ = Math.min(state.Œ≤, Math.PI - state.Œ± - 0.01);
        state.R = Math.max(0.1, Math.min(5.0, state.R));
        
        // –í—ã—á–∏—Å–ª—è–µ–º –æ—à–∏–±–∫—É
        state.params = calculateAllParamsFromAngles(state.Œ±, state.Œ≤, state.R);
        state.error = calculateErrorWithScale(state.params, this.targetParams);
        
        return state;
      }
      
      generateNeighbor() {
        const neighbor = AutoSAConfigurator.generateRandomNeighbor(this.currentState, this.currentStepSizes);
        neighbor.params = calculateAllParamsFromAngles(neighbor.Œ±, neighbor.Œ≤, neighbor.R);
        neighbor.error = calculateErrorWithScale(neighbor.params, this.targetParams);
        return neighbor;
      }
      
      acceptanceProbability(deltaError) {
        if (deltaError < 0) return 1.0;
        return Math.exp(-deltaError / this.temperature);
      }
      
      coolDown() {
        // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –æ—Ö–ª–∞–∂–¥–µ–Ω–∏–µ
        this.temperature *= this.config.coolingRate;
        
        // –ù–µ –æ–ø—É—Å–∫–∞–µ–º—Å—è –Ω–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
        if (this.temperature < this.config.minTemperature) {
          this.temperature = this.config.minTemperature;
        }
      }
      
      adaptStepSizes() {
        if (!this.config.adaptiveSteps) return;
        
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π
        const recentAcceptance = this.getRecentAcceptanceRate();
        
        if (recentAcceptance < 0.2) {
          // –°–ª–∏—à–∫–æ–º –º–∞–ª–æ –ø—Ä–∏–Ω—è—Ç–∏–π - —É–º–µ–Ω—å—à–∞–µ–º —à–∞–≥–∏
          this.currentStepSizes.Œ± *= 0.9;
          this.currentStepSizes.Œ≤ *= 0.9;
          this.currentStepSizes.R *= 0.9;
        } else if (recentAcceptance > 0.6) {
          // –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø—Ä–∏–Ω—è—Ç–∏–π - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —à–∞–≥–∏
          this.currentStepSizes.Œ± = Math.min(0.5, this.currentStepSizes.Œ± * 1.1);
          this.currentStepSizes.Œ≤ = Math.min(0.5, this.currentStepSizes.Œ≤ * 1.1);
          this.currentStepSizes.R = Math.min(0.3, this.currentStepSizes.R * 1.1);
        }
        
        // –ù–∏–∂–Ω–∏–π –ø—Ä–µ–¥–µ–ª —à–∞–≥–æ–≤
        this.currentStepSizes.Œ± = Math.max(this.config.minStepSize, this.currentStepSizes.Œ±);
        this.currentStepSizes.Œ≤ = Math.max(this.config.minStepSize, this.currentStepSizes.Œ≤);
        this.currentStepSizes.R = Math.max(this.config.minStepSize * 0.5, this.currentStepSizes.R);
      }
      
      getRecentAcceptanceRate() {
        const historyLength = Math.min(100, this.acceptanceHistory.length);
        if (historyLength === 0) return 0.5;
        
        const recent = this.acceptanceHistory.slice(-historyLength);
        return recent.filter(a => a).length / historyLength;
      }
      
      checkForRestart() {
        if (!this.config.enableRestarts) return false;
        
        const stagnation = this.iterations - this.lastImprovementIteration;
        if (stagnation < this.config.restartAfterStagnation) return false;
        
        // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è —Å —Ä–æ—Å—Ç–æ–º –∑–∞—Å—Ç–æ—è
        const restartProb = this.config.restartProbability * 
          (stagnation / this.config.restartAfterStagnation);
        
        return Math.random() < restartProb;
      }
      
      performRestart() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª—É—á—à–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        const savedBest = { ...this.bestState };
        
        // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Å –Ω–æ–≤–æ–π —Å–ª—É—á–∞–π–Ω–æ–π —Ç–æ—á–∫–∏
        this.currentState = this.initializeState();
        
        // –ß–∞—Å—Ç–∏—á–Ω–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É (–Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é)
        this.temperature = Math.max(
          this.config.minTemperature * 10,
          this.temperature * 2.0
        );
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏
        this.stagnationCounter = 0;
        this.acceptanceHistory = [];
        
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ, –µ—Å–ª–∏ –æ–Ω–æ –±—ã–ª–æ
        if (savedBest.error < this.currentState.error) {
          this.currentState = { ...savedBest };
          this.bestState = { ...savedBest };
        }
        
        return true;
      }
      
      localRefinement(state) {
        // –í—ã–ø–æ–ª–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –æ–Ω–æ –≤–∫–ª—é—á–µ–Ω–æ –∏ –µ—Å—Ç—å —à–∞–Ω—Å —É–ª—É—á—à–µ–Ω–∏—è
        if (!this.config.localRefinement || !Number.isFinite(state.error) || state.error > this.config.refinementThreshold) {
          return state;
        }

        // –£—Ç–∏–ª–∏—Ç—ã –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
        const EPS = 1e-12;
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

        // –¶–µ–ª–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è (Œ±, Œ≤, logR) -> error
        const objective = (x) => {
          let Œ± = x[0], Œ≤ = x[1];
          const logR = x[2];

          if (!Number.isFinite(Œ±) || !Number.isFinite(Œ≤) || !Number.isFinite(logR)) return Infinity;

          // –ë–∞–∑–æ–≤—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: Œ±>0, Œ≤>0, Œ≥>0
          const lim = Math.PI - 1e-9;
          Œ± = clamp(Œ±, 1e-9, lim);
          Œ≤ = clamp(Œ≤, 1e-9, lim);

          if (Œ± + Œ≤ >= lim) {
            // –º—è–≥–∫–æ ¬´–≤–¥–∞–≤–ª–∏–≤–∞–µ–º¬ª –≤ –¥–æ–ø—É—Å—Ç–∏–º—É—é –æ–±–ª–∞—Å—Ç—å
            const scale = (lim - 1e-9) / (Œ± + Œ≤);
            Œ± *= scale;
            Œ≤ *= scale;
          }

          const R = Math.exp(logR);
          if (!Number.isFinite(R) || R <= 0) return Infinity;

          const params = calculateAllParamsFromAngles(Œ±, Œ≤, R);
          if (!params) return Infinity;

          const err = calculateErrorWithScale(params, this.targetParams);
          return Number.isFinite(err) ? err : Infinity;
        };

        // Nelder‚ÄìMead (—Ä–æ–±–∞—Å—Ç–Ω–æ–µ –±–µ–∑–≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ)
        const nelderMead = (x0, step, maxIter) => {
          const n = x0.length;

          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–º–ø–ª–µ–∫—Å–∞
          const simplex = [];
          simplex.push({ x: x0.slice(), f: objective(x0) });
          for (let i = 0; i < n; i++) {
            const xi = x0.slice();
            xi[i] += step[i];
            simplex.push({ x: xi, f: objective(xi) });
          }

          const Œ±c = 1.0;   // reflection
          const Œ≥c = 2.0;   // expansion
          const œÅc = 0.5;   // contraction
          const œÉc = 0.5;   // shrink

          let best = simplex[0];

          for (let iter = 0; iter < maxIter; iter++) {
            simplex.sort((a, b) => a.f - b.f);

            if (simplex[0].f < best.f) best = { x: simplex[0].x.slice(), f: simplex[0].f };

            // –∫—Ä–∏—Ç–µ—Ä–∏–π –æ—Å—Ç–∞–Ω–æ–≤–∞: –º–∞–ª–∞—è ¬´—à–∏—Ä–∏–Ω–∞¬ª –ø–æ f
            const f0 = simplex[0].f, fn = simplex[n].f;
            if (Number.isFinite(f0) && Number.isFinite(fn) && Math.abs(fn - f0) < 1e-12) break;
            if (best.f < 1e-8) break;

            // –¶–µ–Ω—Ç—Ä–æ–∏–¥ –≤—Å–µ—Ö –∫—Ä–æ–º–µ —Ö—É–¥—à–µ–π —Ç–æ—á–∫–∏
            const centroid = new Array(n).fill(0);
            for (let i = 0; i < n; i++) {
              for (let j = 0; j < n; j++) centroid[j] += simplex[i].x[j];
            }
            for (let j = 0; j < n; j++) centroid[j] /= n;

            const worst = simplex[n];
            const secondWorst = simplex[n - 1];

            // –û—Ç—Ä–∞–∂–µ–Ω–∏–µ
            const xr = centroid.map((c, j) => c + Œ±c * (c - worst.x[j]));
            const fr = objective(xr);

            if (fr < simplex[0].f) {
              // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ
              const xe = centroid.map((c, j) => c + Œ≥c * (xr[j] - c));
              const fe = objective(xe);
              simplex[n] = (fe < fr) ? { x: xe, f: fe } : { x: xr, f: fr };
              continue;
            }

            if (fr < secondWorst.f) {
              simplex[n] = { x: xr, f: fr };
              continue;
            }

            // –°–∂–∞—Ç–∏–µ
            let xc;
            if (fr < worst.f) {
              // –≤–Ω–µ—à–Ω–µ–µ
              xc = centroid.map((c, j) => c + œÅc * (xr[j] - c));
            } else {
              // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ
              xc = centroid.map((c, j) => c - œÅc * (c - worst.x[j]));
            }
            const fc = objective(xc);

            if (fc < worst.f) {
              simplex[n] = { x: xc, f: fc };
              continue;
            }

            // –°–∂–∞—Ç–∏–µ —Å–∏–º–ø–ª–µ–∫—Å–∞ –∫ –ª—É—á—à–µ–π —Ç–æ—á–∫–µ
            const bestX = simplex[0].x;
            for (let i = 1; i < simplex.length; i++) {
              const xs = bestX.map((bx, j) => bx + œÉc * (simplex[i].x[j] - bx));
              simplex[i] = { x: xs, f: objective(xs) };
            }
          }

          // –§–∏–Ω–∞–ª—å–Ω—ã–π best
          simplex.sort((a, b) => a.f - b.f);
          return (simplex[0].f < best.f) ? simplex[0] : best;
        };

        // –°—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞: —Ç–µ–∫—É—â–µ–µ –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ
        const xStart = [state.Œ±, state.Œ≤, Math.log(Math.max(state.R, 1e-12))];

        // –ë–∞–∑–æ–≤—ã–µ —à–∞–≥–∏ (–∞–¥–∞–ø—Ç–∏–≤–Ω–æ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –º–∞—Å—à—Ç–∞–±–∞)
        const baseStep = [
          Math.max(1e-4, Math.abs(state.Œ±) * 1e-3),
          Math.max(1e-4, Math.abs(state.Œ≤) * 1e-3),
          1e-3
        ];

        let bestNM = nelderMead(xStart, baseStep, 700);

        // –ù–µ—Å–∫–æ–ª—å–∫–æ —Ä–µ—Å—Ç–∞—Ä—Ç–æ–≤ –≤–æ–∫—Ä—É–≥ –ª—É—á—à–µ–π —Ç–æ—á–∫–∏ (–¥–ª—è —É—Ö–æ–¥–∞ –∏–∑ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –º–∏–Ω–∏–º—É–º–æ–≤)
        const restarts = 10;
        for (let k = 0; k < restarts; k++) {
          const s = Math.exp(-k / 3);
          const x0 = [
            bestNM.x[0] + (Math.random() * 2 - 1) * baseStep[0] * 10 * s,
            bestNM.x[1] + (Math.random() * 2 - 1) * baseStep[1] * 10 * s,
            bestNM.x[2] + (Math.random() * 2 - 1) * baseStep[2] * 5 * s
          ];
          const step = [baseStep[0] * 5 * s, baseStep[1] * 5 * s, baseStep[2] * 2 * s];
          const cand = nelderMead(x0, step, 450);
          if (cand.f < bestNM.f) bestNM = cand;
          if (bestNM.f < 1e-8) break;
        }

        // –ï—Å–ª–∏ —É–ª—É—á—à–∏–ª–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π state
        if (Number.isFinite(bestNM.f) && bestNM.f + 1e-15 < state.error) {
          const Œ± = bestNM.x[0], Œ≤ = bestNM.x[1], R = Math.exp(bestNM.x[2]);
          const params = calculateAllParamsFromAngles(Œ±, Œ≤, R);
          const improved = {
            ...state,
            Œ±, Œ≤, R,
            params,
            error: bestNM.f
          };
          return improved;
        }

        return state;
      }

      async optimize() {
        const startTime = Date.now();
        let lastProgressUpdate = 0;
        
        for (this.iterations = 0; this.iterations < this.config.maxIterations; this.iterations++) {
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞
          if (this.checkForRestart()) {
            this.performRestart();
            continue;
          }
          
          // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–æ—Å–µ–¥–Ω–µ–≥–æ —Ä–µ—à–µ–Ω–∏—è
          const neighbor = this.generateNeighbor();
          
          // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏
          const deltaError = neighbor.error - this.currentState.error;
          
          // –ü—Ä–∞–≤–∏–ª–æ –ú–µ—Ç—Ä–æ–ø–æ–ª–∏—Å–∞
          const acceptanceProb = this.acceptanceProbability(deltaError);
          const accepted = deltaError < 0 || Math.random() < acceptanceProb;
          
          // –ó–∞–ø–∏—Å—å –≤ –∏—Å—Ç–æ—Ä–∏—é
          this.acceptanceHistory.push(accepted);
          if (this.acceptanceHistory.length > 1000) {
            this.acceptanceHistory.shift();
          }
          
          if (accepted) {
            this.acceptedMoves++;
            this.currentState = neighbor;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ
            if (this.currentState.error < this.bestState.error) {
              this.bestState = { ...this.currentState };
              this.improvements++;
              this.lastImprovementIteration = this.iterations;
              this.stagnationCounter = 0;
            } else {
              this.stagnationCounter++;
            }
          }
          
          // –û—Ö–ª–∞–∂–¥–µ–Ω–∏–µ
          this.coolDown();
          
          // –ê–¥–∞–ø—Ç–∞—Ü–∏—è —à–∞–≥–æ–≤
          if (this.iterations % 100 === 0) {
            this.adaptStepSizes();
          }
          
          // –û—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ
          const currentTime = Date.now();
          if (currentTime - lastProgressUpdate > 100) { // –ù–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ 100–º—Å
            const progress = (this.iterations / this.config.maxIterations) * 100;
            this.progressCallback(progress, this.iterations, this.bestState.error);
            lastProgressUpdate = currentTime;
          }
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
          if (this.shouldStop()) {
            break;
          }
          
          // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–≥–æ UI
          if (this.iterations % 100 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
          }
        }
        
        // –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–∫–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
        this.bestState = this.localRefinement(this.bestState);
        
        // –§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç
        const totalTime = Date.now() - startTime;
        this.progressCallback(100, this.iterations, this.bestState.error);
        
        return {
          state: this.bestState,
          stats: {
            iterations: this.iterations,
            acceptedMoves: this.acceptedMoves,
            improvements: this.improvements,
            finalTemperature: this.temperature,
            finalError: this.bestState.error,
            totalTime: totalTime,
            config: this.config
          }
        };
      }
      
      shouldStop() {
        // 1. –î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å
        if (this.bestState.error < 1e-6) return true;
        
        // 2. –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
        if (this.temperature < this.config.minTemperature * 10) {
          const recentAcceptance = this.getRecentAcceptanceRate();
          if (recentAcceptance < 0.01) return true;
        }
        
        // 3. –°–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ –Ω–µ—Ç —É–ª—É—á—à–µ–Ω–∏–π
        const stagnation = this.iterations - this.lastImprovementIteration;
        if (stagnation > this.config.maxIterations * 0.5) return true;
        
        return false;
      }
    }
    
    // ========== –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò ==========
    async function optimizeTriangleWithSimulatedAnnealing(targetParams, progressCallback) {
      try {
        showStatusMessage('–ê–≤—Ç–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –æ—Ç–∂–∏–≥–∞...', 'info');
        
        // –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –æ—Ç–∂–∏–≥–∞
        const sa = new AdaptiveSimulatedAnnealing(targetParams, progressCallback);
        const result = await sa.optimize();
        
        // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
        const solution = {
          points: calculateTrianglePoints(result.state.Œ±, result.state.Œ≤, result.state.R),
          params: result.state.params,
          scale: result.state.R,
          angles: {
            Œ±: result.state.Œ± * 180 / Math.PI,
            Œ≤: result.state.Œ≤ * 180 / Math.PI,
            Œ≥: (Math.PI - result.state.Œ± - result.state.Œ≤) * 180 / Math.PI
          },
          type: determineTriangleType(result.state.params),
          error: result.state.error,
          iterations: result.stats.iterations,
          stats: result.stats
        };
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        solution.metadata = {
          algorithm: 'Adaptive Simulated Annealing',
          config: result.stats.config,
          autoConfigured: true,
          complexity: sa.analysis.complexity
        };
        
        
        // ====== –õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—ã—Å–æ–∫–æ—Ç–æ—á–Ω–æ–µ –¥–æ–∂–∏–º–∞–Ω–∏–µ (–ø–æ—Å–ª–µ –æ—Ç–∂–∏–≥–∞) ======
        try {
          await progressCallback(95, result.iteration || 0, result.state.error, "–õ–æ–∫–∞–ª—å–Ω–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ...");
          const hpSolution = await optimizeTriangleHighPrecision(targetParams, progressCallback, result.state);
          if (hpSolution && Number.isFinite(hpSolution.error) && hpSolution.error < solution.error) {
            // –∑–∞–º–µ–Ω—è–µ–º —Ä–µ—à–µ–Ω–∏–µ –Ω–∞ —É—Ç–æ—á–Ω—ë–Ω–Ω–æ–µ
            solution.points = hpSolution.points;
            solution.params = hpSolution.params;
            solution.scale = hpSolution.scale;
            solution.angles = hpSolution.angles;
            solution.type = hpSolution.type;
            solution.error = hpSolution.error;
            solution.metadata = Object.assign({}, solution.metadata, { refined: true, refinement: 'HighPrecision (Nelder-Mead + LM + golden)' });
          }
        } catch (refineErr) {
          console.warn('–õ–æ–∫–∞–ª—å–Ω–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ:', refineErr);
        }

        showStatusMessage(`–ê–ª–≥–æ—Ä–∏—Ç–º –æ—Ç–∂–∏–≥–∞ –∑–∞–≤–µ—Ä—à–µ–Ω: ${result.stats.iterations} –∏—Ç–µ—Ä–∞—Ü–∏–π, —Ç–æ—á–Ω–æ—Å—Ç—å ${(100 - result.state.error * 100).toFixed(2)}%`, 'success');
        
        return solution;
        
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–µ –æ—Ç–∂–∏–≥–∞:', error);
        throw error;
      }
    }

    // ========== –í–´–°–û–ö–û–¢–û–ß–ù–û–ï –£–¢–û–ß–ù–ï–ù–ò–ï (–ª–æ–∫–∞–ª—å–Ω—ã–π –¥–æ–∂–∏–º) ==========
    class HighPrecisionOptimizer {
        constructor(targetParams, progressCallback, seedState = null) {
            this.targetParams = targetParams;
            this.progressCallback = progressCallback;
            this.seedState = seedState;
            this.bestSolution = null;
            this.bestError = Infinity;
            this.stats = {
                totalIterations: 0,
                startTime: Date.now(),
                convergenceHistory: []
            };
        }

        async optimize() {
            try {
                // –§–ê–ó–ê 0: –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ (10%)
                await this.progressCallback(5, 0, Infinity, "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...");
                const initialGuess = this.generateInitialGuesses();
                
                // –§–ê–ó–ê 1: –ú–Ω–æ–≥–æ–∑–∞–ø—É—Å–∫–æ–≤—ã–π –ø–æ–∏—Å–∫ –º–µ—Ç–æ–¥–æ–º –ù–µ–ª–¥–µ—Ä–∞-–ú–∏–¥–∞ (30%)
                await this.progressCallback(10, 0, Infinity, "–ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫...");
                const nmSolutions = await this.nelderMeadMultiStart(initialGuess, 20);
                
                // –§–ê–ó–ê 2: –£—Ç–æ—á–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –õ–µ–≤–µ–Ω–±–µ—Ä–≥–∞-–ú–∞—Ä–∫–≤–∞—Ä–¥—Ç–∞ (40%)
                await this.progressCallback(40, 0, nmSolutions.bestError, "–¢–æ—á–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è...");
                const lmSolution = await this.levenbergMarquardt(nmSolutions.bestState, 30);
                
                // –§–ê–ó–ê 3: –ú–∏–∫—Ä–æ-–∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ –º–µ—Ç–æ–¥–æ–º –∑–æ–ª–æ—Ç–æ–≥–æ —Å–µ—á–µ–Ω–∏—è (15%)
                await this.progressCallback(70, 0, lmSolution.error, "–ú–∏–∫—Ä–æ-–∫–æ—Ä—Ä–µ–∫—Ü–∏–∏...");
                const refinedSolution = await this.goldenSectionRefinement(lmSolution, 10);
                
                // –§–ê–ó–ê 4: –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏ (5%)
                await this.progressCallback(90, 0, refinedSolution.error, "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏...");
                const finalSolution = await this.finalPrecisionCheck(refinedSolution, 5);
                
                return this.prepareFinalSolution(finalSolution);
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:', error);
                throw error;
            }
        }

        generateInitialGuesses() {
            const guesses = [];
            // 0. Seed from previous optimizer (if provided)
            if (this.seedState && Number.isFinite(this.seedState.Œ±) && Number.isFinite(this.seedState.Œ≤)) {
                guesses.push({
                    Œ±: this.seedState.Œ±,
                    Œ≤: this.seedState.Œ≤,
                    R: Number.isFinite(this.seedState.R) ? this.seedState.R : 1.0
                });
            }
            
            // 1. –ù–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–¥–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å —É–≥–ª—ã)
            if (this.targetParams.angleA && this.targetParams.angleB) {
                guesses.push({
                    Œ±: this.targetParams.angleA * Math.PI / 180,
                    Œ≤: this.targetParams.angleB * Math.PI / 180,
                    R: this.targetParams.circumradius || 1.0
                });
            }
            
            // 2. –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
            guesses.push({
                Œ±: Math.PI/3,
                Œ≤: Math.PI/3,
                R: 1.0
            });
            
            // 3. –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
            guesses.push({
                Œ±: Math.PI/2,
                Œ≤: Math.PI/4,
                R: 1.0
            });
            
            // 4. –°–ª—É—á–∞–π–Ω—ã–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è
            for (let i = 0; i < 5; i++) {
                guesses.push({
                    Œ±: 0.2 + Math.random() * (Math.PI - 0.4),
                    Œ≤: 0.2 + Math.random() * (Math.PI - 0.4),
                    R: 0.5 + Math.random() * 2.0
                });
            }
            
            return guesses;
        }

        async nelderMeadMultiStart(initialGuesses, maxIterations = 100) {
            const solutions = [];
            
            for (const guess of initialGuesses) {
                const solution = await this.nelderMeadOptimization(guess, maxIterations);
                solutions.push(solution);
                
                // –†–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
                if (solution.error < 1e-8) {
                    break;
                }
            }
            
            // –í—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ
            let bestIndex = 0;
            let bestError = Infinity;
            
            solutions.forEach((sol, idx) => {
                if (sol.error < bestError) {
                    bestError = sol.error;
                    bestIndex = idx;
                }
            });
            
            return {
                bestState: solutions[bestIndex].state,
                bestError: bestError,
                allSolutions: solutions
            };
        }

        async nelderMeadOptimization(initialState, maxIterations) {
            const Œ± = 1.0;  // Reflection coefficient
            const Œ≥ = 2.0;  // Expansion coefficient
            const œÅ = 0.5;  // Contraction coefficient
            const œÉ = 0.5;  // Shrink coefficient
            
            // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Å–∏–º–ø–ª–µ–∫—Å
            let simplex = [initialState];
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫–∏ –≤–æ–∫—Ä—É–≥ –Ω–∞—á–∞–ª—å–Ω–æ–π
            for (let i = 0; i < 3; i++) {
                const point = {
                    Œ±: Math.max(0.01, Math.min(Math.PI - 0.02, initialState.Œ± + (Math.random() - 0.5) * 0.2)),
                    Œ≤: Math.max(0.01, Math.min(Math.PI - initialState.Œ± - 0.01, initialState.Œ≤ + (Math.random() - 0.5) * 0.2)),
                    R: Math.max(0.001, Math.min(10.0, initialState.R * (1 + (Math.random() - 0.5) * 0.2)))
                };
                
                point.params = calculateAllParamsFromAngles(point.Œ±, point.Œ≤, point.R);
                point.error = this.calculateError(point);
                simplex.push(point);
            }
            
            let iteration = 0;
            
            while (iteration < maxIterations) {
                iteration++;
                this.stats.totalIterations++;
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–∏–º–ø–ª–µ–∫—Å –ø–æ –æ—à–∏–±–∫–µ
                simplex.sort((a, b) => a.error - b.error);
                
                // –õ—É—á—à–∞—è, —Å—Ä–µ–¥–Ω—è—è –∏ —Ö—É–¥—à–∞—è —Ç–æ—á–∫–∏
                const best = simplex[0];
                const worst = simplex[simplex.length - 1];
                const secondWorst = simplex[simplex.length - 2];
                
                // –¶–µ–Ω—Ç—Ä —Ç—è–∂–µ—Å—Ç–∏ (–±–µ–∑ —Ö—É–¥—à–µ–π —Ç–æ—á–∫–∏)
                const centroid = this.calculateCentroid(simplex.slice(0, -1));
                
                // –û—Ç—Ä–∞–∂–µ–Ω–∏–µ
                const reflected = this.reflectPoint(worst, centroid, Œ±);
                reflected.error = this.calculateError(reflected);
                
                if (reflected.error < best.error) {
                    // –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ
                    const expanded = this.reflectPoint(worst, centroid, Œ≥);
                    expanded.error = this.calculateError(expanded);
                    
                    if (expanded.error < reflected.error) {
                        simplex[simplex.length - 1] = expanded;
                    } else {
                        simplex[simplex.length - 1] = reflected;
                    }
                } else if (reflected.error < secondWorst.error) {
                    simplex[simplex.length - 1] = reflected;
                } else {
                    // –°–∂–∞—Ç–∏–µ
                    if (reflected.error < worst.error) {
                        // –í–Ω–µ—à–Ω–µ–µ —Å–∂–∞—Ç–∏–µ
                        const contracted = this.reflectPoint(worst, centroid, œÅ);
                        contracted.error = this.calculateError(contracted);
                        
                        if (contracted.error < reflected.error) {
                            simplex[simplex.length - 1] = contracted;
                        } else {
                            this.shrinkSimplex(simplex, best, œÉ);
                        }
                    } else {
                        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–∂–∞—Ç–∏–µ
                        const contracted = this.reflectPoint(worst, centroid, -œÅ);
                        contracted.error = this.calculateError(contracted);
                        
                        if (contracted.error < worst.error) {
                            simplex[simplex.length - 1] = contracted;
                        } else {
                            this.shrinkSimplex(simplex, best, œÉ);
                        }
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                if (iteration % 10 === 0) {
                    const progress = 10 + (iteration / maxIterations) * 20;
                    await this.progressCallback(
                        progress, 
                        iteration, 
                        best.error,
                        `–ù–µ–ª–¥–µ—Ä-–ú–∏–¥–∞: ${best.error.toExponential(3)}`
                    );
                    
                    // –ö—Ä–∏—Ç–µ—Ä–∏–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
                    const errorRange = simplex[simplex.length - 1].error - simplex[0].error;
                    if (errorRange < 1e-12) break;
                }
            }
            
            simplex.sort((a, b) => a.error - b.error);
            return {
                state: simplex[0],
                error: simplex[0].error,
                iterations: iteration
            };
        }

        async levenbergMarquardt(initialState, maxIterations = 50) {
            let state = { ...initialState };
            let Œª = 0.001; // –ü–∞—Ä–∞–º–µ—Ç—Ä –¥–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏—è
            let iteration = 0;
            let prevError = state.error;
            
            while (iteration < maxIterations) {
                iteration++;
                this.stats.totalIterations++;
                
                // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —è–∫–æ–±–∏–∞–Ω–∞ –∏ –Ω–µ–≤—è–∑–æ–∫
                const { J, residuals } = this.calculateJacobianAndResiduals(state);
                
                // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏—è –ì–µ—Å—Å–µ: H = J·µÄJ + ŒªI
                const JT = this.matrixTranspose(J);
                const JTJ = this.matrixMultiply(JT, J);
                const H = this.addDiagonal(JTJ, Œª);
                
                // –ì—Ä–∞–¥–∏–µ–Ω—Ç: g = J·µÄr
                const g = this.matrixVectorMultiply(JT, residuals);
                
                // –†–µ—à–∞–µ–º —Å–∏—Å—Ç–µ–º—É HŒî = -g
                const Œî = this.solveLinearSystem(H, this.vectorNegate(g));
                
                if (!Œî) {
                    Œª *= 10;
                    continue;
                }
                
                // –ü—Ä–æ–±—É–µ–º –Ω–æ–≤—ã–π —à–∞–≥
                const newState = {
                    Œ±: state.Œ± + Œî[0],
                    Œ≤: state.Œ≤ + Œî[1],
                    R: state.R * (1 + Œî[2] * 0.1) // –ú–µ–Ω—å—à–∏–π —à–∞–≥ –¥–ª—è —Ä–∞–¥–∏—É—Å–∞
                };
                
                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
                newState.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, newState.Œ±));
                newState.Œ≤ = Math.max(0.01, Math.min(Math.PI - newState.Œ± - 0.01, newState.Œ≤));
                newState.R = Math.max(0.001, Math.min(10.0, newState.R));
                
                // –ü–µ—Ä–µ—Å—á–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏ –æ—à–∏–±–∫–∏
                newState.params = calculateAllParamsFromAngles(newState.Œ±, newState.Œ≤, newState.R);
                newState.error = this.calculateError(newState);
                
                // –ê–¥–∞–ø—Ç–∞—Ü–∏—è Œª
                if (newState.error < state.error) {
                    // –£—Å–ø–µ—à–Ω—ã–π —à–∞–≥
                    state = newState;
                    Œª *= 0.1;
                    prevError = state.error;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
                    this.stats.convergenceHistory.push({
                        iteration: this.stats.totalIterations,
                        error: state.error,
                        Œª: Œª
                    });
                } else {
                    // –ù–µ—É–¥–∞—á–Ω—ã–π —à–∞–≥
                    Œª *= 10;
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                if (iteration % 5 === 0) {
                    const progress = 40 + (iteration / maxIterations) * 30;
                    await this.progressCallback(
                        progress, 
                        iteration, 
                        state.error,
                        `–õ–µ–≤–µ–Ω–±–µ—Ä–≥-–ú–∞—Ä–∫–≤–∞—Ä–¥—Ç: ${state.error.toExponential(6)}`
                    );
                    
                    // –ö—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
                    if (state.error < 1e-12) break;
                    if (Œª > 1e6) break;
                    if (Math.abs(prevError - state.error) < 1e-15) break;
                }
            }
            
            return {
                state: state,
                error: state.error,
                iterations: iteration
            };
        }

        async goldenSectionRefinement(solution, maxIterations = 20) {
            let state = { ...solution.state };
            const œÜ = (1 + Math.sqrt(5)) / 2; // –ó–æ–ª–æ—Ç–æ–µ —Å–µ—á–µ–Ω–∏–µ
            const tolerance = 1e-10;
            
            // –ü–æ–æ—á–µ—Ä–µ–¥–Ω–æ —É—Ç–æ—á–Ω—è–µ–º –∫–∞–∂–¥—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
            
            // 1. –£—Ç–æ—á–Ω–µ–Ω–∏–µ Œ±
            let [a, b] = [state.Œ± * 0.999, state.Œ± * 1.001];
            let [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
            
            for (let i = 0; i < maxIterations; i++) {
                const stateC = { ...state, Œ±: c };
                stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
                stateC.error = this.calculateError(stateC);
                
                const stateD = { ...state, Œ±: d };
                stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
                stateD.error = this.calculateError(stateD);
                
                if (stateC.error < stateD.error) {
                    b = d;
                } else {
                    a = c;
                }
                
                c = b - (b - a) / œÜ;
                d = a + (b - a) / œÜ;
                
                if (Math.abs(c - d) < tolerance) break;
            }
            
            state.Œ± = (a + b) / 2;
            
            // 2. –£—Ç–æ—á–Ω–µ–Ω–∏–µ Œ≤
            [a, b] = [state.Œ≤ * 0.999, state.Œ≤ * 1.001];
            [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
            
            for (let i = 0; i < maxIterations; i++) {
                const stateC = { ...state, Œ≤: c };
                stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
                stateC.error = this.calculateError(stateC);
                
                const stateD = { ...state, Œ≤: d };
                stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
                stateD.error = this.calculateError(stateD);
                
                if (stateC.error < stateD.error) {
                    b = d;
                } else {
                    a = c;
                }
                
                c = b - (b - a) / œÜ;
                d = a + (b - a) / œÜ;
                
                if (Math.abs(c - d) < tolerance) break;
            }
            
            state.Œ≤ = (a + b) / 2;
            
            // 3. –£—Ç–æ—á–Ω–µ–Ω–∏–µ R
            [a, b] = [state.R * 0.999, state.R * 1.001];
            [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
            
            for (let i = 0; i < maxIterations; i++) {
                const stateC = { ...state, R: c };
                stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
                stateC.error = this.calculateError(stateC);
                
                const stateD = { ...state, R: d };
                stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
                stateD.error = this.calculateError(stateD);
                
                if (stateC.error < stateD.error) {
                    b = d;
                } else {
                    a = c;
                }
                
                c = b - (b - a) / œÜ;
                d = a + (b - a) / œÜ;
                
                if (Math.abs(c - d) < tolerance) break;
            }
            
            state.R = (a + b) / 2;
            
            // –§–∏–Ω–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ—Å—á–µ—Ç
            state.params = calculateAllParamsFromAngles(state.Œ±, state.Œ≤, state.R);
            state.error = this.calculateError(state);
            
            return {
                state: state,
                error: state.error
            };
        }

        async finalPrecisionCheck(solution, maxIterations = 10) {
            let state = { ...solution.state };
            let bestState = { ...state };
            let bestError = state.error;
            
            // –ú–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã–µ –º–∏–∫—Ä–æ-–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏
            for (let i = 0; i < maxIterations; i++) {
                // –ü—Ä–æ–±—É–µ–º –º–∏–∫—Ä–æ-–≤–∞—Ä–∏–∞—Ü–∏–∏
                const variations = [];
                
                for (let j = 0; j < 8; j++) {
                    const variation = {
                        Œ±: state.Œ± * (1 + (Math.random() - 0.5) * 1e-6),
                        Œ≤: state.Œ≤ * (1 + (Math.random() - 0.5) * 1e-6),
                        R: state.R * (1 + (Math.random() - 0.5) * 1e-6)
                    };
                    
                    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
                    variation.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, variation.Œ±));
                    variation.Œ≤ = Math.max(0.01, Math.min(Math.PI - variation.Œ± - 0.01, variation.Œ≤));
                    variation.R = Math.max(0.001, Math.min(10.0, variation.R));
                    
                    variation.params = calculateAllParamsFromAngles(variation.Œ±, variation.Œ≤, variation.R);
                    variation.error = this.calculateError(variation);
                    variations.push(variation);
                }
                
                // –ù–∞—Ö–æ–¥–∏–º –ª—É—á—à—É—é –≤–∞—Ä–∏–∞—Ü–∏—é
                variations.sort((a, b) => a.error - b.error);
                
                if (variations[0].error < bestError) {
                    bestState = variations[0];
                    bestError = variations[0].error;
                    state = bestState;
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                await this.progressCallback(
                    90 + (i / maxIterations) * 5, 
                    i, 
                    bestError,
                    `–§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: ${bestError.toExponential(8)}`
                );
                
                if (bestError < 1e-12) break;
            }
            
            return {
                state: bestState,
                error: bestError
            };
        }

        calculateError(state) {
            return calculateErrorWithScale(state.params, this.targetParams);
        }

        calculateCentroid(points) {
            const centroid = { Œ±: 0, Œ≤: 0, R: 0 };
            
            points.forEach(point => {
                centroid.Œ± += point.Œ±;
                centroid.Œ≤ += point.Œ≤;
                centroid.R += point.R;
            });
            
            centroid.Œ± /= points.length;
            centroid.Œ≤ /= points.length;
            centroid.R /= points.length;
            
            return centroid;
        }

        reflectPoint(point, centroid, coefficient) {
            const reflected = {
                Œ±: centroid.Œ± + coefficient * (centroid.Œ± - point.Œ±),
                Œ≤: centroid.Œ≤ + coefficient * (centroid.Œ≤ - point.Œ≤),
                R: centroid.R + coefficient * (centroid.R - point.R)
            };
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
            reflected.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, reflected.Œ±));
            reflected.Œ≤ = Math.max(0.01, Math.min(Math.PI - reflected.Œ± - 0.01, reflected.Œ≤));
            reflected.R = Math.max(0.001, Math.min(10.0, reflected.R));
            
            return reflected;
        }

        shrinkSimplex(simplex, best, coefficient) {
            for (let i = 1; i < simplex.length; i++) {
                simplex[i] = {
                    Œ±: best.Œ± + coefficient * (simplex[i].Œ± - best.Œ±),
                    Œ≤: best.Œ≤ + coefficient * (simplex[i].Œ≤ - best.Œ≤),
                    R: best.R + coefficient * (simplex[i].R - best.R)
                };
                
                // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
                simplex[i].Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, simplex[i].Œ±));
                simplex[i].Œ≤ = Math.max(0.01, Math.min(Math.PI - simplex[i].Œ± - 0.01, simplex[i].Œ≤));
                simplex[i].R = Math.max(0.001, Math.min(10.0, simplex[i].R));
                
                simplex[i].params = calculateAllParamsFromAngles(simplex[i].Œ±, simplex[i].Œ≤, simplex[i].R);
                simplex[i].error = this.calculateError(simplex[i]);
            }
        }

        calculateJacobianAndResiduals(state) {
            const paramKeys = Object.keys(this.targetParams);
            const J = [];
            const residuals = [];
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —è–∫–æ–±–∏–∞–Ω–∞ (3 x N)
            for (let i = 0; i < 3; i++) {
                J.push(new Array(paramKeys.length).fill(0));
            }
            
            const Œ¥ = 1e-7; // –û—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–π —à–∞–≥ –¥–ª—è –≤—ã—Å–æ–∫–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
            const currentParams = state.params;
            
            paramKeys.forEach((key, col) => {
                const targetValue = this.targetParams[key];
                const currentValue = parseFloat(currentParams[key]);
                
                // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –Ω–µ–≤—è–∑–∫–∏
                let residual;
                if (key.includes('angle')) {
                  const diff = Math.abs(currentValue - targetValue);
                  residual = Math.min(diff, 360 - diff) / 180.0;
                } else {
                  residual = Math.abs(currentValue - targetValue) / Math.max(Math.abs(targetValue), 1e-10);
                }
                residuals.push(residual);
                
                // –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ Œ±
                const stateŒ± = { ...state, Œ±: state.Œ± + Œ¥ };
                stateŒ±.params = calculateAllParamsFromAngles(stateŒ±.Œ±, stateŒ±.Œ≤, stateŒ±.R);
                const valueŒ± = parseFloat(stateŒ±.params[key]);
                J[0][col] = (valueŒ± - currentValue) / Œ¥;
                
                // –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ Œ≤
                const stateŒ≤ = { ...state, Œ≤: state.Œ≤ + Œ¥ };
                stateŒ≤.params = calculateAllParamsFromAngles(stateŒ≤.Œ±, stateŒ≤.Œ≤, stateŒ≤.R);
                const valueŒ≤ = parseFloat(stateŒ≤.params[key]);
                J[1][col] = (valueŒ≤ - currentValue) / Œ¥;
                
                // –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –ø–æ R
                const stateR = { ...state, R: state.R * (1 + Œ¥) };
                stateR.params = calculateAllParamsFromAngles(stateR.Œ±, stateR.Œ≤, stateR.R);
                const valueR = parseFloat(stateR.params[key]);
                J[2][col] = (valueR - currentValue) / (Œ¥ * state.R);
            });
            
            return { J, residuals };
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–∞—Ç—Ä–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
        matrixTranspose(M) {
            const rows = M.length, cols = M[0].length;
            const result = new Array(cols);
            
            for (let j = 0; j < cols; j++) {
                result[j] = new Array(rows);
                for (let i = 0; i < rows; i++) {
                    result[j][i] = M[i][j];
                }
            }
            
            return result;
        }

        matrixMultiply(A, B) {
            const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
            const result = new Array(rowsA);
            
            for (let i = 0; i < rowsA; i++) {
                result[i] = new Array(colsB);
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            
            return result;
        }

        matrixVectorMultiply(M, v) {
            const rows = M.length;
            const result = new Array(rows);
            
            for (let i = 0; i < rows; i++) {
                let sum = 0;
                for (let j = 0; j < v.length; j++) {
                    sum += M[i][j] * v[j];
                }
                result[i] = sum;
            }
            
            return result;
        }

        addDiagonal(M, Œª) {
            const n = M.length;
            const result = [];
            
            for (let i = 0; i < n; i++) {
                result[i] = [...M[i]];
                result[i][i] += Œª;
            }
            
            return result;
        }

        vectorNegate(v) {
            return v.map(x => -x);
        }

        solveLinearSystem(A, b) {
            const n = A.length;
            const Ab = [];
            
            // –°–æ–∑–¥–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É
            for (let i = 0; i < n; i++) {
                Ab[i] = [...A[i], b[i]];
            }
            
            // –ú–µ—Ç–æ–¥ –ì–∞—É—Å—Å–∞ —Å –≤—ã–±–æ—Ä–æ–º –≥–ª–∞–≤–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            for (let i = 0; i < n; i++) {
                // –ü–æ–∏—Å–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                let maxRow = i;
                let maxVal = Math.abs(Ab[i][i]);
                
                for (let j = i + 1; j < n; j++) {
                    if (Math.abs(Ab[j][i]) > maxVal) {
                        maxRow = j;
                        maxVal = Math.abs(Ab[j][i]);
                    }
                }
                
                if (maxVal < 1e-15) return null;
                
                // –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫
                if (maxRow !== i) {
                    [Ab[i], Ab[maxRow]] = [Ab[maxRow], Ab[i]];
                }
                
                // –ù–æ—Ä–º–∏—Ä–æ–≤–∫–∞
                const pivot = Ab[i][i];
                for (let j = i; j <= n; j++) {
                    Ab[i][j] /= pivot;
                }
                
                // –ò—Å–∫–ª—é—á–µ–Ω–∏–µ
                for (let j = i + 1; j < n; j++) {
                    const factor = Ab[j][i];
                    for (let k = i; k <= n; k++) {
                        Ab[j][k] -= factor * Ab[i][k];
                    }
                }
            }
            
            // –û–±—Ä–∞—Ç–Ω–∞—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = Ab[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= Ab[i][j] * x[j];
                }
            }
            
            return x;
        }

        prepareFinalSolution(solution) {
            const finalPoints = calculateTrianglePoints(solution.state.Œ±, solution.state.Œ≤, solution.state.R);
            
            const finalSolution = {
                points: finalPoints,
                params: solution.state.params,
                scale: solution.state.R,
                angles: {
                    Œ±: solution.state.Œ± * 180 / Math.PI,
                    Œ≤: solution.state.Œ≤ * 180 / Math.PI,
                    Œ≥: (Math.PI - solution.state.Œ± - solution.state.Œ≤) * 180 / Math.PI
                },
                type: determineTriangleType(solution.state.params),
                error: solution.error,
                iterations: this.stats.totalIterations,
                stats: {
                    ...this.stats,
                    totalTime: Date.now() - this.stats.startTime,
                    finalPrecision: 100 - solution.error * 100
                }
            };
            
            return finalSolution;
        }
    }

    async function optimizeTriangleHighPrecision(targetParams, progressCallback, seedState = null) {
        showStatusMessage('–ó–∞–ø—É—Å–∫ –≤—ã—Å–æ–∫–æ—Ç–æ—á–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞...', 'info');
        
        const optimizer = new HighPrecisionOptimizer(targetParams,
            async (progress, iteration, error, status) => {
                progressCallback(progress, iteration, error, status);
            }
        , seedState);
        
        const solution = await optimizer.optimize();
        
        // –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–Ω–æ—Å—Ç—å –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
        const accuracy = Math.max(0, 100 - solution.error * 100);
        
        if (accuracy >= 99.999) {
            showStatusMessage(`‚úÖ –°–£–ü–ï–†-–¢–û–ß–ù–û–°–¢–¨: ${accuracy.toFixed(6)}%`, 'success');
        } else if (accuracy >= 99.99) {
            showStatusMessage(`‚úÖ –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: ${accuracy.toFixed(4)}%`, 'success');
        } else if (accuracy >= 99.9) {
            showStatusMessage(`‚úÖ –í—ã—Å–æ–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: ${accuracy.toFixed(3)}%`, 'success');
        } else if (accuracy >= 99.0) {
            showStatusMessage(`‚ö† –•–æ—Ä–æ—à–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: ${accuracy.toFixed(2)}%`, 'warning');
        } else {
            showStatusMessage(`‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å: ${accuracy.toFixed(2)}%`, 'error');
        }
        
        return solution;
    }


    
    // ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    
    function calculateErrorWithScale(currentParams, targetParams) {
      let totalError = 0;
      let weight = 0;
      const Œµ = 1e-10;
      
      for (const [key, targetValue] of Object.entries(targetParams)) {
        const currentValue = parseFloat(currentParams[key]);
        
        if (isNaN(currentValue)) {
          totalError += 1.0;
          weight += 1;
          continue;
        }
        
        let error;
        
        if (key.includes('angle')) {
          const diff = Math.abs(currentValue - targetValue);
          error = Math.min(diff, 360 - diff) / 180.0;
        } else if (key === 'circumradius') {
          const denominator = Math.max(Math.abs(targetValue), Œµ);
          error = Math.abs((currentValue - targetValue) / denominator);
        } else {
          const denominator = Math.max(Math.abs(targetValue), Œµ);
          error = Math.abs((currentValue - targetValue) / denominator);
        }
        
        const paramWeight = key.includes('angle') ? 2.0 : 
                           key === 'circumradius' ? 4.0 : 1.0;
        totalError += error * paramWeight;
        weight += paramWeight;
      }
      
      return weight > 0 ? totalError / weight : Infinity;
    }
    
    // ========== –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–†–ï–î–í–ê–†–ò–¢–ï–õ–¨–ù–û–ô –ü–†–û–í–ï–†–ö–ò ==========
    function preValidateParametersEnhanced(params) {
      // –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      const compatibility = checkParameterCompatibility(params);
      
      if (!compatibility.passed) {
        const errorMessages = compatibility.errors.map(e => e.message).join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏
      const practicalCheck = checkPracticalFeasibility(params);
      if (!practicalCheck.feasible) {
        const errorMessages = practicalCheck.errors.join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Ä–µ–∞–ª–∏–∑—É–µ–º—ã –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const numericalCheck = checkNumericalFeasibility(params);
      if (!numericalCheck.feasible) {
        const errorMessages = numericalCheck.issues.join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —á–∏—Å–ª–µ–Ω–Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–∑–∞–≤–µ–¥–æ–º–æ –Ω–µ—Ä–µ—à–∞–µ–º—ã–µ" –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏
      const vertexChecks = [
        { v: 'A', h: params.altitudeA, m: params.medianA, b: params.bisectorA },
        { v: 'B', h: params.altitudeB, m: params.medianB, b: params.bisectorB },
        { v: 'C', h: params.altitudeC, m: params.medianC, b: params.bisectorC }
      ];
      
      for (const check of vertexChecks) {
        // –ï—Å–ª–∏ –º–µ–¥–∏–∞–Ω–∞ –∑–∞–¥–∞–Ω–∞ –∏ –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã
        if (check.m && check.h && check.m < check.h) {
          return {
            valid: false,
            message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.v} (${check.m.toFixed(3)}) –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã (${check.h.toFixed(3)}). –≠—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ.`
          };
        }
        
        // –ï—Å–ª–∏ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∑–∞–¥–∞–Ω–∞ –∏ –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã
        if (check.b && check.h && check.b < check.h) {
          return {
            valid: false,
            message: `–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.v} (${check.b.toFixed(3)}) –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã (${check.h.toFixed(3)}). –≠—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ.`
          };
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ/–º–∞–ª–µ–Ω—å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
      const maxReasonableValue = 1e6;
      const minReasonableValue = 1e-6;
      
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined) {
          if (Math.abs(value) > maxReasonableValue) {
            return {
              valid: false,
              message: `–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`
            };
          }
          
          if (Math.abs(value) < minReasonableValue && !key.includes('angle')) {
            return {
              valid: false,
              message: `–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`
            };
          }
        }
      }
      
      // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
      const allWarnings = [
        ...compatibility.warnings.map(w => w.message),
        ...practicalCheck.warnings,
        ...numericalCheck.issues.filter(issue => !issue.includes('–æ—à–∏–±–∫–∞') && !issue.includes('–Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã'))
      ];
      
      if (allWarnings.length > 0) {
        return {
          valid: true,
          message: '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É',
          warnings: allWarnings
        };
      }
      
      return {
        valid: true,
        message: '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É'
      };
    }
    
    // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô ==========
    function showErrorMessage(message, persist = false) {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 10px;">
          <span style="font-size: 20px; color: #e74c3c;">‚ùå</span>
          <div style="flex: 1;">
            <strong style="color: #e74c3c;">–û—à–∏–±–∫–∞:</strong>
            <div style="white-space: pre-line; margin-top: 5px;">${message}</div>
          </div>
          ${persist ? '<button onclick="hideErrorMessage()" style="background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 18px;">√ó</button>' : ''}
        </div>
      `;
      errorDiv.classList.remove('hidden');
      
      // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è, —Å–∫—Ä—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
      if (!persist) {
        setTimeout(hideErrorMessage, 10000);
      }
    }
    
    function hideErrorMessage() {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.classList.add('hidden');
      errorDiv.innerHTML = '';
    }
    
    function showStatusMessage(message, type = 'info') {
      currentStatusMessages.push({ message, type, timestamp: Date.now() });
      updateStatusPanel();
    }
    
    function updateStatusPanel() {
      const panel = document.getElementById('statusPanel');
      const messagesDiv = document.getElementById('statusMessages');
      const inlinePanel = document.getElementById('statusMessagesInline');
      const inlineContent = document.getElementById('inlineStatusContent');
      
      if (!messagesDiv || !inlineContent) return;
      
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (—Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç)
      const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
      currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp > fiveMinutesAgo);
      
      if (currentStatusMessages.length === 0) {
        panel.style.display = 'none';
        inlinePanel.style.display = 'none';
        return;
      }
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ç–∏–ø—É (–æ—à–∏–±–∫–∏ –≤–≤–µ—Ä—Ö—É)
      currentStatusMessages.sort((a, b) => {
        const typeOrder = { 'error': 0, 'warning': 1, 'info': 2, 'success': 3 };
        return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
      });
      
      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
      messagesDiv.innerHTML = '';
      inlineContent.innerHTML = '';
      
      const icons = {
        'error': '‚ùå',
        'warning': '‚ö†Ô∏è',
        'info': '‚ÑπÔ∏è',
        'success': '‚úÖ'
      };
      
      currentStatusMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message status-${msg.type}`;
        
        const icon = icons[msg.type] || '‚ÑπÔ∏è';
        const timeAgo = Math.floor((Date.now() - msg.timestamp) / 1000);
        const timeText = timeAgo < 60 ? `${timeAgo} —Å–µ–∫ –Ω–∞–∑–∞–¥` : 
                        timeAgo < 3600 ? `${Math.floor(timeAgo/60)} –º–∏–Ω –Ω–∞–∑–∞–¥` : 
                        `${Math.floor(timeAgo/3600)} —á –Ω–∞–∑–∞–¥`;
        
        messageDiv.innerHTML = `
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 16px;">${icon}</span>
            <div style="flex: 1;">
              <div style="white-space: pre-line;">${msg.message}</div>
              <div style="font-size: 10px; color: #666; margin-top: 3px;">${timeText}</div>
            </div>
            <button onclick="removeStatusMessage(${msg.timestamp})" style="background: none; border: none; color: #666; cursor: pointer; font-size: 14px;">√ó</button>
          </div>
        `;
        
        messagesDiv.appendChild(messageDiv.cloneNode(true));
        inlineContent.appendChild(messageDiv);
      });
      
      panel.style.display = 'block';
      inlinePanel.style.display = 'block';
    }
    
    function removeStatusMessage(timestamp) {
      currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp !== timestamp);
      updateStatusPanel();
    }
    
    function clearStatusMessages() {
      currentStatusMessages = [];
      updateStatusPanel();
    }
    
    // ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    function startSolvingEnhanced() {
      if (isFindingAll) return;
      closeSolutionsPanel();
      hideCompatibilityPanel();
      
      // –ï—Å–ª–∏ —É–∂–µ –∏–¥–µ—Ç —Ä–∞—Å—á–µ—Ç - –≤—ã—Ö–æ–¥–∏–º
      const solveBtn = document.getElementById('solveBtn');
      if (solveBtn.textContent === '–í—ã—á–∏—Å–ª–µ–Ω–∏–µ...') {
        return;
      }
      
      if (!validateParameterSelection()) return;
      
      // –£–°–û–í–ï–†–®–ï–ù–°–¢–í–ê–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò
      const preCheck = preValidateParametersEnhanced(selectedParameters);
      if (!preCheck.valid) {
        showErrorMessage(preCheck.message, true);
        clearSolutionOnInvalidParams();
        return;
      }
      
      // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
      if (preCheck.warnings && preCheck.warnings.length > 0) {
        preCheck.warnings.forEach(warning => {
          showStatusMessage(warning, 'warning');
        });
      }
      
      solveBtn.disabled = true;
      solveBtn.textContent = '–í—ã—á–∏—Å–ª–µ–Ω–∏–µ...';
      
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const statusText = document.getElementById('statusText');
      
      progressContainer.style.display = 'block';
      progressText.textContent = '–ó–∞–ø—É—Å–∫ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –æ—Ç–∂–∏–≥–∞...';
      statusText.textContent = '–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è...';
      statusText.style.color = '#f39c12';
      
      // –û—á–∏—â–∞–µ–º —Ç–∞–π–º–µ—Ä –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç–∞
      if (autoCalculateTimer) {
        clearTimeout(autoCalculateTimer);
        autoCalculateTimer = null;
      }
      
      setTimeout(async () => {
        try {
          const solution = await optimizeTriangleWithSimulatedAnnealing(selectedParameters, (progress, iteration, error) => {
            progressBar.style.width = progress + '%';
            let status = '–ê–ª–≥–æ—Ä–∏—Ç–º –æ—Ç–∂–∏–≥–∞';
            if (error > 1.0) status = '–ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫';
            else if (error > 0.1) status = '–õ–æ–∫–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è';
            else status = '–¢–æ–Ω–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞';
            progressText.textContent = `${status}: ${iteration} –∏—Ç–µ—Ä–∞—Ü–∏–π, –æ—à–∏–±–∫–∞: ${error.toFixed(6)}`;
          });
          
          displaySolution(solution);
          
        } catch (error) {
          showErrorMessage(`–û—à–∏–±–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: ${error.message}`, true);
          clearSolutionOnInvalidParams();
        } finally {
          solveBtn.disabled = false;
          solveBtn.textContent = '–†–∞—Å—Å—á–∏—Ç–∞—Ç—å';
          progressText.textContent = '–ì–æ—Ç–æ–≤–æ';
          
          setTimeout(() => {
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
          }, 2000);
        }
      }, 100);
    }
    
    function initChart() {
      const ctx = document.getElementById('triangleChart').getContext('2d');
      
      chart = new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: -3.5, max: 3.5,
              grid: { color: 'rgba(0,0,0,0.1)' },
              title: { display: true, text: 'x' }
            },
            y: {
              min: -3.5, max: 3.5,
              grid: { color: 'rgba(0,0,0,0.1)' },
              title: { display: true, text: 'y' }
            }
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { font: { size: 10 }, boxWidth: 12 }
            },
            tooltip: { enabled: true }
          }
        }
      });
      
      applyTriangleYscale();
    }
    
    let triYscale = parseFloat(localStorage.getItem("triangle_yScale") || "100");
    const triBaseYmin = -3.5;
    const triBaseYmax = 3.5;

    function applyTriangleYscale() {
      if (!chart) return;
      const k = triYscale / 100;
      chart.options.scales.y.min = triBaseYmin * k;
      chart.options.scales.y.max = triBaseYmax * k;
      chart.update();
    }

    function initVerticalScaleControl() {
      const slider = document.getElementById("yScale");
      const label = document.getElementById("yScaleLabel");
      if (!slider || !label) return;
      
      slider.value = triYscale;
      label.textContent = triYscale + "%";
      
      slider.addEventListener("input", () => {
        triYscale = parseFloat(slider.value);
        label.textContent = triYscale + "%";
        localStorage.setItem("triangle_yScale", triYscale);
        applyTriangleYscale();
      });
    }
    
    function generateCirclePoints(radius, points = 100) {
      const circlePoints = [];
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        circlePoints.push({
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)
        });
      }
      return circlePoints;
    }
    
    function setupEventListeners() {
      ['value1', 'value2', 'value3'].forEach(id => {
        const input = document.getElementById(id);
        
        input.addEventListener('keypress', function(e) {
          if (e.key === 'Enter' && !document.getElementById('solveBtn').disabled) {
            startSolvingEnhanced();
          }
        });
        
        input.addEventListener('blur', function() {
          const index = parseInt(id.replace('value', ''));
          const paramKey = document.getElementById(`param${index}`).value;
          
          if (!paramKey) return;
          
          const range = paramRanges[paramKey];
          if (!range) return;
          
          const value = parseFloat(this.value);
          if (isNaN(value)) return;
          
          const clampedValue = Math.max(range.min, Math.min(range.max, value));
          
          if (Math.abs(value - clampedValue) > 0.001) {
            if (paramKey.includes('angle')) {
              this.value = clampedValue.toFixed(1);
            } else {
              this.value = clampedValue.toFixed(3);
            }
          }
          
          updateSliderFromInput(index, this.value);
        });
      });
    }
    
    function updateSliderFromInput(paramIndex, inputValue) {
      const paramKey = document.getElementById(`param${paramIndex}`).value;
      if (!paramKey) return;
      
      const range = paramRanges[paramKey];
      if (!range) return;
      
      const value = parseFloat(inputValue);
      if (isNaN(value)) return;
      
      const clampedValue = Math.max(range.min, Math.min(range.max, value));
      
      const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
      
      const slider = document.getElementById(`slider${paramIndex}`);
      const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
      const input = document.getElementById(`value${paramIndex}`);
      
      if (slider && valueDisplay && input) {
        slider.value = normalizedValue;
        
        let displayValue;
        if (paramKey.includes('angle')) {
          displayValue = clampedValue.toFixed(1) + '¬∞';
        } else {
          displayValue = clampedValue.toFixed(3);
        }
        
        valueDisplay.textContent = displayValue;
        
        const currentInputValue = parseFloat(input.value);
        if (isNaN(currentInputValue) || Math.abs(currentInputValue - clampedValue) > 0.001) {
          if (paramKey.includes('angle')) {
            input.value = clampedValue.toFixed(1);
          } else {
            input.value = clampedValue.toFixed(3);
          }
        }
      }
    }
    
    // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
    function calculateAllParamsFromAngles(Œ±, Œ≤, R = 1) {
      const Œ≥ = Math.PI - Œ± - Œ≤;
      
      if (!isValidTriangle(Œ±, Œ≤, Œ≥)) {
        return {
          sideBC: "0", sideAC: "0", sideAB: "0",
          angleA: "0", angleB: "0", angleC: "0",
          altitudeA: "0", altitudeB: "0", altitudeC: "0",
          bisectorA: "0", bisectorB: "0", bisectorC: "0",
          medianA: "0", medianB: "0", medianC: "0",
          circumradius: "0", inradius: "0", area: "0"
        };
      }
      
      const a = 2 * R * Math.sin(Œ±);
      const b = 2 * R * Math.sin(Œ≤);
      const c = 2 * R * Math.sin(Œ≥);
      
      const p = (a + b + c) / 2;
      const S = Math.sqrt(p * (p - a) * (p - b) * (p - c));
      
      const ha = 2 * S / a;
      const hb = 2 * S / b;
      const hc = 2 * S / c;
      
      const la = (2 * b * c * Math.cos(Œ± / 2)) / (b + c);
      const lb = (2 * a * c * Math.cos(Œ≤ / 2)) / (a + c);
      const lc = (2 * a * b * Math.cos(Œ≥ / 2)) / (a + b);
      
      const ma = 0.5 * Math.sqrt(2 * b * b + 2 * c * c - a * a);
      const mb = 0.5 * Math.sqrt(2 * a * a + 2 * c * c - b * b);
      const mc = 0.5 * Math.sqrt(2 * a * a + 2 * b * b - c * c);
      
      const r = S / p;
      
      const params = {};
      
      params.sideBC = a.toFixed(8);
      params.sideAC = b.toFixed(8);
      params.sideAB = c.toFixed(8);
      params.angleA = (Œ± * 180 / Math.PI).toFixed(8);
      params.angleB = (Œ≤ * 180 / Math.PI).toFixed(8);
      params.angleC = (Œ≥ * 180 / Math.PI).toFixed(8);
      params.altitudeA = ha.toFixed(8);
      params.altitudeB = hb.toFixed(8);
      params.altitudeC = hc.toFixed(8);
      params.bisectorA = la.toFixed(8);
      params.bisectorB = lb.toFixed(8);
      params.bisectorC = lc.toFixed(8);
      params.medianA = ma.toFixed(8);
      params.medianB = mb.toFixed(8);
      params.medianC = mc.toFixed(8);
      params.circumradius = R.toFixed(8);
      params.inradius = r.toFixed(8);
      params.area = S.toFixed(8);
      
      return params;
    }
    
    function calculateTrianglePoints(Œ±, Œ≤, R = 1) {
      const Œ≥ = Math.PI - Œ± - Œ≤;

      const A = { x: R, y: 0 };
      
      const Œ∏_B = 2 * Œ≥;
      const B = { 
        x: R * Math.cos(Œ∏_B), 
        y: R * Math.sin(Œ∏_B) 
      };
      
      const Œ∏_C = -2 * Œ≤;
      const C = { 
        x: R * Math.cos(Œ∏_C), 
        y: R * Math.sin(Œ∏_C) 
      };

      return { A, B, C };
    }
    
    function isValidTriangle(Œ±, Œ≤, Œ≥) {
      const Œµ = 1e-6;
      return (
        Œ± > Œµ && Œ≤ > Œµ && Œ≥ > Œµ &&
        Math.abs(Œ± + Œ≤ + Œ≥ - Math.PI) < Œµ
      );
    }
    
    // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ==========
    function displaySolution(solution) {
      if (!solution) return;

      const normalized = normalizeSolutionOrientation(solution);
      currentSolution = normalized;

      const statusText = document.getElementById('statusText');
      const accuracyText = document.getElementById('accuracyText');
      const iterationsText = document.getElementById('iterationsText');
      const scaleText = document.getElementById('scaleText');
      const angleAText = document.getElementById('angleAText');
      const angleBText = document.getElementById('angleBText');
      const angleCText = document.getElementById('angleCText');
      const triangleTypeText = document.getElementById('triangleTypeText');

      statusText.textContent = '–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ!';
      statusText.style.color = '#2ecc71';

      const accuracy = normalized.error ? Math.max(0, 100 - normalized.error * 100) : 100;
      accuracyText.textContent = accuracy >= 99.99 ? '>99.99%' : accuracy.toFixed(2) + '%';

      iterationsText.textContent = normalized.iterations || '0';
      scaleText.textContent = normalized.scale.toFixed(4);
      angleAText.textContent = `${normalized.angles.Œ±.toFixed(2)}¬∞`;
      angleBText.textContent = `${normalized.angles.Œ≤.toFixed(2)}¬∞`;
      angleCText.textContent = `${normalized.angles.Œ≥.toFixed(2)}¬∞`;
      triangleTypeText.textContent = getTriangleTypeName(normalized.type);

      updateChart(normalized);
      updateAllParamsTable(normalized);

      showStatusMessage(`–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é ${accuracy.toFixed(2)}%`, 'success');

      if (accuracy < 95) {
        showStatusMessage(`–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é ${accuracy.toFixed(2)}%`, 'warning');
      }
    }
    
    function normalizeSolutionOrientation(solution) {
      if (!solution || !solution.points) return solution;

      const points = solution.points;
      const A = points.A;
      const B = points.B;
      const C = points.C;

      if (!A || !B || !C) return solution;

      const cross = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);

      if (cross > 0) {
        return solution;
      }

      const newPoints = { A: A, B: C, C: B };

      const newAngles = solution.angles ? {
        Œ±: solution.angles.Œ±,
        Œ≤: solution.angles.Œ≥,
        Œ≥: solution.angles.Œ≤
      } : solution.angles;

      let newParams = solution.params ? { ...solution.params } : solution.params;

      if (newParams) {
        const oldSideAB = newParams.sideAB;
        const oldSideBC = newParams.sideBC;
        const oldSideAC = newParams.sideAC;

        newParams.sideAB = oldSideAC;
        newParams.sideBC = oldSideBC;
        newParams.sideAC = oldSideAB;

        if ('altitudeB' in newParams && 'altitudeC' in newParams) {
          const oldAltB = newParams.altitudeB;
          const oldAltC = newParams.altitudeC;
          newParams.altitudeB = oldAltC;
          newParams.altitudeC = oldAltB;
        }

        if ('medianB' in newParams && 'medianC' in newParams) {
          const oldMedB = newParams.medianB;
          const oldMedC = newParams.medianC;
          newParams.medianB = oldMedC;
          newParams.medianC = oldMedB;
        }

        if ('bisectorB' in newParams && 'bisectorC' in newParams) {
          const oldBisB = newParams.bisectorB;
          const oldBisC = newParams.bisectorC;
          newParams.bisectorB = oldBisC;
          newParams.bisectorC = oldBisB;
        }
      }

      return {
        ...solution,
        points: newPoints,
        angles: newAngles,
        params: newParams
      };
    }
    
    // ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –ì–†–ê–§–ò–ö–ê ==========
    function updateChart(solution) {
      if (!solution || !chart) return;
      
      const { A, B, C } = solution.points;
      const R = solution.scale;
      
      // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
      const Œ± = solution.angles.Œ± * Math.PI / 180;
      const Œ≤ = solution.angles.Œ≤ * Math.PI / 180;
      const Œ≥ = solution.angles.Œ≥ * Math.PI / 180;
      
      const a = parseFloat(solution.params.sideBC);
      const b = parseFloat(solution.params.sideAC);
      const c = parseFloat(solution.params.sideAB);
      const S = parseFloat(solution.params.area);
      
      // –¶–µ–Ω—Ç—Ä –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
      const incenter = {
        x: (a * A.x + b * B.x + c * C.x) / (a + b + c),
        y: (a * A.y + b * B.y + c * C.y) / (a + b + c)
      };
      
      const r = parseFloat(solution.params.inradius);
      
      const unitCirclePoints = generateCirclePoints(1, 100);
      const circumCirclePoints = generateCirclePoints(R, 100);
      const inCirclePoints = generateCirclePoints(r, 100).map(p => ({
        x: p.x + incenter.x,
        y: p.y + incenter.y
      }));
      
      const datasets = [
        {
          label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: unitCirclePoints,
          borderColor: '#3498db',
          backgroundColor: 'transparent',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderDash: [5, 5],
          borderWidth: 1
        },
        {
          label: '–û–ø–∏—Å–∞–Ω–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: circumCirclePoints,
          borderColor: '#9b59b6',
          backgroundColor: 'rgba(155, 89, 182, 0.05)',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderWidth: 2
        },
        {
          label: '–í–ø–∏—Å–∞–Ω–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: inCirclePoints,
          borderColor: '#2ecc71',
          backgroundColor: 'rgba(46, 204, 113, 0.1)',
          pointRadius: 0,
          showLine: true,
          fill: true,
          borderWidth: 1.5
        },
        {
          label: '–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫',
          data: [A, B, C, A],
          borderColor: '#e74c3c',
          backgroundColor: 'rgba(231, 76, 60, 0.2)',
          pointRadius: 0,
          showLine: true,
          fill: true,
          borderWidth: 2
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ A',
          data: [A],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ B',
          data: [B],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ C',
          data: [C],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–ò–Ω—Ü–µ–Ω—Ç—Ä',
          data: [incenter],
          backgroundColor: '#2ecc71',
          pointRadius: 6,
          showLine: false,
          pointStyle: 'rect'
        }
      ];
      
      chart.data.datasets = datasets;
      
      chart.options.plugins.annotation = {
        annotations: {
          labelA: {
            type: 'label',
            xValue: A.x,
            yValue: A.y,
            content: 'A',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          },
          labelB: {
            type: 'label',
            xValue: B.x,
            yValue: B.y,
            content: 'B',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          },
          labelC: {
            type: 'label',
            xValue: C.x,
            yValue: C.y,
            content: 'C',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          }
        }
      };
      
      applyTriangleYscale();
    }
    
    // ========== –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    function checkCompatibility() {
      if (Object.keys(selectedParameters).length === 0) {
        showStatusMessage('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã', 'warning');
        return;
      }
      
      const compatibility = checkParameterCompatibility(selectedParameters);
      const panel = document.getElementById('compatibilityPanel');
      const resultsDiv = document.getElementById('compatibilityResults');
      
      resultsDiv.innerHTML = '';
      
      if (compatibility.passed) {
        const div = document.createElement('div');
        div.className = 'compatibility-result validation-ok';
        div.innerHTML = `
          <div><strong>‚úì –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã</strong></div>
          <div>–ú–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å —Ä–∞—Å—á—ë—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞</div>
        `;
        resultsDiv.appendChild(div);
        
        if (compatibility.warnings.length > 0) {
          compatibility.warnings.forEach(warning => {
            const warnDiv = document.createElement('div');
            warnDiv.className = 'compatibility-result validation-warning';
            warnDiv.innerHTML = `
              <div><strong>‚ö† –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:</strong></div>
              <div>${warning.message}</div>
            `;
            resultsDiv.appendChild(warnDiv);
          });
        }
      } else {
        const div = document.createElement('div');
        div.className = 'compatibility-result validation-error';
        div.innerHTML = `
          <div><strong>‚úó –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã</strong></div>
          <div>–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏</div>
        `;
        resultsDiv.appendChild(div);
        
        compatibility.errors.forEach(error => {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'compatibility-result validation-error';
          errorDiv.innerHTML = `
            <div><strong>‚úó –û—à–∏–±–∫–∞:</strong></div>
            <div>${error.message}</div>
          `;
          resultsDiv.appendChild(errorDiv);
        });
      }
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    function hideCompatibilityPanel() {
      document.getElementById('compatibilityPanel').style.display = 'none';
    }
    
    function debugCoordinates() {
      if (!currentSolution) {
        showStatusMessage('–ù–µ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏', 'warning');
        return;
      }
      
      const panel = document.getElementById('debugPanel');
      const resultsDiv = document.getElementById('debugResults');
      
      const { A, B, C } = currentSolution.points;
      const { Œ±, Œ≤, Œ≥ } = currentSolution.angles;
      const R = currentSolution.scale;
      
      const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
      const a_actual = dist(B, C);
      const b_actual = dist(A, C);
      const c_actual = dist(A, B);
      
      const angleFromCoords = (p1, p2, p3) => {
        const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
        const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x**2 + v1.y**2);
        const mag2 = Math.sqrt(v2.x**2 + v2.y**2);
        const cosAngle = dot / (mag1 * mag2);
        const clamped = Math.max(-1, Math.min(1, cosAngle));
        return Math.acos(clamped) * 180 / Math.PI;
      };
      
      const Œ±_actual = angleFromCoords(B, A, C);
      const Œ≤_actual = angleFromCoords(A, B, C);
      const Œ≥_actual = angleFromCoords(A, C, B);
      
      resultsDiv.innerHTML = '';
      
      const coordsDiv = document.createElement('div');
      coordsDiv.innerHTML = '<strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–µ—Ä—à–∏–Ω:</strong>';
      resultsDiv.appendChild(coordsDiv);
      
      addDebugRow('A (–≤–µ—Ä—à–∏–Ω–∞ Œ±)', `(${A.x.toFixed(4)}, ${A.y.toFixed(4)})`, resultsDiv);
      addDebugRow('B (–≤–µ—Ä—à–∏–Ω–∞ Œ≤)', `(${B.x.toFixed(4)}, ${B.y.toFixed(4)})`, resultsDiv);
      addDebugRow('C (–≤–µ—Ä—à–∏–Ω–∞ Œ≥)', `(${C.x.toFixed(4)}, ${C.y.toFixed(4)})`, resultsDiv);
      addDebugRow('–†–∞–¥–∏—É—Å R', R.toFixed(4), resultsDiv);
      
      const sidesDiv = document.createElement('div');
      sidesDiv.innerHTML = '<br><strong>–§–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong>';
      resultsDiv.appendChild(sidesDiv);
      
      addDebugRow('AB (c)', `${c_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideAB).toFixed(4)})`, resultsDiv);
      addDebugRow('BC (a)', `${a_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideBC).toFixed(4)})`, resultsDiv);
      addDebugRow('AC (b)', `${b_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideAC).toFixed(4)})`, resultsDiv);
      
      const anglesDiv = document.createElement('div');
      anglesDiv.innerHTML = '<br><strong>–§–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —É–≥–ª—ã –∏–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong>';
      resultsDiv.appendChild(anglesDiv);
      
      addDebugRow('‚à†A (Œ±)', `${Œ±_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ±.toFixed(2)}¬∞)`, resultsDiv);
      addDebugRow('‚à†B (Œ≤)', `${Œ≤_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ≤.toFixed(2)}¬∞)`, resultsDiv);
      addDebugRow('‚à†C (Œ≥)', `${Œ≥_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ≥.toFixed(2)}¬∞)`, resultsDiv);
      
      const sumAnglesActual = Œ±_actual + Œ≤_actual + Œ≥_actual;
      addDebugRow('–°—É–º–º–∞ —É–≥–ª–æ–≤', `${sumAnglesActual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è 180¬∞)`, resultsDiv);
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    function addDebugRow(label, value, container) {
      const row = document.createElement('div');
      row.className = 'debug-row';
      row.innerHTML = `
        <span class="debug-label">${label}:</span>
        <span class="debug-value">${value}</span>
      `;
      container.appendChild(row);
    }
    
    function validateTriangleGeometry(params) {
      const results = [];
      const Œµ = 1e-6;
      
      const a = parseFloat(params.sideBC);
      const b = parseFloat(params.sideAC);
      const c = parseFloat(params.sideAB);
      const Œ± = parseFloat(params.angleA);
      const Œ≤ = parseFloat(params.angleB);
      const Œ≥ = parseFloat(params.angleC);
      const R = parseFloat(params.circumradius);
      const S = parseFloat(params.area);
      const r = parseFloat(params.inradius);
      
      const sumAngles = Œ± + Œ≤ + Œ≥;
      const angleError = Math.abs(sumAngles - 180);
      results.push({
        test: '–°—É–º–º–∞ —É–≥–ª–æ–≤',
        value: sumAngles.toFixed(6),
        expected: '180.000000',
        error: angleError,
        passed: angleError < 0.001
      });
      
      const sinRatioA = a / Math.sin(Œ± * Math.PI / 180);
      const sinRatioB = b / Math.sin(Œ≤ * Math.PI / 180);
      const sinRatioC = c / Math.sin(Œ≥ * Math.PI / 180);
      const sinError = Math.max(
        Math.abs(sinRatioA - sinRatioB),
        Math.abs(sinRatioB - sinRatioC),
        Math.abs(sinRatioA - sinRatioC)
      );
      results.push({
        test: '–¢–µ–æ—Ä–µ–º–∞ —Å–∏–Ω—É—Å–æ–≤',
        value: `${sinRatioA.toFixed(3)} ‚âà ${sinRatioB.toFixed(3)} ‚âà ${sinRatioC.toFixed(3)}`,
        expected: '–†–∞–≤–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è',
        error: sinError,
        passed: sinError < 0.01
      });
      
      const R_from_sides = (a * b * c) / (4 * S);
      const R_error = Math.abs(R - R_from_sides);
      results.push({
        test: '–†–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏',
        value: R.toFixed(6),
        expected: R_from_sides.toFixed(6),
        error: R_error,
        passed: R_error < 0.001
      });
      
      const p = (a + b + c) / 2;
      const r_from_sides = S / p;
      const r_error = Math.abs(r - r_from_sides);
      results.push({
        test: '–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏',
        value: r.toFixed(6),
        expected: r_from_sides.toFixed(6),
        error: r_error,
        passed: r_error < 0.001
      });
      
      const triangleInequality = (a + b > c) && (a + c > b) && (b + c > a);
      results.push({
        test: '–ù–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞',
        value: triangleInequality ? '–í—ã–ø–æ–ª–Ω–µ–Ω–æ' : '–ù–∞—Ä—É—à–µ–Ω–æ',
        expected: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ',
        error: triangleInequality ? 0 : 1,
        passed: triangleInequality
      });
      
      return {
        results: results,
        passed: results.every(r => r.passed),
        score: results.filter(r => r.passed).length / results.length * 100
      };
    }
    
    function validateCurrentTriangleEnhanced() {
      if (!currentSolution) {
        showStatusMessage('–ù–µ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏', 'warning');
        return;
      }
      
      const validation = validateTriangleGeometry(currentSolution.params);
      const practicalCheck = checkPracticalFeasibility(currentSolution.params);
      const numericalCheck = checkNumericalFeasibility(currentSolution.params);
      
      const panel = document.getElementById('validationPanel');
      const resultsDiv = document.getElementById('validationResults');
      
      resultsDiv.innerHTML = '';
      
      // –ó–∞–≥–æ–ª–æ–≤–æ–∫
      const header = document.createElement('div');
      header.className = 'validation-result';
      header.style.backgroundColor = '#34495e';
      header.style.color = 'white';
      header.style.fontWeight = 'bold';
      header.innerHTML = '<div style="text-align: center;">–ü–û–õ–ù–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø –¢–†–ï–£–ì–û–õ–¨–ù–ò–ö–ê</div>';
      resultsDiv.appendChild(header);
      
      // –ë–∞–∑–æ–≤—ã–µ –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
      validation.results.forEach(result => {
        const div = document.createElement('div');
        div.className = `validation-result ${result.passed ? 'validation-ok' : 'validation-error'}`;
        
        let status = result.passed ? '‚úì' : '‚úó';
        
        div.innerHTML = `
          <div><strong>${status} ${result.test}:</strong></div>
          <div>–ü–æ–ª—É—á–µ–Ω–æ: ${result.value}</div>
          <div>–û–∂–∏–¥–∞–µ—Ç—Å—è: ${result.expected}</div>
          <div style="font-size: 11px; color: #666;">–û—à–∏–±–∫–∞: ${result.error.toExponential(2)}</div>
        `;
        
        resultsDiv.appendChild(div);
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏
      if (practicalCheck.allIssues.length > 0) {
        const practicalDiv = document.createElement('div');
        practicalDiv.className = `validation-result ${practicalCheck.feasible ? 'validation-warning' : 'validation-error'}`;
        practicalDiv.innerHTML = `
          <div><strong>${practicalCheck.feasible ? '‚ö†' : '‚úó'} –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å:</strong></div>
          <div>${practicalCheck.feasible ? '–ï—Å—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è' : '–ï—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã'}</div>
        `;
        resultsDiv.appendChild(practicalDiv);
        
        practicalCheck.allIssues.forEach((issue, index) => {
          if (index < 3) {
            const issueDiv = document.createElement('div');
            issueDiv.className = 'validation-result validation-warning';
            issueDiv.style.marginLeft = '20px';
            issueDiv.style.fontSize = '12px';
            issueDiv.innerHTML = `‚Ä¢ ${issue}`;
            resultsDiv.appendChild(issueDiv);
          }
        });
      }
      
      // –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      const overallPassed = validation.passed && practicalCheck.feasible && numericalCheck.feasible;
      const summary = document.createElement('div');
      summary.className = `validation-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
      summary.innerHTML = `
        <div><strong>${overallPassed ? '‚úì –¢–†–ï–£–ì–û–õ–¨–ù–ò–ö –ö–û–†–†–ï–ö–¢–ï–ù' : '‚úó –ï–°–¢–¨ –ü–†–û–ë–õ–ï–ú–´'}</strong></div>
        <div>–ì–µ–æ–º–µ—Ç—Ä–∏—è: ${validation.results.filter(r => r.passed).length}/${validation.results.length}</div>
        <div>–û—Ü–µ–Ω–∫–∞: ${validation.score.toFixed(1)}%</div>
        <div>–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å: ${practicalCheck.feasible ? '‚úì' : '‚úó'}</div>
        <div>–ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å: ${numericalCheck.feasible ? '‚úì' : '‚úó'}</div>
      `;
      resultsDiv.appendChild(summary);
      
      panel.style.display = 'block';
      updateAllParamsTable(currentSolution);
    }
    
    function determineTriangleType(params) {
      const a = parseFloat(params.sideBC);
      const b = parseFloat(params.sideAC);
      const c = parseFloat(params.sideAB);
      const Œ± = parseFloat(params.angleA);
      const Œ≤ = parseFloat(params.angleB);
      const Œ≥ = parseFloat(params.angleC);
      
      const Œµ = 0.01;
      
      if (Math.abs(a - b) < Œµ && Math.abs(b - c) < Œµ && 
          Math.abs(Œ± - 60) < 1 && Math.abs(Œ≤ - 60) < 1 && Math.abs(Œ≥ - 60) < 1) {
        return 'equilateral';
      }
      
      if (Math.abs(Œ± - 90) < 1 || Math.abs(Œ≤ - 90) < 1 || Math.abs(Œ≥ - 90) < 1) {
        return 'right';
      }
      
      if (Math.abs(a - b) < Œµ || Math.abs(a - c) < Œµ || Math.abs(b - c) < Œµ) {
        return 'isosceles';
      }
      
      return 'scalene';
    }
    
    function updateAllParamsTable(solution = null) {
      const tbody = document.getElementById('paramsTableBody');
      tbody.innerHTML = '';
      
      let validation = null;
      if (solution && solution.params) {
        validation = validateTriangleGeometry(solution.params);
      }
      
      allParameters.forEach((param, index) => {
        let value = '-';
        let isGiven = false;
        let isValid = true;
        let validationInfo = '';
        
        if (solution && solution.params && solution.params[param.key] !== undefined) {
          value = solution.params[param.key];
          
          if (validation) {
            const numValue = parseFloat(value);
            
            if (param.key.includes('side')) {
              const a = parseFloat(solution.params.sideBC);
              const b = parseFloat(solution.params.sideAC);
              const c = parseFloat(solution.params.sideAB);
              isValid = (a + b > c && a + c > b && b + c > a);
              if (!isValid) validationInfo = '–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞';
            } else if (param.key.includes('angle')) {
              const sum = parseFloat(solution.params.angleA || 0) + 
                         parseFloat(solution.params.angleB || 0) + 
                         parseFloat(solution.params.angleC || 0);
              isValid = Math.abs(sum - 180) < 0.001;
              if (!isValid) validationInfo = `–°—É–º–º–∞ —É–≥–ª–æ–≤: ${sum.toFixed(2)}¬∞`;
            }
          }
        }
        
        if (selectedParameters && selectedParameters[param.key] !== undefined) {
          isGiven = true;
          value = selectedParameters[param.key].toFixed(6);
        }
        
        const row = document.createElement('tr');
        if (isGiven) {
          row.style.backgroundColor = '#e8f6f3';
        }
        
        const numValue = parseFloat(value);
        const cellClass = !isNaN(numValue) && numValue <= 0 ? 'invalid' : 'valid';
        
        row.innerHTML = `
          <td>${index + 1}</td>
          <td>${param.name}</td>
          <td>${param.designation}</td>
          <td class="${cellClass}"><strong>${value}</strong></td>
          <td>${isGiven ? '‚úì' : ''} ${validationInfo ? `<span style="color: #e74c3c; font-size: 10px;">${validationInfo}</span>` : ''}</td>
        `;
        
        tbody.appendChild(row);
      });
    }
    
    function getTriangleTypeName(type) {
      const names = {
        'equilateral': '—Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π',
        'right': '–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π',
        'isosceles': '—Ä–∞–≤–Ω–æ–±–µ–¥—Ä–µ–Ω–Ω—ã–π',
        'scalene': '—Ä–∞–∑–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π'
      };
      return names[type] || type;
    }
    
    function generateTriangleByType(type) {
      clearAll();
      
      let solution;
      switch(type) {
        case 'equilateral':
          solution = generateEquilateralTriangle();
          break;
        case 'right':
          solution = generateRightTriangle();
          break;
        case 'isosceles':
          solution = generateIsoscelesTriangle();
          break;
        default:
          solution = generateRandomTriangle();
      }
      
      displayGeneratedTriangle(solution);
      showStatusMessage(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω ${getTriangleTypeName(solution.type)} —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫`, 'info');
    }
    
    function generateEquilateralTriangle() {
      const Œ± = 60, Œ≤ = 60, Œ≥ = 60;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'equilateral'
      };
    }
    
    function generateRightTriangle() {
      const Œ± = 90, Œ≤ = 45, Œ≥ = 45;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'right'
      };
    }
    
    function generateIsoscelesTriangle() {
      const Œ± = 70, Œ≤ = 70, Œ≥ = 40;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'isosceles'
      };
    }
    
    function generateRandomTriangle() {
      let Œ±, Œ≤;
      do {
        Œ± = 10 + Math.random() * 160;
        Œ≤ = 10 + Math.random() * (160 - Œ±);
      } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
      
      const Œ≥ = 180 - Œ± - Œ≤;
      const R = 1.0 + Math.random() * 1.5;
      
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      const type = determineTriangleType(params);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: type,
        validated: validateTriangleGeometry(params)
      };
    }
    
    function displayGeneratedTriangle(solution) {
      if (!solution) return;
      
      currentSolution = solution;
      
      updateChart(solution);
      updateAllParamsTable(solution);
      
      document.getElementById('statusText').textContent = `–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫: ${getTriangleTypeName(solution.type)}`;
      document.getElementById('statusText').style.color = '#9b59b6';
      document.getElementById('accuracyText').textContent = '100%';
      document.getElementById('iterationsText').textContent = '0';
      document.getElementById('scaleText').textContent = solution.scale.toFixed(2);
      document.getElementById('angleAText').textContent = `${solution.angles.Œ±.toFixed(2)}¬∞`;
      document.getElementById('angleBText').textContent = `${solution.angles.Œ≤.toFixed(2)}¬∞`;
      document.getElementById('angleCText').textContent = `${solution.angles.Œ≥.toFixed(2)}¬∞`;
      document.getElementById('triangleTypeText').textContent = getTriangleTypeName(solution.type);
    }
    
    function generateRandomProblem() {
      clearAll();
      
      const R = 1.0 + Math.random() * 1.5;
      let Œ±, Œ≤;
      
      do {
        Œ± = 10 + Math.random() * 160;
        Œ≤ = 10 + Math.random() * (160 - Œ±);
      } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
      
      const Œ≥ = 180 - Œ± - Œ≤;
      
      if (Œ≥ < 10 || Œ≥ > 170) {
        return generateRandomProblem();
      }
      
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      const type = determineTriangleType(params);
      
      const solution = {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: type,
        validated: validateTriangleGeometry(params)
      };
      
      const allKeys = Object.keys(solution.params).filter(key => {
        const value = parseFloat(solution.params[key]);
        return !isNaN(value) && value > 0;
      });
      
      let selectedKeys = [];
      let attempts = 0;
      const maxAttempts = 100;
      
      while (selectedKeys.length < 3 && attempts < maxAttempts) {
        const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
        const candidateKeys = shuffled.slice(0, 3);
        
        const hasAngle = candidateKeys.some(k => k.includes('angle'));
        const hasSide = candidateKeys.some(k => k.includes('side'));
        const hasOther = candidateKeys.some(k => !k.includes('angle') && !k.includes('side'));
        
        if ((hasAngle && hasSide) || (hasAngle && hasOther) || (hasSide && hasOther)) {
          selectedKeys = candidateKeys;
          break;
        }
        
        attempts++;
      }
      
      if (selectedKeys.length < 3) {
        selectedKeys = allKeys.slice(0, 3);
      }
      
      selectedKeys.forEach((key, index) => {
        const value = solution.params[key];
        if (value) {
          const select = document.getElementById(`param${index + 1}`);
          select.value = key;
          
          const numValue = parseFloat(value);
          const input = document.getElementById(`value${index + 1}`);
          
          if (key.includes('angle')) {
            input.value = numValue.toFixed(1);
          } else {
            input.value = numValue.toFixed(3);
          }
          
          updateSliderForParam(index + 1, key);
          
          const range = paramRanges[key];
          if (range) {
            const clampedValue = Math.max(range.min, Math.min(range.max, numValue));
            const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
            
            const slider = document.getElementById(`slider${index + 1}`);
            const valueDisplay = document.getElementById(`sliderValue${index + 1}`);
            
            if (slider && valueDisplay) {
              slider.value = normalizedValue;
              
              let displayValue;
              if (key.includes('angle')) {
                displayValue = clampedValue.toFixed(1) + '¬∞';
              } else {
                displayValue = clampedValue.toFixed(3);
              }
              
              valueDisplay.textContent = displayValue;
            }
          }
        }
      });
      
      displayGeneratedTriangle(solution);
      validateParameterSelection();
      
      showStatusMessage(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ –∑–∞–¥–∞—á–∞ —Å ${getTriangleTypeName(solution.type)} —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–º`, 'info');
    }
    
    function testAndDisplayFormulas() {
      console.clear();
      console.log('=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –§–û–†–ú–£–õ ===');
      
      const equilateral = generateEquilateralTriangle();
      console.log('\n1. –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ (Œ±=Œ≤=Œ≥=60¬∞, R=1):');
      console.log('–°—Ç–æ—Ä–æ–Ω—ã (–æ–∂–∏–¥–∞–µ—Ç—Å—è ~1.732):', 
        equilateral.params.sideAB, equilateral.params.sideBC, equilateral.params.sideAC);
      
      const right = generateRightTriangle();
      console.log('\n2. –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ (Œ±=90¬∞, Œ≤=Œ≥=45¬∞, R=1):');
      console.log('–°—Ç–æ—Ä–æ–Ω—ã:', right.params.sideAB, right.params.sideBC, right.params.sideAC);
      
      const validation = validateTriangleGeometry(equilateral.params);
      console.log('\n3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞:');
      console.log(`–ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: ${validation.results.filter(r => r.passed).length}/${validation.results.length}`);
      console.log(`–û—Ü–µ–Ω–∫–∞: ${validation.score.toFixed(1)}%`);
      
      displayGeneratedTriangle(equilateral);
      
      setTimeout(() => {
        debugCoordinates();
      }, 500);
      
      showStatusMessage('–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ (F12).', 'info');
    }
    
    function clearAll() {
      closeSolutionsPanel();
      hideCompatibilityPanel();
      allSolutions = [];
      currentSolutionIndex = 0;
      currentStatusMessages = [];
      
      for (let i = 1; i <= 3; i++) {
        document.getElementById(`param${i}`).value = '';
        document.getElementById(`value${i}`).value = '';
        document.getElementById(`sliderContainer${i}`).style.display = 'none';
        document.getElementById(`param${i}`).style.borderColor = '#ddd';
        document.getElementById(`value${i}`).style.borderColor = '#ddd';
        document.getElementById(`fixParam${i}`).checked = false;
        document.getElementById(`paramRow${i}`).classList.remove('fixed');
      }
      
      selectedParameters = {};
      currentSolution = null;
      
      document.getElementById('solveBtn').disabled = true;
      document.getElementById('solveAllBtn').disabled = true;
      document.getElementById('randomParamsBtn').disabled = true;
      document.getElementById('solveBtn').textContent = '–†–∞—Å—Å—á–∏—Ç–∞—Ç—å';
      document.getElementById('statusText').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö';
      document.getElementById('statusText').style.color = '#7f8c8d';
      document.getElementById('accuracyText').textContent = '-';
      document.getElementById('iterationsText').textContent = '0';
      document.getElementById('scaleText').textContent = '1.00';
      document.getElementById('angleAText').textContent = '-';
      document.getElementById('angleBText').textContent = '-';
      document.getElementById('angleCText').textContent = '-';
      document.getElementById('triangleTypeText').textContent = '-';
      
      hideErrorMessage();
      updateStatusPanel();
      
      document.getElementById('validationPanel').style.display = 'none';
      document.getElementById('debugPanel').style.display = 'none';
      
      // –û—á–∏—â–∞–µ–º —Ç–∞–π–º–µ—Ä –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç–∞
      if (autoCalculateTimer) {
        clearTimeout(autoCalculateTimer);
        autoCalculateTimer = null;
      }
      
      if (chart) {
        chart.data.datasets = [
          {
            label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
            data: generateCirclePoints(1, 100),
            borderColor: '#3498db',
            backgroundColor: 'transparent',
            pointRadius: 0,
            showLine: true,
            fill: false,
            borderDash: [5, 5],
            borderWidth: 1
          }
        ];
        chart.options.scales.x.min = -3.5;
        chart.options.scales.x.max = 3.5;
        chart.options.scales.y.min = -3.5;
        chart.options.scales.y.max = 3.5;
        chart.options.plugins.annotation = { annotations: {} };
        applyTriangleYscale();
      }
      
      updateAllParamsTable();
    }
    
    function clearSolutionOnInvalidParams() {
      const statusText = document.getElementById('statusText');
      const accuracyText = document.getElementById('accuracyText');
      const iterationsText = document.getElementById('iterationsText');
      
      statusText.textContent = '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã';
      statusText.style.color = '#e74c3c';
      accuracyText.textContent = '-';
      iterationsText.textContent = '0';
      document.getElementById('scaleText').textContent = '1.00';
      document.getElementById('angleAText').textContent = '-';
      document.getElementById('angleBText').textContent = '-';
      document.getElementById('angleCText').textContent = '-';
      document.getElementById('triangleTypeText').textContent = '-';
      
      currentSolution = null;
      
      if (chart) {
        chart.data.datasets = [{
          label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: generateCirclePoints(1, 100),
          borderColor: '#3498db',
          backgroundColor: 'transparent',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderDash: [5, 5],
          borderWidth: 1
        }];
        chart.update();
      }
      
      updateAllParamsTable();
    }
    
    async function findAllSolutionsEnhanced() {
      if (!validateParameterSelection()) return;
      
      const preCheck = preValidateParametersEnhanced(selectedParameters);
      if (!preCheck.valid) {
        showErrorMessage(preCheck.message, true);
        clearSolutionOnInvalidParams();
        return;
      }
      
      const solveAllBtn = document.getElementById('solveAllBtn');
      solveAllBtn.disabled = true;
      solveAllBtn.textContent = '–ü–æ–∏—Å–∫...';
      
      isFindingAll = true;
      
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      
      progressContainer.style.display = 'block';
      progressText.textContent = '–ü–æ–∏—Å–∫ –≤—Å–µ—Ö —Ä–µ—à–µ–Ω–∏–π (–∞–ª–≥–æ—Ä–∏—Ç–º –æ—Ç–∂–∏–≥–∞)...';
      
      try {
        const mainSolution = await optimizeTriangleWithSimulatedAnnealing(selectedParameters, (progress, iteration, error) => {
          progressBar.style.width = Math.min(50, progress) + '%';
          progressText.textContent = `–û—Å–Ω–æ–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: ${iteration} –∏—Ç–µ—Ä–∞—Ü–∏–π, –æ—à–∏–±–∫–∞: ${error.toFixed(6)}`;
        });
        
        allSolutions = generateAllTriangleVariantsEnhanced(mainSolution);
        displaySolutionsPanel(allSolutions);
        
        if (allSolutions.length > 0) {
          showSolution(0);
        }
        
        showStatusMessage(`–ù–∞–π–¥–µ–Ω–æ ${allSolutions.length} —Ä–µ—à–µ–Ω–∏–π`, 'success');
        
      } catch (error) {
        showErrorMessage(`–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ${error.message}`, true);
        clearSolutionOnInvalidParams();
      } finally {
        solveAllBtn.disabled = false;
        solveAllBtn.textContent = '–í—Å–µ —Ä–µ—à–µ–Ω–∏—è';
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
        isFindingAll = false;
      }
    }
    
    function generateAllTriangleVariantsEnhanced(mainSolution) {
      if (!mainSolution) return [];
      
      const variants = [mainSolution];
      
      if (mainSolution.type !== 'equilateral') {
        // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
        const mirrored = createMirroredTriangle(mainSolution);
        if (mirrored) {
          variants.push({
            ...mirrored,
            isMirror: true,
            displayName: "–°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ"
          });
        }
        
        // –í—Ä–∞—â–µ–Ω–∏—è (–¥–ª—è –Ω–µ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤)
        const rotated1 = rotateTriangle(mainSolution, 120);
        if (rotated1 && !isDuplicateSolution(variants, rotated1)) {
          variants.push({
            ...rotated1,
            displayName: "–ü–æ–≤–æ—Ä–æ—Ç 120¬∞"
          });
        }
        
        const rotated2 = rotateTriangle(mainSolution, 240);
        if (rotated2 && !isDuplicateSolution(variants, rotated2)) {
          variants.push({
            ...rotated2,
            displayName: "–ü–æ–≤–æ—Ä–æ—Ç 240¬∞"
          });
        }
      }
      
      return variants.map(s => normalizeSolutionOrientation(s));
    }
    
    function createMirroredTriangle(original) {
      if (!original || !original.points) return null;
      
      const { A, B, C } = original.points;
      
      return {
        ...original,
        points: {
          A: { x: A.x, y: -A.y },
          B: { x: B.x, y: -B.y },
          C: { x: C.x, y: -C.y }
        },
        isMirror: true
      };
    }
    
    function rotateTriangle(solution, angleDeg) {
      if (!solution || !solution.points) return null;
      
      const angleRad = angleDeg * Math.PI / 180;
      const cosA = Math.cos(angleRad);
      const sinA = Math.sin(angleRad);
      
      const rotatePoint = (p) => ({
        x: p.x * cosA - p.y * sinA,
        y: p.x * sinA + p.y * cosA
      });
      
      return {
        ...solution,
        points: {
          A: rotatePoint(solution.points.A),
          B: rotatePoint(solution.points.B),
          C: rotatePoint(solution.points.C)
        }
      };
    }
    
    function isDuplicateSolution(solutions, newSolution) {
      if (!newSolution || !newSolution.points) return true;
      
      return solutions.some(existing => {
        if (!existing || !existing.points) return false;
        
        const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
        
        const distances = [
          dist(existing.points.A, newSolution.points.A),
          dist(existing.points.B, newSolution.points.B),
          dist(existing.points.C, newSolution.points.C)
        ];
        
        return distances.every(d => d < 0.001);
      });
    }
    
    function displaySolutionsPanel(solutions) {
      if (!solutions || solutions.length === 0) return;
      
      const panel = document.getElementById('solutionsPanel');
      const grid = document.getElementById('solutionsGrid');
      const countDisplay = document.getElementById('solutionsCountDisplay');
      const infoSpan = document.getElementById('allSolutionsInfo');
      const solutionsCount = document.getElementById('solutionsCount');
      
      countDisplay.textContent = solutions.length;
      solutionsCount.textContent = solutions.length;
      infoSpan.style.display = 'inline';
      
      grid.innerHTML = '';
      
      solutions.forEach((solution, index) => {
        const thumb = document.createElement('div');
        thumb.className = `solution-thumb ${solution.isMirror ? 'mirror' : ''}`;
        thumb.onclick = () => showSolution(index);
        
        const typeName = getTriangleTypeName(solution.type);
        const errorPercent = solution.error ? 
          Math.max(0, 100 - solution.error * 100).toFixed(1) : '100.0';
        
        let title = `–†–µ—à–µ–Ω–∏–µ ${index + 1}`;
        if (solution.displayName) {
          title = solution.displayName;
        } else if (solution.isMirror) {
          title = "–°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ";
        }
        
        thumb.innerHTML = `
          <div class="thumb-title">${title}</div>
          <div class="thumb-info">
            Œ±=${solution.angles.Œ±.toFixed(1)}¬∞<br>
            Œ≤=${solution.angles.Œ≤.toFixed(1)}¬∞<br>
            ${typeName}<br>
            <small>–¢–æ—á–Ω–æ—Å—Ç—å: ${errorPercent}%</small>
          </div>
          <div class="solution-actions">
            <button class="solution-btn view-btn" onclick="event.stopPropagation(); showSolution(${index})">
              üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä
            </button>
            <button class="solution-btn animate-btn" onclick="event.stopPropagation(); animateToSolution(${index})">
              ‚Üí –ê–Ω–∏–º–∞—Ü–∏—è
            </button>
          </div>
        `;
        
        grid.appendChild(thumb);
      });
      
      panel.style.display = 'block';
    }
    
    function showSolution(index) {
      if (!allSolutions || index < 0 || index >= allSolutions.length) return;
      
      document.querySelectorAll('.solution-thumb').forEach((thumb, i) => {
        thumb.classList.toggle('active', i === index);
      });
      
      const solution = allSolutions[index];
      displaySolution(solution);
      currentSolution = solution;
      currentSolutionIndex = index;
      
      updateSolutionIndicator();
    }
    
    function showPreviousSolution() {
      if (allSolutions.length <= 1) return;
      const newIndex = (currentSolutionIndex - 1 + allSolutions.length) % allSolutions.length;
      showSolution(newIndex);
    }
    
    function showNextSolution() {
      if (allSolutions.length <= 1) return;
      const newIndex = (currentSolutionIndex + 1) % allSolutions.length;
      showSolution(newIndex);
    }
    
    function animateToSolution(targetIndex) {
      if (!allSolutions || targetIndex === currentSolutionIndex || allSolutions.length <= 1) return;
      
      const steps = 20;
      const duration = 800;
      const stepTime = duration / steps;
      
      const startSolution = allSolutions[currentSolutionIndex];
      const endSolution = allSolutions[targetIndex];
      
      let currentStep = 0;
      
      const animate = () => {
        if (currentStep > steps) {
          showSolution(targetIndex);
          return;
        }
        
        const t = currentStep / steps;
        const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        
        const interpolatedPoints = {
          A: {
            x: startSolution.points.A.x + (endSolution.points.A.x - startSolution.points.A.x) * easeT,
            y: startSolution.points.A.y + (endSolution.points.A.y - startSolution.points.A.y) * easeT
          },
          B: {
            x: startSolution.points.B.x + (endSolution.points.B.x - startSolution.points.B.x) * easeT,
            y: startSolution.points.B.y + (endSolution.points.B.y - startSolution.points.B.y) * easeT
          },
          C: {
            x: startSolution.points.C.x + (endSolution.points.C.x - startSolution.points.C.x) * easeT,
            y: startSolution.points.C.y + (endSolution.points.C.y - startSolution.points.C.y) * easeT
          }
        };
        
        const intermediateSolution = {
          ...startSolution,
          points: interpolatedPoints
        };
        
        updateChart(intermediateSolution);
        
        currentStep++;
        setTimeout(animate, stepTime);
      };
      
      animate();
    }
    
    function updateSolutionIndicator() {
      const indicator = document.getElementById('solutionIndicator');
      if (!allSolutions || allSolutions.length <= 1) {
        indicator.textContent = '';
        return;
      }
      
      indicator.textContent = `[${currentSolutionIndex + 1}/${allSolutions.length}]`;
    }
    
    function closeSolutionsPanel() {
      const panel = document.getElementById('solutionsPanel');
      panel.style.display = 'none';
      
      const infoSpan = document.getElementById('allSolutionsInfo');
      infoSpan.style.display = 'none';
      
      allSolutions = [];
      currentSolutionIndex = 0;
      updateSolutionIndicator();
    }
    
    // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ö–ù–û–ü–ö–ò "–°–õ–£–ß–ê–ô–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´" ==========
    function setupFixCheckboxes() {
      for (let i = 1; i <= 3; i++) {
        const checkbox = document.getElementById(`fixParam${i}`);
        const paramRow = document.getElementById(`paramRow${i}`);
        
        checkbox.addEventListener('change', function() {
          if (this.checked) {
            paramRow.classList.add('fixed');
          } else {
            paramRow.classList.remove('fixed');
          }
          updateRandomParamsButtonState();
        });
      }
    }
    
    function updateRandomParamsButtonState() {
      const param1Selected = document.getElementById('param1').value !== '';
      const param2Selected = document.getElementById('param2').value !== '';
      const param3Selected = document.getElementById('param3').value !== '';
      
      const allParamsSelected = param1Selected && param2Selected && param3Selected;
      
      const fix1 = document.getElementById('fixParam1').checked;
      const fix2 = document.getElementById('fixParam2').checked;
      const fix3 = document.getElementById('fixParam3').checked;
      
      const allFixed = fix1 && fix2 && fix3;
      
      const randomParamsBtn = document.getElementById('randomParamsBtn');
      
      if (allParamsSelected && !allFixed) {
        randomParamsBtn.disabled = false;
      } else {
        randomParamsBtn.disabled = true;
      }
    }
    
    function randomizeNonFixedParameters() {
      if (!validateParameterSelection()) return;
      
      let changedAny = false;
      
      for (let i = 1; i <= 3; i++) {
        const paramKey = document.getElementById(`param${i}`).value;
        const isFixed = document.getElementById(`fixParam${i}`).checked;
        
        if (!paramKey || isFixed) continue;
        
        const range = paramRanges[paramKey];
        if (!range) continue;
        
        let randomValue;
        
        if (paramKey.includes('angle')) {
          const otherAngles = getOtherAngleValues(i);
          const maxAngle = 170 - otherAngles.reduce((a, b) => a + b, 0);
          
          if (maxAngle < 10) {
            continue;
          }
          
          randomValue = 10 + Math.random() * (maxAngle - 10);
          randomValue = Math.max(10, Math.min(maxAngle, randomValue));
        } else {
          randomValue = range.min + Math.random() * (range.max - range.min);
        }
        
        const input = document.getElementById(`value${i}`);
        const slider = document.getElementById(`slider${i}`);
        const valueDisplay = document.getElementById(`sliderValue${i}`);
        
        if (paramKey.includes('angle')) {
          input.value = randomValue.toFixed(1);
        } else {
          input.value = randomValue.toFixed(3);
        }
        
        const normalizedValue = ((randomValue - range.min) / (range.max - range.min)) * 100;
        
        if (slider) slider.value = normalizedValue;
        
        let displayValue;
        if (paramKey.includes('angle')) {
          displayValue = randomValue.toFixed(1) + '¬∞';
        } else {
          displayValue = randomValue.toFixed(3);
        }
        
        if (valueDisplay) valueDisplay.textContent = displayValue;
        
        changedAny = true;
      }
      
      if (changedAny) {
        validateParameterSelection();
        showStatusMessage('–ó–Ω–∞—á–µ–Ω–∏—è –Ω–µ–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω—ã', 'info');
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ —Ä–∞—Å—á–µ—Ç–∞ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        triggerAutoCalculate();
      } else {
        showStatusMessage('–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã', 'warning');
      }
    }
    
    function getOtherAngleValues(currentIndex) {
      const otherAngles = [];
      
      for (let i = 1; i <= 3; i++) {
        if (i === currentIndex) continue;
        
        const paramKey = document.getElementById(`param${i}`).value;
        const isFixed = document.getElementById(`fixParam${i}`).checked;
        
        if (paramKey && paramKey.includes('angle') && isFixed) {
          const value = parseFloat(document.getElementById(`value${i}`).value);
          if (!isNaN(value)) {
            otherAngles.push(value);
          }
        }
      }
      
      return otherAngles;
    }
    
    // ========== –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–†–û–í–ï–†–ö–ò –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ô –†–ï–ê–õ–ò–ó–£–ï–ú–û–°–¢–ò UI ==========
    function checkPracticalFeasibilityUI() {
      if (Object.keys(selectedParameters).length === 0) {
        showStatusMessage('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã', 'warning');
        return;
      }
      
      const compatibility = checkParameterCompatibility(selectedParameters);
      const practicalCheck = checkPracticalFeasibility(selectedParameters);
      const numericalCheck = checkNumericalFeasibility(selectedParameters);
      
      const panel = document.getElementById('compatibilityPanel');
      const resultsDiv = document.getElementById('compatibilityResults');
      
      resultsDiv.innerHTML = '';
      
      // –ó–∞–≥–æ–ª–æ–≤–æ–∫
      const header = document.createElement('div');
      header.className = 'compatibility-result';
      header.style.backgroundColor = '#34495e';
      header.style.color = 'white';
      header.style.fontWeight = 'bold';
      header.innerHTML = '<div style="text-align: center;">–ü–û–õ–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ü–ê–†–ê–ú–ï–¢–†–û–í</div>';
      resultsDiv.appendChild(header);
      
      // 1. –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      const compatDiv = document.createElement('div');
      compatDiv.className = `compatibility-result ${compatibility.passed ? 'validation-ok' : 'validation-error'}`;
      compatDiv.innerHTML = `
        <div><strong>${compatibility.passed ? '‚úì' : '‚úó'} –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</strong></div>
        <div>${compatibility.passed ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã' : '–ï—Å—Ç—å –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã'}</div>
        <div style="font-size: 11px;">–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: ${compatibility.allChecks.length} —É—Å–ª–æ–≤–∏–π</div>
      `;
      resultsDiv.appendChild(compatDiv);
      
      // 2. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å
      const practicalDiv = document.createElement('div');
      practicalDiv.className = `compatibility-result ${practicalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
      practicalDiv.innerHTML = `
        <div><strong>${practicalCheck.feasible ? '‚úì' : '‚úó'} –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å:</strong></div>
        <div>${practicalCheck.feasible ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∞–ª–∏–∑—É–µ–º—ã' : '–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π'}</div>
        <div style="font-size: 11px;">–û—à–∏–±–æ–∫: ${practicalCheck.errors.length}, –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π: ${practicalCheck.warnings.length}</div>
      `;
      resultsDiv.appendChild(practicalDiv);
      
      // 3. –ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
      const numericalDiv = document.createElement('div');
      numericalDiv.className = `compatibility-result ${numericalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
      numericalDiv.innerHTML = `
        <div><strong>${numericalCheck.feasible ? '‚úì' : '‚úó'} –ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:</strong></div>
        <div>${numericalCheck.feasible ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–∞–±–∏–ª—å–Ω—ã' : '–í–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏'}</div>
        <div style="font-size: 11px;">–ü—Ä–æ–±–ª–µ–º: ${numericalCheck.issues.length}</div>
      `;
      resultsDiv.appendChild(numericalDiv);
      
      // –í—ã–≤–æ–¥ –≤—Å–µ—Ö –ø—Ä–æ–±–ª–µ–º
      const allProblems = [
        ...compatibility.errors.map(e => ({type: 'error', message: e.message})),
        ...practicalCheck.errors.map(e => ({type: 'error', message: e})),
        ...practicalCheck.warnings.map(w => ({type: 'warning', message: w})),
        ...numericalCheck.issues.map(i => ({type: i.includes('–æ—à–∏–±–∫–∞') ? 'error' : 'warning', message: i}))
      ];
      
      if (allProblems.length > 0) {
        const problemsDiv = document.createElement('div');
        problemsDiv.className = 'compatibility-result';
        problemsDiv.style.backgroundColor = '#f8f9fa';
        problemsDiv.innerHTML = '<div><strong>–î–µ—Ç–∞–ª–∏:</strong></div>';
        resultsDiv.appendChild(problemsDiv);
        
        allProblems.forEach(problem => {
          const problemDiv = document.createElement('div');
          problemDiv.className = `compatibility-result ${problem.type === 'error' ? 'validation-error' : 'validation-warning'}`;
          problemDiv.style.marginTop = '5px';
          problemDiv.innerHTML = `
            <div><strong>${problem.type === 'error' ? '‚úó' : '‚ö†'} ${problem.type === 'error' ? '–û—à–∏–±–∫–∞' : '–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ'}:</strong></div>
            <div>${problem.message}</div>
          `;
          resultsDiv.appendChild(problemDiv);
        });
      }
      
      // –ò—Ç–æ–≥–æ–≤—ã–π –≤–µ—Ä–¥–∏–∫—Ç
      const overallPassed = compatibility.passed && practicalCheck.feasible && numericalCheck.feasible;
      const verdictDiv = document.createElement('div');
      verdictDiv.className = `compatibility-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
      verdictDiv.style.fontWeight = 'bold';
      verdictDiv.style.fontSize = '14px';
      verdictDiv.innerHTML = `
        <div><strong>${overallPassed ? '‚úì –ì–û–¢–û–í–û –ö –†–ê–°–ß–Å–¢–£' : '‚úó –¢–†–ï–ë–£–Æ–¢–°–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø'}</strong></div>
        <div>${overallPassed ? '–í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ' : '–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å'}</div>
      `;
      resultsDiv.appendChild(verdictDiv);
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    // ========== –£–õ–£–ß–®–ï–ù–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ==========
    function setupEnhancedEventListeners() {
      // –î–æ–±–∞–≤–ª—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é –ø—Ä–∏ –≤–≤–æ–¥–µ –∑–Ω–∞—á–µ–Ω–∏–π
      ['value1', 'value2', 'value3'].forEach(id => {
        const input = document.getElementById(id);
        
        input.addEventListener('input', function() {
          const index = parseInt(id.replace('value', ''));
          const paramKey = document.getElementById(`param${index}`).value;
          
          if (!paramKey) return;
          
          const value = parseFloat(this.value);
          if (isNaN(value)) return;
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
          if (paramKey.includes('angle')) {
            if (value < 0.1 || value > 179.9) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–£–≥–æ–ª —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º (${value}¬∞)`, 'warning');
            } else {
              this.style.borderColor = '#2ecc71';
            }
          } else {
            if (value < 0.001) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–ó–Ω–∞—á–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ (${value})`, 'warning');
            } else if (value > 1000) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–ó–Ω–∞—á–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫–æ (${value})`, 'warning');
            } else {
              this.style.borderColor = '#2ecc71';
            }
          }
        });
      });
    }
    
    // ========== –ü–†–û–í–ï–†–ö–ê –ß–ò–°–õ–ï–ù–ù–û–ô –£–°–¢–û–ô–ß–ò–í–û–°–¢–ò ==========
    function checkNumericalFeasibility(params) {
      const issues = [];
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ NaN –∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          if (isNaN(value)) {
            issues.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} —Å–æ–¥–µ—Ä–∂–∏—Ç NaN`);
          }
          if (!isFinite(value)) {
            issues.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} —Å–æ–¥–µ—Ä–∂–∏—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ`);
          }
        }
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const definedAngles = [];
      let anglesSum = 0;
      
      if (params.angleA) {
        definedAngles.push('A');
        anglesSum += params.angleA;
      }
      if (params.angleB) {
        definedAngles.push('B');
        anglesSum += params.angleB;
      }
      if (params.angleC) {
        definedAngles.push('C');
        anglesSum += params.angleC;
      }
      
      if (definedAngles.length === 3) {
        const angleError = Math.abs(anglesSum - 180);
        if (angleError > 0.1) {
          issues.push(`–°—É–º–º–∞ —É–≥–ª–æ–≤ (${anglesSum.toFixed(2)}¬∞) –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç 180¬∞ (–æ—à–∏–±–∫–∞: ${angleError.toFixed(2)}¬∞)`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
      if (params.angleA && params.angleB && params.angleC) {
        const minAngle = Math.min(params.angleA, params.angleB, params.angleC);
        const maxAngle = Math.max(params.angleA, params.angleB, params.angleC);
        
        if (minAngle < 0.1) {
          issues.push(`–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª (${minAngle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`);
        }
        
        if (maxAngle > 179.9) {
          issues.push(`–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª (${maxAngle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ 180¬∞`);
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ—á—Ç–∏ –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
        if (anglesSum > 179.9 && anglesSum < 180.1) {
          if (maxAngle > 179.5 || minAngle < 0.5) {
            issues.push("–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π (–æ–¥–∏–Ω —É–≥–æ–ª –æ—á–µ–Ω—å –±–ª–∏–∑–æ–∫ –∫ 180¬∞)");
          }
        }
      }
      
      return {
        feasible: issues.length === 0,
        issues: issues
      };
    }
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ—Ä–∞—Å—á–µ—Ç–∞
    function triggerAutoCalculate() {
      // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä
      if (autoCalculateTimer) {
        clearTimeout(autoCalculateTimer);
      }
      
      // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á–µ—Ç —á–µ—Ä–µ–∑ 300–º—Å (–¥–µ–±–∞—É–Ω—Å–∏–Ω–≥)
      autoCalculateTimer = setTimeout(() => {
        if (validateParameterSelection() && !document.getElementById('solveBtn').disabled) {
          startSolvingEnhanced();
        }
      }, 300);
    }
    
    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–∞ –¥–ª—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π Chart.js
    if (typeof Chart !== 'undefined' && Chart.register) {
      Chart.register({
        id: 'annotation',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const annotations = chart.options.plugins?.annotation?.annotations;
          
          if (!annotations) return;
          
          Object.values(annotations).forEach(annotation => {
            if (!annotation || !annotation.xValue || !annotation.yValue) return;
            
            const meta = chart.getDatasetMeta(0);
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            
            const x = xScale.getPixelForValue(annotation.xValue);
            const y = yScale.getPixelForValue(annotation.yValue);
            
            ctx.save();
            ctx.font = annotation.font?.size + 'px ' + (annotation.font?.weight || 'normal') + ' Arial';
            ctx.fillStyle = annotation.color || '#2c3e50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const xAdj = annotation.xAdjust || 0;
            const yAdj = annotation.yAdjust || 0;
            
            ctx.fillText(annotation.content, x + xAdj, y + yAdj);
            ctx.restore();
          });
        }
      });
    }
  </script>
</body>
</html>