<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Vessel Constructor ‚Äî simulation model + 3D view</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f7fa;
      color: #333;
    }
    
    h1, h2, h3 {
      color: #2c3e50;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 2px solid #3498db;
    }
    
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .panel {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      flex: 1;
      min-width: 300px;
    }
    
    .panel h2 {
      margin-top: 0;
      color: #3498db;
      font-size: 1.4em;
    }
    
    .wide-panel {
      flex: 2;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
      align-items: center;
    }
    
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    .param-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      padding: 8px 0;
      border-bottom: 1px solid #eee;
    }
    
    .param-symbol {
      font-weight: bold;
      width: 30px;
      text-align: center;
      font-size: 1.2em;
    }
    
    .param-name {
      flex: 2;
      margin: 0 10px;
      font-size: 0.9em;
    }
    
    .param-value {
      width: 70px;
      padding: 5px;
      border: 1px solid #ddd;
      border-radius: 3px;
      text-align: right;
    }
    
    .param-unit {
      width: 30px;
      margin-left: 5px;
      color: #7f8c8d;
    }
    
    .slider-container {
      margin-bottom: 15px;
      padding-left: 40px;
    }
    
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .slider-value {
      min-width: 50px;
      text-align: right;
      font-family: monospace;
    }
    
    .param-slider {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: #ddd;
      border-radius: 3px;
      outline: none;
    }
    
    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #3498db;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .chart-container {
      height: 400px;
      position: relative;
    }

    .chart-3d-container {
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
      background: #f8f9fa;
      margin-top: 10px;
    }

    #vesselCanvas3D {
      width: 100%;
      height: 100%;
      display: block;
    }

    
    .results {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-top: 20px;
    }
    
    .result-item {
      text-align: center;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    
    .result-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #2c3e50;
      margin-top: 5px;
    }
    
    .status-panel {
      background: #fff;
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-height: 200px;
      overflow-y: auto;
    }
    
    .status-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .status-messages {
      font-family: monospace;
      font-size: 0.85em;
    }
    
    .status-message {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    
    .status-info { color: #3498db; }
    .status-success { color: #27ae60; }
    .status-warning { color: #f39c12; }
    .status-error { color: #e74c3c; }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    th {
      background: #f8f9fa;
      font-weight: bold;
    }
    
    .ok { color: #27ae60; }
    .bad { color: #e74c3c; }
    
    .scale-controls {
      display: flex;
      gap: 20px;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    
    .scale-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #3498db;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      position: relative;
    }
    
    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
    }
    
    .ontology-table {
      width: 100%;
      margin-top: 20px;
    }
    
    .ontology-type-header {
      background: #f1f8ff;
      font-size: 1.1em;
      padding: 10px;
    }
    
    .edit-btn {
      padding: 3px 8px;
      font-size: 0.8em;
      background: #f1c40f;
    }
    
    .edit-btn:hover {
      background: #f39c12;
    }
    
    .canvas-3d-container {
      width: 100%;
      height: 400px;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
      background: #f8f9fa;
      margin-top: 10px;
    }
    
    .canvas-3d-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .canvas-3d-controls button {
      padding: 5px 10px;
      font-size: 0.9em;
    }
    
    .rotation-info {
      font-family: monospace;
      padding: 5px 10px;
      background: #f8f9fa;
      border-radius: 3px;
      font-size: 0.9em;
      margin-left: auto;
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #bdc3c7;
      transition: .4s;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
    }
    
    input:checked + .slider {
      background-color: #2ecc71;
    }
    
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    .slider.round {
      border-radius: 24px;
    }
    
    .slider.round:before {
      border-radius: 50%;
    }
    
    .controls-below-chart {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #eee;
    }
    
    .chart-controls {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>Vessel Constructor ‚Äî simulation model + 3D view</h1>
  
  <div class="container">
    <!-- –ü–∞–Ω–µ–ª—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ -->
    <div class="panel">
      <h2>Vessel Parameters</h2>
      <div id="paramsContainer"></div>
    </div>
    
    <!-- –ü–∞–Ω–µ–ª—å –≥—Ä–∞—Ñ–∏–∫–∞ -->
    <div class="panel wide-panel">
      <h2>2D Vessel Profile</h2>
      <div class="chart-container">
        <canvas id="vesselChart"></canvas>
      </div>
      <div class="scale-controls">
        <div class="scale-control">
          <span>Y scale:</span>
          <input type="range" id="yScale" min="50" max="200" value="100">
          <span id="yScaleLabel">100</span>%
        </div>
        <div class="scale-control">
          <span>X scale:</span>
          <input type="range" id="xScale" min="50" max="200" value="100">
          <span id="xScaleLabel">100</span>%
        </div>
      </div>
      
      <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥ –¥–∏–∞–≥—Ä–∞–º–º–æ–π -->
      <div class="controls-below-chart">
        <h3>Model Controls</h3>
        <div class="controls chart-controls">
          <select id="ontologySelect" onchange="changeOntologyMode()">
            <option value="all">All vessels</option>
            <option value="vase">Vase</option>
            <option value="dish">Dish</option>
            <option value="cup">Cup</option>
            <option value="glass">Glass</option>
          </select>
          <button onclick="generateRandomProblem()">üé≤ Random problem</button>
          <button onclick="calculateVessel()">üîÑ Calculate</button>
          <button onclick="clearAll()">üóëÔ∏è Clear all</button>
          <button onclick="toggleDebug()">üêõ Debug</button>
          <button id="toggleMessagesBtn" onclick="toggleStatusPanel()" title="–°–≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è">üì®</button>
        </div>
      </div>

      <!-- 3D –≤–∏–¥ (–ø–µ—Ä–µ–º–µ—â—ë–Ω –ø–æ–¥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—å—é) -->
      <h2 style="margin-top: 30px;">3D Vessel View</h2>
      <div class="chart-container chart-3d-container">
        <canvas id="vesselCanvas3D"></canvas>
      </div>
      <div class="canvas-3d-controls">
        <button onclick="rotateVessel('x', 10)">‚Üª Forward</button>
        <button onclick="rotateVessel('x', -10)">‚Ü∫ Back</button>
        <button onclick="rotateVessel('y', 10)">‚Üª Right</button>
        <button onclick="rotateVessel('y', -10)">‚Ü∫ Left</button>
        <button onclick="resetRotation()">üîÑ Reset</button>
        <button id="toggleWireframe" onclick="toggleWireframe()">
          <span id="wireframeIcon">üî≥</span> Wireframe
        </button>
        <button onclick="toggleAutoRotate()">
          <span id="autoRotateIcon">‚ñ∂</span> Auto-rotate
        </button>
        <div class="rotation-info">
          <span id="rotationInfo">Rotation: X:25¬∞ Y:45¬∞</span>
        </div>
      </div>
    </div>
  </div>
  
  <div class="container">
    <!-- –ü–∞–Ω–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ -->
    <div class="panel">
      <h2>Main Results</h2>
      <div class="results">
        <div class="result-item">
          <div>Vessel height h</div>
          <div id="heightText" class="result-value">‚Äî</div>
        </div>
        <div class="result-item">
          <div>Volume V</div>
          <div id="volumeText" class="result-value">‚Äî</div>
        </div>
        <div class="result-item">
          <div>Weight P</div>
          <div id="weightText" class="result-value">‚Äî</div>
        </div>
      </div>
      <h3 style="margin-top: 20px;">Ontological classification</h3>
      <div id="ontologyResults">Enter parameters and run calculation</div>
    </div>
  </div>
  
  <!-- –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç—É—Å–∞ -->
  <div id="statusPanel" class="status-panel">
    <div class="status-header">
      <span id="statusText" style="font-weight: bold;">Done</span>
      <div>
        <label class="toggle-switch" id="globalMessagesToggle">
          <input type="checkbox" checked>
          <span class="toggle-slider"></span>
        </label>
        <button onclick="clearStatusMessages()" style="padding: 5px 10px; font-size: 0.8em;">Clear</button>
        <span id="statusCounter">(0)</span>
      </div>
    </div>
    <div id="statusMessages" class="status-messages"></div>
  </div>
  
  <!-- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã -->
  <div class="container">
    <div class="panel wide-panel">
      <h2>All parameters (input and derived)</h2>
      <table>
        <thead>
          <tr>
            <th>‚Ññ</th>
            <th>Name</th>
            <th>Symbol</th>
            <th>Type</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody id="paramsTableBody"></tbody>
      </table>
    </div>
  </div>
  
  <!-- –ü–∞–Ω–µ–ª—å –æ—Ç–ª–∞–¥–∫–∏ -->
  <div id="debugPanel" class="panel" style="display: none;">
    <h2>Debug information</h2>
    <div id="debugResults"></div>
  </div>
  
  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –æ–Ω—Ç–æ–ª–æ–≥–∏–∏ -->
  <div id="ontologyModal" class="modal">
    <div class="modal-content">
      <span class="close-modal" onclick="hideOntologyEditor()">√ó</span>
      <h2>Ontology Editor</h2>
      <div style="margin: 20px 0;">
        <button onclick="exportOntologyConfig()">üì• Export configuration</button>
        <button onclick="document.getElementById('importConfig').click()">üì§ Import configuration</button>
        <input type="file" id="importConfig" accept=".json" style="display:none" onchange="importOntologyConfig(this.files[0])">
        <button onclick="resetOntologyToDefaults()" style="background:#e74c3c;">üîÑ Reset to defaults</button>
        <button id="saveAllBtn" onclick="saveAllOntologyChanges()" style="display:none; background:#2ecc71;">üíæ Save all</button>
      </div>
      <table class="ontology-table">
        <thead>
          <tr>
            <th>Parameter</th>
            <th>Symbol / ID</th>
            <th>Min</th>
            <th>Max</th>
            <th>Step</th>
            <th>Constraints</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="ontologyTableBody"></tbody>
      </table>
    </div>
  </div>
  
  <!-- –ö–Ω–æ–ø–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –æ–Ω—Ç–æ–ª–æ–≥–∏–∏ -->
  <div style="text-align: center; margin-top: 30px;">
    <button onclick="showOntologyEditor()">‚öôÔ∏è Ontology Editor</button>
  </div>

<script>
  // ========== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
  
  // –ï–î–ò–ù–´–ô –ö–û–ù–§–ò–ì –í–°–ï–• –ü–ê–†–ê–ú–ï–¢–†–û–í
  const unifiedParamConfig = {
    common: [
      { 
        id: 'A', 
        symbol: 'A', 
        name: 'Ellipsoid diameter (scale factor)', 
        unit: '', 
        min: 4,
        max: 40,
        step: 1,
        fixed: false,
        description: '–î–∏–∞–º–µ—Ç—Ä —ç–ª–ª–∏–ø—Å–æ–∏–¥–∞, –º–∞—Å—à—Ç–∞–±–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–ª—è –≤—Å–µ—Ö –ª–∏–Ω–µ–π–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤' 
      },
      { 
        id: 'delta', 
        symbol: 'Œ¥', 
        name: 'Wall thickness', 
        unit: '', 
        min: 0.01, 
        max: 0.05, 
        step: 0.01,
        description: '–î–æ–ª–∂–Ω–∞ –±—ã—Ç—å > 0' 
      },
      { 
        id: 'gamma', 
        symbol: 'Œ≥', 
        name: 'Material density', 
        unit: '', 
        min: 1, 
        max: 8, 
        step: 1,
        description: '–î–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0' 
      }
    ],
    
    variable: [
      { 
        id: 'B', 
        symbol: 'B', 
        name: 'Vertical ellipsoid axis (height)', 
        unit: '' 
      },
      { 
        id: 'l_S', 
        symbol: 'l‚Çõ', 
        name: 'Neck generatrix length', 
        unit: '' 
      },
      { 
        id: 'h_F', 
        symbol: 'h_F', 
        name: 'Pedestal cone height', 
        unit: '' 
      },
      { 
        id: 'phi_S', 
        symbol: 'œÜ‚Çõ', 
        name: 'Neck lower rim angle', 
        unit: '¬∞' 
      },
      { 
        id: 'phi_F', 
        symbol: 'œÜ_F', 
        name: 'Pedestal upper rim angle', 
        unit: '¬∞' 
      },
      { 
        id: 'alpha_S', 
        symbol: 'Œ±‚Çõ', 
        name: 'Neck inclination angle', 
        unit: '¬∞' 
      },
      { 
        id: 'alpha_F', 
        symbol: 'Œ±_F', 
        name: 'Pedestal inclination angle', 
        unit: '¬∞' 
      }
    ]
  };

  // –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ï –î–ê–ù–ù–´–ï
  const BASE_X_MIN = -4.0;
  const BASE_X_MAX =  4.0;
  const BASE_Y_MIN = -3.0;
  const BASE_Y_MAX =  3.0;

  let currentOntologyMode = 'all';

  // –ò–°–•–û–î–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´
  let inputParams = [];

  const derivedParams = [
    { key: 'h',    symbol: 'h',    name: 'Vessel height' },
    { key: 'h_S',  symbol: 'h_S',  name: 'Neck height' },
    { key: 'd_T',  symbol: 'd_T',  name: 'Neck top rim diameter' },
    { key: 'd_S',  symbol: 'd_S',  name: 'Neck bottom rim diameter' },
    { key: 'd_F',  symbol: 'd_F',  name: 'Base top rim diameter' },
    { key: 'd_G',  symbol: 'd_G',  name: 'Base bottom rim diameter' },
    { key: 'd_L',  symbol: 'd_L',  name: 'Base disk diameter' },
    { key: 'V_SF', symbol: 'V_SF', name: 'Elliptic section volume' },
    { key: 'V',    symbol: 'V',    name: 'Vessel volume' },
    { key: 'P',    symbol: 'P',    name: 'Object weight' }
  ];

  // –û–ù–¢–û–õ–û–ì–ò–ß–ï–°–ö–ò–ï –û–ì–†–ê–ù–ò–ß–ï–ù–ò–Ø
  let ontologyConstraints = {
    vase: {
      name: 'Vase',
      constraints: [
        { param: 'B',   condition: (p) => (p.B - 0.5) >= 0, desc: 'B/A ‚â• 0.5' },
        { param: 'l_S', condition: (p) => (p.l_S - 0.25) >= 0, desc: 'l‚Çõ/A ‚â• 0.25' },
        { param: 'phi_S',   condition: (p) => (p.phi_S - 60) >= 0, desc: 'œÜ‚Çõ ‚â• 60' },
        { param: 'phi_S',   condition: (p) => (-p.phi_S + 80) >= 0, desc: 'œÜ‚Çõ ‚â§ 80' },
        { param: 'alpha_S', condition: (p) => (p.alpha_S - 60) >= 0, desc: 'Œ±‚Çõ ‚â• 60' },
        { param: 'alpha_S', condition: (p) => (-p.alpha_S + 90) >= 0, desc: 'Œ±‚Çõ ‚â§ 90' }
      ]
    },
    dish: {
      name: 'Dish',
      constraints: [
        { param: 'B',   condition: (p) => (-p.B + 0.5) >= 0, desc: 'B/A ‚â§ 0.5' },
        { param: 'l_S', condition: (p) => (p.l_S - 0.5) >= 0, desc: 'l‚Çõ/A ‚â• 0.5' },
        { param: 'phi_S',   condition: (p) => (-p.phi_S - 50) >= 0, desc: 'œÜ‚Çõ ‚â§ -50' },
        { param: 'alpha_S', condition: (p) => (20 - p.alpha_S) >= 0, desc: 'Œ±‚Çõ ‚â§ 20' }
      ]
    },
    cup: {
      name: 'Cup',
      constraints: [
        { param: 'B',   condition: (p) => (p.B - 0.5) >= 0, desc: 'B/A ‚â• 0.5' },
        { param: 'l_S', condition: (p) => (-p.l_S + 0.1) >= 0, desc: 'l‚Çõ/A ‚â§ 0.1' },
        { param: 'phi_S',   condition: (p) => (p.phi_S + 20) >= 0, desc: 'œÜ‚Çõ ‚â• -20' },
        { param: 'phi_S',   condition: (p) => (20 - p.phi_S) >= 0, desc: 'œÜ‚Çõ ‚â§ 20' },
        { param: 'alpha_S', condition: (p) => (20 - p.alpha_S) >= 0, desc: 'Œ±‚Çõ ‚â§ 20' }
      ]
    },
    glass: {
      name: 'Glass',
      constraints: [
        { param: 'l_S', condition: (p) => (p.l_S - (0.5 + p.B) / 2) >= 0, desc: 'l‚Çõ/A ‚â• (0.5 + B/A)/2' },
        { param: 'phi_S', condition: (p) => ((p.phi_S - 70) >= 0) || ((p.phi_S + 40) <= 0), desc: '(œÜ‚Çõ ‚â• 70) ‚à® (œÜ‚Çõ ‚â§ -40)' },
        { param: 'alpha_S', condition: (p) => (p.alpha_S - 70) >= 0, desc: 'Œ±‚Çõ ‚â• 70' },
        { param: 'alpha_S', condition: (p) => (-p.alpha_S + 90) >= 0, desc: 'Œ±‚Çõ ‚â§ 90' }
      ]
    }
  };

  // –î–ò–ê–ü–ê–ó–û–ù–´ –î–õ–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò
  let ontologyRanges = {
    all: {
      name: 'All vessels',
      ranges: {
        'A': { min: 4, max: 40, step: 2 },
        'B': { min: 0.5, max: 1.25, step: 0.05 },
        'l_S': { min: 0.5, max: 1.25, step: 0.05 },
        'h_F': { min: 0.05, max: 0.25, step: 0.05 },
        'phi_S': { min: -80, max: 80, step: 5 },
        'phi_F': { min: -60, max: -20, step: 5 },
        'alpha_S': { min: 5, max: 90, step: 5 },
        'alpha_F': { min: -120, max: -60, step: 5 },
        'delta': { min: 0.01, max: 0.05, step: 0.01 },
        'gamma': { min: 1, max: 8, step: 1 }
      }
    },
    vase: {
      name: 'Vase',
      ranges: {
        'A': { min: 4, max: 40, step: 2 },
        'B': { min: 0.5, max: 1.25, step: 0.05 },
        'l_S': { min: 0.25, max: 1.25, step: 0.05 },
        'h_F': { min: 0.05, max: 0.5, step: 0.05 },
        'phi_S': { min: 60, max: 80, step: 5 },
        'phi_F': { min: -80, max: 0, step: 5 },
        'alpha_S': { min: 60, max: 90, step: 5 },
        'alpha_F': { min: -120, max: -60, step: 5 },
        'delta': { min: 0.01, max: 0.05, step: 0.01 },
        'gamma': { min: 1, max: 8, step: 1 }
      }
    },
    dish: {
      name: 'Dish',
      ranges: {
        'A': { min: 4, max: 40, step: 2 },
        'B': { min: 0.05, max: 0.5, step: 0.05 },
        'l_S': { min: 0.5, max: 1.25, step: 0.05 },
        'h_F': { min: 0.05, max: 0.5, step: 0.05 },
        'phi_S': { min: -80, max: -50, step: 5 },
        'phi_F': { min: -80, max: 0, step: 5 },
        'alpha_S': { min: 5, max: 20, step: 5 },
        'alpha_F': { min: -120, max: -60, step: 5 },
        'delta': { min: 0.01, max: 0.05, step: 0.01 },
        'gamma': { min: 1, max: 8, step: 1 }
      }
    },
    cup: {
      name: 'Cup',
      ranges: {
        'A': { min: 4, max: 40, step: 2 },
        'B': { min: 0.5, max: 1.25, step: 0.05 },
        'l_S': { min: 0.0025, max: 0.0125, step: 0.0005 },
        'h_F': { min: 0.05, max: 0.25, step: 0.05 },
        'phi_S': { min: -20, max: 20, step: 5 },
        'phi_F': { min: -80, max: 0, step: 5 },
        'alpha_S': { min: 5, max: 20, step: 5 },
        'alpha_F': { min: -120, max: -60, step: 5 },
        'delta': { min: 0.01, max: 0.05, step: 0.01 },
        'gamma': { min: 1, max: 8, step: 1 }
      }
    },
    glass: {
      name: 'Glass',
      ranges: {
        'A': { min: 4, max: 40, step: 2 },
        'B': { min: 0.5, max: 1.25, step: 0.05 },
        'l_S': { min: 0.5, max: 1.25, step: 0.05 },
        'h_F': { min: 0.05, max: 0.25, step: 0.05 },
        'phi_S': { min: -80, max: 80, step: 5 },
        'phi_F': { min: -60, max: -20, step: 5 },
        'alpha_S': { min: 70, max: 90, step: 5 },
        'alpha_F': { min: -120, max: -60, step: 5 },
        'delta': { min: 0.01, max: 0.05, step: 0.01 },
        'gamma': { min: 1, max: 8, step: 1 }
      }
    }
  };

  // ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
  let chart = null;
  let currentParams = {};
  let baseYExtents = { min: BASE_Y_MIN, max: BASE_Y_MIN };
  let ontologyChanges = {};
  let messagesEnabled = true;
  let messageCount = 0;
  let currentAValue = 22;
  let chartParams = {};
  let autoRecalcEnabled = false;
  let recalcTimeout = null;

  // ========== 3D –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
  let canvas3D, ctx3D;
  let rotationX = 25;
  let rotationY = 45;
  let isWireframe = false;
  let autoRotate = false;
  let animationId = null;

  // ========== –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –°–û–û–ë–©–ï–ù–ò–Ø–ú–ò ==========
  
  function toggleGlobalMessages() {
    const toggle = document.getElementById('globalMessagesToggle');
    const messagesBtn = document.getElementById('toggleMessagesBtn');
    const statusPanel = document.getElementById('statusPanel');
    
    if (!toggle || !messagesBtn) return;
    
    messagesEnabled = !messagesEnabled;
    
    if (messagesEnabled) {
      toggle.classList.add('active');
      messagesBtn.classList.add('active');
      messagesBtn.title = '–°–∫—Ä—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
      statusPanel.style.display = 'block';
    } else {
      toggle.classList.remove('active');
      messagesBtn.classList.remove('active');
      messagesBtn.title = '–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
      statusPanel.style.display = 'none';
    }
    
    localStorage.setItem('vessel_messagesEnabled', messagesEnabled);
    
    if (messagesEnabled) {
      showStatus(`–°–æ–æ–±—â–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã ${messagesEnabled ? '–≤–∫–ª—é—á–µ–Ω—ã' : '–æ—Ç–∫–ª—é—á–µ–Ω—ã'}`, 'info');
    }
  }
  
  function toggleStatusPanel() {
    const statusPanel = document.getElementById('statusPanel');
    const messagesBtn = document.getElementById('toggleMessagesBtn');
    
    if (statusPanel.classList.contains('collapsed')) {
      statusPanel.classList.remove('collapsed');
      messagesBtn.innerHTML = 'üì®';
      messagesBtn.title = '–°–≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
    } else {
      statusPanel.classList.add('collapsed');
      messagesBtn.innerHTML = 'üì©';
      messagesBtn.title = '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
    }
    
    localStorage.setItem('vessel_statusPanelCollapsed', statusPanel.classList.contains('collapsed'));
  }
  
  function clearStatusMessages() {
    const messagesContainer = document.getElementById('statusMessages');
    messagesContainer.innerHTML = '';
    messageCount = 0;
    updateMessageCounter();
  }
  
  function updateMessageCounter() {
    const counter = document.getElementById('statusCounter');
    if (counter) {
      counter.textContent = `(${messageCount})`;
    }
  }
  
  function showStatus(message, type, details) {
    if (!messagesEnabled && type !== 'error') {
      return;
    }
    
    const panel = document.getElementById('statusPanel');
    const messages = document.getElementById('statusMessages');
    const statusPanelIcon = document.getElementById('statusPanelIcon');
    
    if (type === 'error' && panel.classList.contains('collapsed')) {
      panel.classList.remove('collapsed');
    }
    
    const typeClass = 'status-' + (type || 'info');
    const now = new Date().toLocaleTimeString('ru-RU', { hour12: false });
    messageCount++;
    
    const icons = {
      'info': 'üì®',
      'success': '‚úÖ',
      'warning': '‚ö†Ô∏è',
      'error': '‚ùå'
    };
    
    let html = `<div class="status-message ${typeClass}">[${now}] ${message}</div>`;
    if (details && details.length > 0) {
      details.forEach(d => {
        html += `<div class="status-message status-info" style="margin-left:15px;">‚Ä¢ ${d}</div>`;
      });
    }
    
    messages.innerHTML = html + messages.innerHTML;
    
    const allMessages = messages.querySelectorAll('.status-message');
    if (allMessages.length > 20) {
      for (let i = 20; i < allMessages.length; i++) {
        allMessages[i].remove();
      }
    }
    
    updateMessageCounter();
    
    if (type === 'error') {
      document.getElementById('statusText').textContent = 'Error';
      document.getElementById('statusText').style.color = '#e74c3c';
    } else if (type === 'success') {
      document.getElementById('statusText').textContent = '–£—Å–ø–µ—à–Ω–æ';
      document.getElementById('statusText').style.color = '#27ae60';
    } else if (type === 'warning') {
      document.getElementById('statusText').textContent = '–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ';
      document.getElementById('statusText').style.color = '#f39c12';
    }
    
    setTimeout(() => {
      document.getElementById('statusText').textContent = 'Done';
      document.getElementById('statusText').style.color = '#16a085';
    }, 5000);
  }

  // ========== –§–£–ù–ö–¶–ò–ò –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–Ø ==========
  
  function getNormalizedParams(realParams) {
    const A_real = realParams.A || currentAValue;
    const normalized = {};
    
    Object.keys(realParams).forEach(key => {
      if (key === 'A') {
        normalized[key] = 1.0; // –ù–æ—Ä–º–∏—Ä—É–µ–º A –∫ 1
      } else if (['phi_S', 'phi_F', 'alpha_S', 'alpha_F', 'delta', 'gamma'].includes(key)) {
        // –£–≥–ª—ã –∏ –±–µ–∑—Ä–∞–∑–º–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        normalized[key] = realParams[key];
      } else {
        // –õ–∏–Ω–µ–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ A
        normalized[key] = realParams[key] / A_real;
      }
    });
    
    return normalized;
  }
  
  function checkOntologyConstraints(params_norm, ontologyMode) {
    if (ontologyMode === 'all') return true;
    
    const constraints = ontologyConstraints[ontologyMode];
    if (!constraints || !constraints.constraints) return true;
    
    for (const constraint of constraints.constraints) {
      try {
        if (!constraint.condition(params_norm)) {
          return false;
        }
      } catch (e) {
        console.error('Error –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:', constraint.desc, e);
        return false;
      }
    }
    
    return true;
  }
  
  function updateSliderRangesForA(A_real) {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
    const normValues = {};
    ['B', 'l_S', 'h_F'].forEach(paramId => {
      const inputEl = document.getElementById(`value_${paramId}`);
      if (inputEl && inputEl.value) {
        const currentValue = parseFloat(inputEl.value);
        normValues[paramId] = currentValue / currentAValue;
      }
    });
    
    currentAValue = A_real;
    
    ['B', 'l_S', 'h_F'].forEach(paramId => {
      const paramDef = inputParams.find(p => p.key === paramId);
      if (!paramDef) return;
      
      const currentMode = document.getElementById('ontologySelect').value;
      const normRange = ontologyRanges[currentMode].ranges[paramId];
      if (!normRange) return;
      
      // –î–∏–∞–ø–∞–∑–æ–Ω—ã –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö
      const realMin = normRange.min * A_real;
      const realMax = normRange.max * A_real;
      const realStep = normRange.step * A_real;
      
      paramDef.min = realMin;
      paramDef.max = realMax;
      paramDef.step = realStep;
      
      const inputEl = document.getElementById(`value_${paramId}`);
      const sliderEl = document.getElementById(`slider_${paramId}`);
      const sliderValEl = document.getElementById(`sliderVal_${paramId}`);
      
      if (inputEl && sliderEl && sliderValEl) {
        let finalValue;
        
        if (normValues[paramId] !== undefined) {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
          const normValue = normValues[paramId];
          const clampedNormValue = Math.max(normRange.min, Math.min(normRange.max, normValue));
          const steps = Math.round((clampedNormValue - normRange.min) / normRange.step);
          const correctedNormValue = normRange.min + steps * normRange.step;
          finalValue = correctedNormValue * A_real;
        } else {
          // –ù–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ - —Å–µ—Ä–µ–¥–∏–Ω–∞ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
          finalValue = (realMin + realMax) / 2;
          const steps = Math.round((finalValue - realMin) / realStep);
          finalValue = realMin + steps * realStep;
        }
        
        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É
        finalValue = Math.max(realMin, Math.min(realMax, finalValue));
        
        inputEl.min = realMin;
        inputEl.max = realMax;
        inputEl.step = realStep;
        inputEl.value = finalValue.toFixed(realStep < 1 ? 2 : 0);
        
        const t = (realMax === realMin) ? 50 : ((finalValue - realMin) / (realMax - realMin)) * 100;
        sliderEl.value = Math.min(100, Math.max(0, t));
        sliderValEl.textContent = finalValue.toFixed(realStep < 1 ? 2 : 0);
      }
    });
  }
  
  function handleAChange() {
    const A_input = document.getElementById('value_A');
    const A_real = parseFloat(A_input.value);
    
    if (isNaN(A_real) || A_real < 4 || A_real > 40) {
      showStatus('Parameter A –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 4 –¥–æ 40', 'error');
      return;
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ª–∏–Ω–µ–π–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
    const savedNormValues = {};
    ['B', 'l_S', 'h_F'].forEach(paramId => {
      const inputEl = document.getElementById(`value_${paramId}`);
      if (inputEl && inputEl.value) {
        const currentValue = parseFloat(inputEl.value);
        savedNormValues[paramId] = currentValue / currentAValue;
      }
    });
    
    currentAValue = A_real;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –ø–æ–ª–∑—É–Ω–∫–æ–≤
    updateSliderRangesForA(A_real);
    
    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ª–∏–Ω–µ–π–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    ['B', 'l_S', 'h_F'].forEach(paramId => {
      if (savedNormValues[paramId] !== undefined) {
        const inputEl = document.getElementById(`value_${paramId}`);
        const sliderEl = document.getElementById(`slider_${paramId}`);
        const sliderValEl = document.getElementById(`sliderVal_${paramId}`);
        
        if (inputEl && sliderEl && sliderValEl) {
          const newAbsoluteValue = savedNormValues[paramId] * A_real;
          const paramDef = inputParams.find(p => p.key === paramId);
          
          if (paramDef) {
            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∫ –¥–æ–ø—É—Å—Ç–∏–º–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É
            const clampedValue = Math.max(paramDef.min, Math.min(paramDef.max, newAbsoluteValue));
            const steps = Math.round((clampedValue - paramDef.min) / paramDef.step);
            const correctedValue = paramDef.min + steps * paramDef.step;
            
            inputEl.value = correctedValue.toFixed(paramDef.step < 1 ? 2 : 0);
            
            const t = (paramDef.max === paramDef.min) ? 50 : 
                      ((correctedValue - paramDef.min) / (paramDef.max - paramDef.min)) * 100;
            sliderEl.value = Math.min(100, Math.max(0, t));
            sliderValEl.textContent = correctedValue.toFixed(paramDef.step < 1 ? 2 : 0);
          }
        }
      }
    });
    
    showStatus(`Scale factor A —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: ${A_real}`, 'info');
    
    if (autoRecalcEnabled) {
      scheduleAutoRecalc();
    } else {
      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º
      calculateVessel();
    }
  }

  // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
  
  function initInputParams() {
    inputParams = [];
    
    unifiedParamConfig.common.forEach(param => {
      inputParams.push({
        key: param.id,
        symbol: param.symbol,
        name: param.name,
        unit: param.unit,
        min: param.min,
        max: param.max,
        step: param.step
      });
    });
    
    unifiedParamConfig.variable.forEach(param => {
      const ranges = ontologyRanges.all.ranges[param.id];
      inputParams.push({
        key: param.id,
        symbol: param.symbol,
        name: param.name,
        unit: param.unit,
        min: ranges ? ranges.min : 0,
        max: ranges ? ranges.max : 1,
        step: ranges ? ranges.step : 0.1
      });
    });
  }
  
  function updateParamUI(paramDef, preserveValue = null) {
    const inputEl = document.getElementById(`value_${paramDef.key}`);
    const sliderEl = document.getElementById(`slider_${paramDef.key}`);
    const sliderValEl = document.getElementById(`sliderVal_${paramDef.key}`);
    
    if (!inputEl || !sliderEl || !sliderValEl) return;
    
    inputEl.min = paramDef.min;
    inputEl.max = paramDef.max;
    inputEl.step = paramDef.step;
    
    let newValue;
    if (preserveValue !== null && !isNaN(preserveValue)) {
        newValue = Math.max(paramDef.min, Math.min(paramDef.max, preserveValue));
    } else {
        newValue = (paramDef.min + paramDef.max) / 2;
    }
    
    const steps = Math.round((newValue - paramDef.min) / paramDef.step);
    newValue = paramDef.min + steps * paramDef.step;
    newValue = Math.max(paramDef.min, Math.min(paramDef.max, newValue));
    
    const formattedValue = newValue.toFixed(paramDef.unit === '¬∞' ? 0 : (paramDef.step < 1 ? 2 : 0));
    
    const currentValue = parseFloat(inputEl.value);
    if (!isNaN(currentValue) && currentValue > paramDef.max) {
        inputEl.value = formattedValue;
    } else if (!isNaN(currentValue) && currentValue < paramDef.min) {
        inputEl.value = formattedValue;
    } else if (preserveValue === null) {
        inputEl.value = formattedValue;
    }
    
    const t = (paramDef.max === paramDef.min) ? 50 : 
              ((newValue - paramDef.min) / (paramDef.max - paramDef.min)) * 100;
    sliderEl.value = Math.min(100, Math.max(0, t));
    sliderValEl.textContent = formattedValue;
  }

  // ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ==========
  
  function changeOntologyMode() {
    const select = document.getElementById('ontologySelect');
    currentOntologyMode = select.value;
    
    const A_input = document.getElementById('value_A');
    const A_real = parseFloat(A_input.value) || 20;
    updateSliderRangesForA(A_real);
  }

  // ========== –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–õ–£–ß–ê–ô–ù–û–ô –ó–ê–î–ê–ß–ò ==========
  
  function generateRandomProblem() {
    const select = document.getElementById('ontologySelect');
    const ontologyMode = select.value;
    const ontology = ontologyRanges[ontologyMode] || ontologyRanges.all;
    
    try {
      // 1. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º A (–¥–∏–∞–º–µ—Ç—Ä —ç–ª–ª–∏–ø—Å–æ–∏–¥–∞)
      const A_range = ontology.ranges['A'];
      const A_steps = Math.floor((A_range.max - A_range.min) / A_range.step);
      const A_randomStep = Math.floor(Math.random() * (A_steps + 1));
      const A_real = A_range.min + A_randomStep * A_range.step;
      
      // 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (A=1)
      const params_norm = { A: 1.0 };
      
      // 2.1. –£–≥–ª—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –æ—Ç—Å—á—ë—Ç–∞
      const phiFRange = ontology.ranges['phi_F'];
      const phiFSteps = Math.floor((phiFRange.max - phiFRange.min) / phiFRange.step);
      const phiFRandomStep = Math.floor(Math.random() * (phiFSteps + 1));
      const phiFVal = phiFRange.min + phiFRandomStep * phiFRange.step;
      
      const phiSRange = ontology.ranges['phi_S'];
      let phiSMin = Math.max(phiSRange.min, phiFVal);
      let phiSMax = phiSRange.max;
      
      if (phiSMin > phiSMax) phiSMin = phiSRange.min;
      
      const phiSSteps = Math.floor((phiSMax - phiSMin) / phiSRange.step);
      const phiSRandomStep = Math.floor(Math.random() * (phiSSteps + 1));
      const phiSVal = phiSMin + phiSRandomStep * phiSRange.step;
      
      params_norm.phi_F = phiFVal;
      params_norm.phi_S = phiSVal;
      
      // 2.2. –õ–∏–Ω–µ–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
      ['B', 'l_S', 'h_F'].forEach(paramId => {
        const range = ontology.ranges[paramId];
        const steps = Math.floor((range.max - range.min) / range.step);
        const randomStep = Math.floor(Math.random() * (steps + 1));
        params_norm[paramId] = range.min + randomStep * range.step;
      });
      
      // 2.3. –£–≥–ª—ã –Ω–∞–∫–ª–æ–Ω–∞ Œ±_S (–≥–æ—Ä–ª–æ–≤–∏–Ω—ã)
      const alphaSRange = ontology.ranges['alpha_S'];
      const alphaSSteps = Math.floor((alphaSRange.max - alphaSRange.min) / alphaSRange.step);
      const alphaSRandomStep = Math.floor(Math.random() * (alphaSSteps + 1));
      params_norm.alpha_S = alphaSRange.min + alphaSRandomStep * alphaSRange.step;
      
      // 2.4. Œ¥ (—Ç–æ–ª—â–∏–Ω–∞ —Å—Ç–µ–Ω–∫–∏)
      const deltaRange = ontology.ranges['delta'];
      const deltaSteps = Math.floor((deltaRange.max - deltaRange.min) / deltaRange.step);
      const deltaRandomStep = Math.floor(Math.random() * (deltaSteps + 1));
      params_norm.delta = deltaRange.min + deltaRandomStep * deltaRange.step;
      
      // 2.5. Œ≥ (—É–¥–µ–ª—å–Ω—ã–π –≤–µ—Å –º–∞—Ç–µ—Ä–∏–∞–ª–∞)
      const gammaRange = ontology.ranges['gamma'];
      const gammaSteps = Math.floor((gammaRange.max - gammaRange.min) / gammaRange.step);
      const gammaRandomStep = Math.floor(Math.random() * (gammaSteps + 1));
      params_norm.gamma = gammaRange.min + gammaRandomStep * gammaRange.step;
      
      // 3. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º l_S —Å–æ–≥–ª–∞—Å–Ω–æ –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º
      if (ontologyMode === 'glass') {
        const minL_S = (params_norm.A + params_norm.B) / 2;
        if (params_norm.l_S < minL_S) {
          params_norm.l_S = minL_S;
        }
      }
      
      if (ontologyMode === 'vase') {
        const minL_S = params_norm.A / 2;
        if (params_norm.l_S < minL_S) {
          params_norm.l_S = minL_S;
        }
      }
      
      if (ontologyMode === 'dish') {
        const minL_S = params_norm.A;
        if (params_norm.l_S < minL_S) {
          params_norm.l_S = minL_S;
        }
      }
      
      if (ontologyMode === 'cup') {
        const maxL_S = params_norm.A / 5;
        if (params_norm.l_S > maxL_S) {
          params_norm.l_S = maxL_S;
        }
      }
      
      // 4. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º Œ±_F (—É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞ –ø–æ—Å—Ç–∞–º–µ–Ω—Ç–∞)
      const alphaFRange = ontology.ranges['alpha_F'];
      const alphaFSteps = Math.floor((alphaFRange.max - alphaFRange.min) / alphaFRange.step);
      const alphaFRandomStep = Math.floor(Math.random() * (alphaFSteps + 1));
      let alphaF_val = alphaFRange.min + alphaFRandomStep * alphaFRange.step;
      
      const stepsFromMin = Math.round((alphaF_val - alphaFRange.min) / alphaFRange.step);
      params_norm.alpha_F = alphaFRange.min + stepsFromMin * alphaFRange.step;
      params_norm.alpha_F = Math.max(alphaFRange.min, Math.min(alphaFRange.max, params_norm.alpha_F));
      
      // 5. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –≤ UI
      inputParams.forEach(def => {
        const el = document.getElementById(`value_${def.key}`);
        const slider = document.getElementById(`slider_${def.key}`);
        const sliderVal = document.getElementById(`sliderVal_${def.key}`);
        
        let value;
        if (def.key === 'A') {
          value = A_real;
        } else if (['phi_S', 'phi_F', 'alpha_S', 'alpha_F', 'delta', 'gamma'].includes(def.key)) {
          // –£–≥–ª—ã –∏ –±–µ–∑—Ä–∞–∑–º–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
          value = params_norm[def.key];
        } else {
          // –õ–∏–Ω–µ–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ
          value = params_norm[def.key] * A_real;
        }
        
        if (el && value !== undefined) {
          const formattedValue = value.toFixed(def.unit === '¬∞' ? 0 : (def.step < 1 ? 2 : 0));
          el.value = formattedValue;
          
          if (slider && sliderVal) {
            const t = (def.max === def.min) ? 50 : ((value - def.min) / (def.max - def.min)) * 100;
            slider.value = Math.min(100, Math.max(0, t));
            sliderVal.textContent = formattedValue;
          }
        }
      });
      
      // 6. –û–±–Ω–æ–≤–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –ø–æ–ª–∑—É–Ω–∫–æ–≤
      updateSliderRangesForA(A_real);
      
      // 7. –í—ã–ø–æ–ª–Ω—è–µ–º —Ä–∞—Å—á—ë—Ç
      calculateVessel();
      
      showStatus(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Å–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–∞—á–∞ (A=${A_real})`, 'success');
      
    } catch (e) {
      showStatus(`Error –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: ${e.message}`, 'error');
      console.error('Error –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:', e);
    }
  }

  // ========== –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ì–û –ü–ï–†–ï–°–ß–ï–¢–ê ==========
  
  function scheduleAutoRecalc() {
    if (recalcTimeout) {
      clearTimeout(recalcTimeout);
    }
    
    recalcTimeout = setTimeout(() => {
      calculateVessel();
      recalcTimeout = null;
    }, 500);
  }
  
  function initParamsUI() {
    const container = document.getElementById('paramsContainer');
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ—Å—á–µ—Ç–∞ –≤ –Ω–∞—á–∞–ª–æ
    const autoRecalcRow = document.createElement('div');
    autoRecalcRow.className = 'param-row';
    autoRecalcRow.innerHTML = `
      <div class="param-symbol">üîÑ</div>
      <div class="param-name">Auto-recalculate</div>
      <div style="display: flex; align-items: center; gap: 10px;">
        <label class="switch">
          <input type="checkbox" id="autoRecalcToggle">
          <span class="slider round"></span>
        </label>
        <span id="autoRecalcStatus" style="font-size: 13px; color: #7f8c8d;">Off</span>
      </div>
    `;
    container.appendChild(autoRecalcRow);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    inputParams.forEach((p) => {
      const row = document.createElement('div');
      row.className = 'param-row';
      row.id = `row_${p.key}`;
      row.innerHTML = `
        <div class="param-symbol">${p.symbol}</div>
        <div class="param-name">${p.name}</div>
        <input type="number" class="param-value" id="value_${p.key}" step="${p.step}" placeholder="‚Äî">
        <div class="param-unit">${p.unit || ''}</div>
      `;
      container.appendChild(row);

      const sliderContainer = document.createElement('div');
      sliderContainer.className = 'slider-container';
      sliderContainer.innerHTML = `
        <div class="slider-row">
          <span class="slider-value" id="sliderVal_${p.key}">‚Äî</span>
          <input type="range" class="param-slider" id="slider_${p.key}" min="0" max="100" step="1">
        </div>
      `;
      container.appendChild(sliderContainer);

      const inputEl = row.querySelector(`#value_${p.key}`);
      const sliderEl = sliderContainer.querySelector(`#slider_${p.key}`);
      const sliderValEl = sliderContainer.querySelector(`#sliderVal_${p.key}`);

      let initial;
      if (p.key === 'A') {
        initial = 22;
      } else if (p.key === 'delta') {
        initial = 0.01 + Math.random() * (0.05 - 0.01);
        initial = Math.round(initial / 0.01) * 0.01;
      } else if (p.key === 'gamma') {
        initial = 1 + Math.floor(Math.random() * 8);
      } else if (['phi_S', 'phi_F', 'alpha_S', 'alpha_F'].includes(p.key)) {
        // –£–≥–ª—ã - —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        initial = (p.min + p.max) / 2;
      } else {
        // –õ–∏–Ω–µ–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, —É–º–Ω–æ–∂–µ–Ω–Ω—ã–µ –Ω–∞ A=22
        const normRange = ontologyRanges.all.ranges[p.key];
        if (normRange) {
          const normValue = (normRange.min + normRange.max) / 2;
          const steps = Math.round((normValue - normRange.min) / normRange.step);
          const correctedNormValue = normRange.min + steps * normRange.step;
          initial = correctedNormValue * 22; // A=22 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        } else {
          initial = (p.min + p.max) / 2;
        }
      }
      
      inputEl.value = initial.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));
      sliderEl.value = 50;
      sliderValEl.textContent = initial.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));

      inputEl.addEventListener('input', () => {
        const v = parseFloat(inputEl.value);
        if (!isNaN(v)) {
          const clamped = Math.min(Math.max(v, p.min), p.max);
          const t = (p.max === p.min) ? 50 : ((clamped - p.min) / (p.max - p.min)) * 100;
          sliderEl.value = t;
          sliderValEl.textContent = clamped.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));
        } else {
          sliderValEl.textContent = '‚Äî';
        }
        
        if (autoRecalcEnabled) {
          scheduleAutoRecalc();
        }
        
        // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ A
        if (p.key === 'A') {
          handleAChange();
        }
      });

      sliderEl.addEventListener('input', () => {
        const t = parseFloat(sliderEl.value);
        const v = p.min + (p.max - p.min) * (t / 100);
        inputEl.value = v.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));
        sliderValEl.textContent = v.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));
        
        if (autoRecalcEnabled) {
          scheduleAutoRecalc();
        }
        
        // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ A
        if (p.key === 'A') {
          handleAChange();
        }
      });
    });
    
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ—Å—á–µ—Ç–∞
    const toggle = document.getElementById('autoRecalcToggle');
    const status = document.getElementById('autoRecalcStatus');
    
    if (toggle && status) {
      toggle.addEventListener('change', function() {
        autoRecalcEnabled = this.checked;
        if (autoRecalcEnabled) {
          status.textContent = 'On';
          status.style.color = '#2ecc71';
          showStatus('Auto-recalculate –≤–∫–ª—é—á–µ–Ω', 'success');
          calculateVessel();
        } else {
          status.textContent = 'Off';
          status.style.color = '#7f8c8d';
          showStatus('Auto-recalculate –≤—ã–∫–ª—é—á–µ–Ω', 'info');
        }
        
        localStorage.setItem('vessel_autoRecalcEnabled', autoRecalcEnabled);
      });
      
      const savedAutoRecalc = localStorage.getItem('vessel_autoRecalcEnabled');
      if (savedAutoRecalc !== null) {
        autoRecalcEnabled = JSON.parse(savedAutoRecalc);
        toggle.checked = autoRecalcEnabled;
        if (autoRecalcEnabled) {
          status.textContent = 'On';
          status.style.color = '#2ecc71';
        } else {
          status.textContent = 'Off';
          status.style.color = '#7f8c8d';
        }
      }
    }
  }

  function initChart() {
    const ctx = document.getElementById('vesselChart').getContext('2d');
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [
          { label: '–ë–∞–∑–æ–≤—ã–π —ç–ª–ª–∏–ø—Å', data: [], borderColor: '#000000', borderWidth: 1, borderDash: [3,3], fill: false, pointRadius: 0, tension: 0 },
          { label: '–û—Å—å y', data: [], borderColor: '#000000', borderWidth: 1, borderDash: [6,4,1,4], fill: false, pointRadius: 0, tension: 0 },
          { label: '–û—Å—å x', data: [], borderColor: '#000000', borderWidth: 1, borderDash: [6,4,1,4], fill: false, pointRadius: 0, tension: 0 },
          { label: '–ö–æ–Ω—Ç—É—Ä —Å–æ—Å—É–¥–∞', data: [], borderColor: '#000000', borderWidth: 2, fill: false, pointRadius: 0, tension: 0.2 },
          { label: '–û—Å–Ω–æ–≤–∞–Ω–∏–µ –Ω–∏–∂–Ω–µ–µ', data: [], borderColor: '#000000', borderWidth: 1, fill: false, pointRadius: 0, tension: 0 },
          { label: '–û—Å–Ω–æ–≤–∞–Ω–∏–µ –≤–µ—Ä—Ö–Ω–µ–µ', data: [], borderColor: '#000000', borderWidth: 3, fill: false, pointRadius: 0, tension: 0 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { type: 'linear', position: 'bottom', min: BASE_X_MIN, max: BASE_X_MAX, title: { display: true, text: 'x' } },
          y: { type: 'linear', min: BASE_Y_MIN, max: BASE_Y_MAX, title: { display: true, text: 'y' } }
        },
        plugins: { legend: { display: false } }
      }
    });

    baseYExtents = { min: BASE_Y_MIN, max: BASE_Y_MIN };
    updateAxesLines();
  }

  function updateAxesLines() {
    if (!chart) return;
    const ys = chart.options.scales.y;
    const xs = chart.options.scales.x;

    chart.data.datasets[1].data = [{ x: 0, y: ys.min }, { x: 0, y: ys.max }];
    chart.data.datasets[2].data = [{ x: xs.min, y: 0 }, { x: xs.max, y: 0 }];
    chart.update();
  }

  function initVerticalScaleControl() {
    const slider = document.getElementById('yScale');
    const label = document.getElementById('yScaleLabel');

    let saved = localStorage.getItem('vessel_yScale');
    let val = parseFloat(saved);
    if (!isFinite(val)) val = 100;

    slider.value = val;
    label.textContent = val;
    applyVerticalScale();

    slider.addEventListener('input', () => {
      label.textContent = slider.value;
      applyVerticalScale();
      localStorage.setItem('vessel_yScale', slider.value);
    });
  }

  function applyVerticalScale() {
    if (!chart) return;
    const slider = document.getElementById('yScale');
    const k = parseFloat(slider.value) / 100;
    const center = (BASE_Y_MIN + BASE_Y_MAX) / 2;
    const half = (BASE_Y_MAX - BASE_Y_MIN) / 2;
    const newHalf = half / k;
    chart.options.scales.y.min = center - newHalf;
    chart.options.scales.y.max = center + newHalf;
    updateAxesLines();
  }

  function initHorizontalScaleControl() {
    const slider = document.getElementById('xScale');
    const label = document.getElementById('xScaleLabel');

    let saved = localStorage.getItem('vessel_xScale');
    let val = parseFloat(saved);
    if (!isFinite(val)) val = 100;

    slider.value = val;
    label.textContent = val;
    applyHorizontalScale();

    slider.addEventListener('input', () => {
      label.textContent = slider.value;
      applyHorizontalScale();
      localStorage.setItem('vessel_xScale', slider.value);
    });
  }

  function applyHorizontalScale() {
    if (!chart) return;
    const slider = document.getElementById('xScale');
    const k = parseFloat(slider.value) / 100;
    const center = (BASE_X_MIN + BASE_X_MAX) / 2;
    const half = (BASE_X_MAX - BASE_X_MIN) / 2;
    const newHalf = half / k;
    chart.options.scales.x.min = center - newHalf;
    chart.options.scales.x.max = center + newHalf;
    updateAxesLines();
  }

  function drawVesselContour(params) {
    if (!chart || !params || params.A === undefined) return;
    
    const { x_L, y_G, x_G, y_F, x_F, y_S, x_S, y_T, x_T, A, B, phi_S_rad, phi_F_rad } = params;
    
    // –í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É–∂–µ –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã (A=1 –≤ –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ)
    const pointsRight = [];
    pointsRight.push({ x: 0, y: y_G });
    pointsRight.push({ x: x_L, y: y_G });
    
    if (Math.abs(x_G - x_L) > 1e-6) pointsRight.push({ x: x_G, y: y_G });
    
    const stepsCone = 10;
    for (let i = 1; i <= stepsCone; i++) {
      const t = i / stepsCone;
      const x = x_G + (x_F - x_G) * t;
      const y = y_G + (y_F - y_G) * t;
      pointsRight.push({ x, y });
    }
    
    let phiStart = phi_F_rad;
    let phiEnd = phi_S_rad;
    if (phiStart > phiEnd) { 
      const tmp = phiStart; 
      phiStart = phiEnd; 
      phiEnd = tmp; 
    }
    
    const stepsEll = 30;
    for (let i = 1; i <= stepsEll; i++) {
      const t = i / stepsEll;
      const phi = phiStart + (phiEnd - phiStart) * t;
      const x = A * Math.cos(phi);
      const y = B * Math.sin(phi);
      pointsRight.push({ x, y });
    }
    
    const stepsNeck = 10;
    for (let i = 1; i <= stepsNeck; i++) {
      const t = i / stepsNeck;
      const x = x_S + (x_T - x_S) * t;
      const y = y_S + (y_T - y_S) * t;
      pointsRight.push({ x, y });
    }
    
    const pointsLeft = pointsRight.slice().reverse().map(p => ({ x: -p.x, y: p.y }));
    const contour = pointsRight.concat(pointsLeft);
    
    // –≠–ª–ª–∏–ø—Å –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (–Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
    const ellipse = [];
    const stepsFull = 100;
    for (let i = 0; i <= stepsFull; i++) {
      const t = i / stepsFull;
      const phi = -Math.PI + 2 * Math.PI * t;
      const x = A * Math.cos(phi);
      const y = B * Math.sin(phi);
      ellipse.push({ x, y });
    }
    
    const baseOffset = 0.02;
    const baseBottom = [{ x: -x_L, y: y_G - baseOffset }, { x: x_L, y: y_G - baseOffset }];
    const baseTop = [{ x: -x_L, y: y_G }, { x: x_L, y: y_G }];
    
    chart.data.datasets[0].data = ellipse;
    chart.data.datasets[3].data = contour;
    chart.data.datasets[4].data = baseBottom;
    chart.data.datasets[5].data = baseTop;
    chart.update();
  }

  function degToRad(d) { return d * Math.PI / 180; }
  function radToDeg(r) { return r * 180 / Math.PI; }

  function readInputParams() {
    const p = {};
    const errors = [];
    inputParams.forEach(def => {
      const el = document.getElementById('value_' + def.key);
      const v = parseFloat(el.value);
      if (isNaN(v)) errors.push(`Parameter ${def.symbol} –Ω–µ –∑–∞–¥–∞–Ω –∏–ª–∏ –Ω–µ —á–∏—Å–ª–æ`);
      else p[def.key] = v;
    });
    ['A','B','delta','gamma'].forEach(k => {
      if (p[k] !== undefined && p[k] <= 0) errors.push(`Parameter ${k} –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0`);
    });
    if (p.phi_S !== undefined && p.phi_F !== undefined && p.phi_S < p.phi_F) {
      errors.push(`œÜ‚Çõ (${p.phi_S}¬∞) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å ‚â• œÜ_F (${p.phi_F}¬∞)`);
    }
    if (p.h_F !== undefined && p.h_F < 0.1) errors.push(`h_F –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚â• 0.1`);
    return { params: p, errors };
  }

  function calculateVessel() {
    const { params: p_real, errors } = readInputParams();
    const warnings = [];
    if (errors.length > 0) {
      showStatus('–û—à–∏–±–∫–∏ –≤–æ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö', 'error', errors);
      currentParams = {};
      chartParams = {};
      updateAllParamsTable();
      clearChart(true);
      return;
    }
    
    try {
      const A_real = p_real.A;
      currentAValue = A_real;
      
      const p_norm = getNormalizedParams(p_real);
      
      if (p_norm.l_S === 0) {
        p_norm.l_S = 0.1;
        warnings.push('l‚Çõ = 0 –∑–∞–º–µ–Ω–µ–Ω–∞ –Ω–∞ 0.1 –¥–ª—è —Ä–∞—Å—á—ë—Ç–æ–≤');
      }
      
      const alphaFParam = inputParams.find(d => d.key === 'alpha_F');
      if (p_norm.alpha_F < alphaFParam.min || p_norm.alpha_F > alphaFParam.max) {
        throw new Error(`Œ±_F (${p_norm.alpha_F}¬∞) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [${alphaFParam.min}¬∞, ${alphaFParam.max}¬∞]`);
      }
      
      const stepsFromMin = (p_norm.alpha_F - alphaFParam.min) / alphaFParam.step;
      if (Math.abs(stepsFromMin - Math.round(stepsFromMin)) > 0.001) {
        const steps = Math.round(stepsFromMin);
        const corrected = alphaFParam.min + steps * alphaFParam.step;
        p_norm.alpha_F = Math.max(alphaFParam.min, Math.min(alphaFParam.max, corrected));
        const el = document.getElementById('value_alpha_F');
        const slider = document.getElementById('slider_alpha_F');
        const sliderVal = document.getElementById('sliderVal_alpha_F');
        if (el) el.value = p_norm.alpha_F.toFixed(0);
        if (slider) {
          const t = ((p_norm.alpha_F - alphaFParam.min) / (alphaFParam.max - alphaFParam.min)) * 100;
          slider.value = Math.min(100, Math.max(0, t));
        }
        if (sliderVal) sliderVal.textContent = p_norm.alpha_F.toFixed(0);
        warnings.push(`Œ±_F —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω –¥–æ ${p_norm.alpha_F}¬∞ (–∫—Ä–∞—Ç–Ω–æ ${alphaFParam.step}¬∞)`);
      }
      
      const phi_S_rad = degToRad(p_norm.phi_S);
      const phi_F_rad = degToRad(p_norm.phi_F);
      const alpha_S_rad = degToRad(p_norm.alpha_S);
      const alpha_F_rad = degToRad(p_norm.alpha_F);
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —ç–ª–ª–∏–ø—Å–∞ (A_norm = 1)
      const rx = 0.5; // A_norm = 1, –ø–æ—ç—Ç–æ–º—É —Ä–∞–¥–∏—É—Å = 0.5
      const ry = 0.5 * p_norm.B; // –ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —ç–ª–ª–∏–ø—Å–∞
      
      const y_S = ry * Math.sin(phi_S_rad);
      const x_S = rx * Math.cos(phi_S_rad);
      const y_F = ry * Math.sin(phi_F_rad);
      const x_F = rx * Math.cos(phi_F_rad);
      const y_T = y_S + p_norm.l_S * Math.sin(alpha_S_rad);
      const x_T = x_S + p_norm.l_S * Math.cos(alpha_S_rad);
      const y_G = y_F - p_norm.h_F;
      const sin_aF = Math.sin(alpha_F_rad);
      if (Math.abs(sin_aF) < 1e-6) throw new Error('sin(Œ±_F) —Å–ª–∏—à–∫–æ–º –º–∞–ª');
      const cot_aF = Math.cos(alpha_F_rad) / sin_aF;
      const x_G = x_F - p_norm.h_F * cot_aF;
      
      const h_norm = y_T - y_G;
      const h_abs_norm = Math.abs(h_norm);
      
      const half_A = 0.5;
      const limit_norm = 0.6 * h_abs_norm;
      let x_L_norm;
      
      if (x_G > half_A) {
        x_L_norm = x_G;
      } else if (half_A <= limit_norm) {
        x_L_norm = half_A;
      } else {
        x_L_norm = limit_norm;
      }
      
      const S_SF_norm = Math.PI * (y_S + ry);
      const S_ST_norm = Math.PI * p_norm.l_S * (x_S + x_T);
      const S_FG_norm = (Math.PI * p_norm.h_F / Math.abs(Math.sin(alpha_F_rad))) * (x_F + x_G);
      const S_L_norm = Math.PI * x_L_norm * x_L_norm;
      const S_norm = S_SF_norm + S_ST_norm + S_FG_norm + S_L_norm;
      
      const V_SF_norm = Math.PI * (rx * rx) * Math.pow(y_S + ry, 2) * (2 * ry - y_S) / (3 * ry * ry);
      const V_ST_norm = (Math.PI / 3) * (y_T - y_S) * (x_T * x_T + x_T * x_S + x_S * x_S);
      const V_norm = V_SF_norm + V_ST_norm;
      
      const P_norm = S_norm * p_norm.delta * p_norm.gamma;
      
      // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
      const h_real = h_norm * A_real;
      const h_S_real = (y_T - y_S) * A_real;
      const d_T_real = 2 * x_T * A_real;
      const d_S_real = 2 * x_S * A_real;
      const d_F_real = 2 * x_F * A_real;
      const d_G_real = 2 * x_G * A_real;
      const d_L_real = 2 * x_L_norm * A_real;
      const V_SF_real = V_SF_norm * Math.pow(A_real, 3);
      const V_real = V_norm * Math.pow(A_real, 3);
      const P_real = P_norm * Math.pow(A_real, 2);
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
      currentParams = {};
      inputParams.forEach(def => { 
        currentParams[def.key] = p_real[def.key];
      });
      
      Object.assign(currentParams, { 
        h: h_real,
        h_S: h_S_real,
        d_T: d_T_real,
        d_S: d_S_real,
        d_F: d_F_real,
        d_G: d_G_real,
        d_L: d_L_real,
        V_SF: V_SF_real,
        V: V_real,
        P: P_real
      });
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ù–û–†–ú–ò–†–û–í–ê–ù–ù–´–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
      chartParams = {
        x_S, y_S, x_F, y_F, x_T, y_T, x_G, y_G, 
        x_L: x_L_norm,
        S_SF: S_SF_norm, S_ST: S_ST_norm, S_FG: S_FG_norm, S_L: S_L_norm, S: S_norm,
        phi_S_rad, phi_F_rad, 
        A: rx,
        B: ry
      };
      
      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      const heightEl = document.getElementById('heightText');
      const volumeEl = document.getElementById('volumeText');
      const weightEl = document.getElementById('weightText');
      
      if (heightEl) {
        heightEl.textContent = h_real.toFixed(3);
      }
      if (volumeEl) {
        volumeEl.textContent = V_real.toFixed(3);
      }
      if (weightEl) {
        weightEl.textContent = P_real.toFixed(3);
      }
      
      if (!autoRecalcEnabled) {
        showStatus('–†–∞—Å—á—ë—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω', warnings.length ? 'warning' : 'success', warnings);
      }
      updateAllParamsTable();
      drawVesselContour(chartParams);
      if (document.getElementById('debugPanel').style.display !== 'none') fillDebugPanel();
      
      // –û–±–Ω–æ–≤–ª—è–µ–º 3D –≤–∏–¥
      drawVessel3D();
      
    } catch (e) {
      showStatus('Error –≤—ã—á–∏—Å–ª–µ–Ω–∏–π: ' + e.message, 'error');
      currentParams = {};
      chartParams = {};
      updateAllParamsTable();
      clearChart(true);
    }
  }

  function clearChart(keepScale) {
    if (!chart) return;
    chart.data.datasets[0].data = [];
    chart.data.datasets[3].data = [];
    chart.data.datasets[4].data = [];
    chart.data.datasets[5].data = [];
    if (!keepScale) {
      chart.options.scales.x.min = BASE_X_MIN;
      chart.options.scales.x.max = BASE_X_MAX;
      chart.options.scales.y.min = BASE_Y_MIN;
      chart.options.scales.y.max = BASE_Y_MAX;
      baseYExtents = { min: BASE_Y_MIN, max: BASE_Y_MIN };
      const slider = document.getElementById('yScale');
      const label = document.getElementById('yScaleLabel');
      if (slider && label) {
        slider.value = 100;
        label.textContent = '100';
        localStorage.setItem('vessel_yScale', '100');
      }
      const xSlider = document.getElementById('xScale');
      const xLabel = document.getElementById('xScaleLabel');
      if (xSlider && xLabel) {
        xSlider.value = 100;
        xLabel.textContent = '100';
        localStorage.setItem('vessel_xScale', '100');
      }
    }
    updateAxesLines();
  }

  function evaluateOntologyClasses() {
    if (!currentParams || currentParams.A === undefined) return null;
    
    const params_norm = getNormalizedParams(currentParams);
    
    const res = {};
    const A_norm = params_norm.A;
    const B_norm = params_norm.B;
    const l_s_norm = params_norm.l_S;
    const phi_s = params_norm.phi_S;
    const alpha_s = params_norm.alpha_S;
    
    res.all = true;
    res.vase = (B_norm - A_norm >= 0) && (l_s_norm - A_norm/2 >= 0) && (phi_s - 60 >= 0) && (alpha_s - 60 >= 0);
    res.dish = (A_norm - B_norm >= 0) && (l_s_norm - A_norm >= 0) && (-phi_s - 50 >= 0) && (20 - alpha_s >= 0);
    res.cup = (B_norm - A_norm >= 0) && (A_norm/5 - l_s_norm >= 0) && (phi_s + 20 >= 0) && (20 - phi_s >= 0) && (20 - alpha_s >= 0);
    res.glass = (l_s_norm - (A_norm + B_norm)/2 >= 0) && ((phi_s - 70 >= 0) || (-phi_s - 40 >= 0)) && (alpha_s - 70 >= 0) && (90 - alpha_s >= 0);
    return res;
  }

  function updateOntologyPanel(showAll, hasError) {
    const div = document.getElementById('ontologyResults');
    if (hasError) {
      div.innerHTML = '<span class="bad">Cannot evaluate ontology with invalid parameters</span>';
      return;
    }
    const classes = evaluateOntologyClasses();
    if (!classes) {
      div.innerHTML = 'Enter parameters and run calculation';
      return;
    }
    let html = '';
    const names = { vase:'Vase', dish:'Dish', cup:'Cup', glass:'Glass' };
    Object.keys(names).forEach(k => {
      const ok = classes[k];
      const status = ok ? 'ok' : 'bad';
      const text = ok ? '‚úì' : '‚úó';
      html += `<div>${names[k]}: <span class="${status}">${text}</span></div>`;
    });
    if (showAll) {
      html += '<hr style="margin:5px 0;border:none;border-top:1px solid #ddd;">';
      html += `<div>All: ${classes.all ? '<span class="ok">‚úì</span>' : '<span class="bad">‚úó</span>'}</div>`;
    }
    div.innerHTML = html;
  }

  function updateAllParamsTable() {
    const tbody = document.getElementById('paramsTableBody');
    tbody.innerHTML = '';
    let idx = 0;
    
    // Input parameters
    inputParams.forEach(p => {
        let val = currentParams[p.key] !== undefined ? currentParams[p.key] : '-';
        let formatted;
        
        if (typeof val === 'number') {
            if (['phi_S', 'phi_F', 'alpha_S', 'alpha_F'].includes(p.key)) {
                formatted = val.toFixed(p.unit === '¬∞' ? 0 : (p.step < 1 ? 2 : 0));
            } else if (p.key === 'A') {
                formatted = val.toFixed(p.step < 1 ? 2 : 0);
            } else if (p.key === 'delta' || p.key === 'gamma') {
                formatted = val.toFixed(p.step < 1 ? 2 : 0);
            } else {
                formatted = val.toFixed(p.step < 1 ? 2 : 0);
            }
        } else {
            formatted = val;
        }
        
        const row = `<tr>
            <td>${++idx}</td>
            <td>${p.name}</td>
            <td>${p.symbol}</td>
            <td>Input</td>
            <td>${formatted} ${p.unit || ''}</td>
        </tr>`;
        tbody.innerHTML += row;
    });
    
    // –†–∞—Å—á—ë—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    derivedParams.forEach(p => {
        let val = currentParams[p.key] !== undefined ? currentParams[p.key] : '-';
        let formatted;
        
        if (typeof val === 'number') {
            if (['h', 'h_S', 'd_T', 'd_S', 'd_F', 'd_G', 'd_L'].includes(p.key)) {
                formatted = val.toFixed(3);
            } else if (['V_SF', 'V', 'P'].includes(p.key)) {
                formatted = val.toFixed(3);
            } else {
                formatted = val.toFixed(4);
            }
        } else {
            formatted = val;
        }
        
        const row = `<tr>
            <td>${++idx}</td>
            <td>${p.name}</td>
            <td>${p.symbol}</td>
            <td>Derived</td>
            <td>${formatted}</td>
        </tr>`;
        tbody.innerHTML += row;
    });
  }

  function toggleDebug() {
    const panel = document.getElementById('debugPanel');
    if (panel.style.display === 'none') {
      panel.style.display = 'block';
      fillDebugPanel();
    } else {
      panel.style.display = 'none';
    }
  }

  function fillDebugPanel() {
    const div = document.getElementById('debugResults');
    if (!currentParams || Object.keys(currentParams).length === 0) {
        div.innerHTML = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏. –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —Ä–∞—Å—á—ë—Ç.';
        return;
    }
    let html = '';
    const A_real = currentParams.A || currentAValue;
    
    html += `<strong>Normalized values (A=1) for plotting:</strong><br>`;
    const normKeys = ['x_S','y_S','x_F','y_F','x_T','y_T','x_G','y_G','x_L'];
    normKeys.forEach(k => {
        const v = chartParams[k];
        if (v !== undefined) {
            html += `${k} = ${v.toFixed(4)}<br>`;
        }
    });
    
    html += `<br><strong>Areas (normalized, A=1):</strong><br>`;
    const areaKeys = ['S_SF','S_ST','S_FG','S_L','S'];
    areaKeys.forEach(k => {
        const v = chartParams[k];
        if (v !== undefined) {
            html += `${k} = ${v.toFixed(4)}<br>`;
        }
    });
    
    html += `<br><strong>Real values (scaled):</strong><br>`;
    const realKeys = ['h','h_S','d_T','d_S','d_F','d_G','d_L','V_SF','V','P'];
    realKeys.forEach(k => {
        const v = currentParams[k];
        if (v !== undefined) {
            html += `${k} = ${v.toFixed(4)}<br>`;
        }
    });
    
    html += `<br><strong>Scale factor:</strong><br>`;
    html += `A_real = ${A_real}<br>`;
    
    html += `<br><strong>Input parameters (real):</strong><br>`;
    inputParams.forEach(p => {
        const v = currentParams[p.key];
        if (v !== undefined) {
            html += `${p.symbol} = ${v.toFixed(4)}<br>`;
        }
    });
    
    div.innerHTML = html;
  }

  function clearAll() {
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º A –∫ –∑–Ω–∞—á–µ–Ω–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    const A_el = document.getElementById('value_A');
    if (A_el) A_el.value = '22';
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã
    updateSliderRangesForA(22);
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    inputParams.forEach(def => {
      if (def.key === 'A') return; // A —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω
      
      const el = document.getElementById(`value_${def.key}`);
      const slider = document.getElementById(`slider_${def.key}`);
      const sliderVal = document.getElementById(`sliderVal_${def.key}`);
      
      if (el) {
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        let defaultValue;
        if (def.key === 'delta') {
          defaultValue = 0.01;
        } else if (def.key === 'gamma') {
          defaultValue = 1;
        } else if (['phi_S', 'phi_F', 'alpha_S', 'alpha_F'].includes(def.key)) {
          defaultValue = (def.min + def.max) / 2;
        } else {
          // –õ–∏–Ω–µ–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è A=22
          const normRange = ontologyRanges.all.ranges[def.key];
          if (normRange) {
            const normValue = (normRange.min + normRange.max) / 2;
            defaultValue = normValue * 22;
          } else {
            defaultValue = (def.min + def.max) / 2;
          }
        }
        
        const steps = Math.round((defaultValue - def.min) / def.step);
        defaultValue = def.min + steps * def.step;
        defaultValue = Math.max(def.min, Math.min(def.max, defaultValue));
        
        el.value = defaultValue.toFixed(def.unit === '¬∞' ? 0 : (def.step < 1 ? 2 : 0));
        
        if (slider && sliderVal) {
          const t = (def.max === def.min) ? 50 : ((defaultValue - def.min) / (def.max - def.min)) * 100;
          slider.value = Math.min(100, Math.max(0, t));
          sliderVal.textContent = defaultValue.toFixed(def.unit === '¬∞' ? 0 : (def.step < 1 ? 2 : 0));
        }
      }
    });
    
    // –û—á–∏—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    document.getElementById('heightText').innerHTML = '‚Äî';
    document.getElementById('volumeText').innerHTML = '‚Äî';
    document.getElementById('weightText').innerHTML = '‚Äî';
    document.getElementById('statusText').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö';
    
    clearChart(false);
    currentParams = {};
    chartParams = {};
    updateAllParamsTable();
    showStatus('–í—Å–µ –ø–æ–ª—è –æ—á–∏—â–µ–Ω—ã', 'info');
  }

  // ========== 3D –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø ==========
  
  function init3DCanvas() {
    canvas3D = document.getElementById('vesselCanvas3D');
    ctx3D = canvas3D.getContext('2d');
    
    canvas3D.width = canvas3D.offsetWidth;
    canvas3D.height = canvas3D.offsetHeight;
    
    load3DSettings();
    drawVessel3D();
  }
  
  function drawVessel3D() {
    if (!ctx3D || !chartParams || !chartParams.x_S) {
      drawPlaceholder();
      return;
    }
    
    const width = canvas3D.width;
    const height = canvas3D.height;
    
    ctx3D.clearRect(0, 0, width, height);
    
    // –ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ñ–æ–Ω
    const bgGradient = ctx3D.createLinearGradient(0, 0, 0, height);
    bgGradient.addColorStop(0, '#f8f9fa');
    bgGradient.addColorStop(1, '#e9ecef');
    ctx3D.fillStyle = bgGradient;
    ctx3D.fillRect(0, 0, width, height);
    
    const centerX = width / 2;
    const centerY = height / 2;
    const scale = Math.min(width, height) / 6;
    
    const radX = (rotationX * Math.PI) / 180;
    const radY = (rotationY * Math.PI) / 180;
    
    const project = (x, y, z) => {
      let x1 = x * Math.cos(radY) - z * Math.sin(radY);
      let z1 = x * Math.sin(radY) + z * Math.cos(radY);
      
      let y1 = y * Math.cos(radX) - z1 * Math.sin(radX);
      let z2 = y * Math.sin(radX) + z1 * Math.cos(radX);
      
      const perspective = 500;
      const factor = perspective / (perspective + z2 + 5);
      
      return {
        x: centerX + x1 * factor * scale,
        y: centerY - y1 * factor * scale,
        depth: z2
      };
    };
    
    // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å —Å–æ—Å—É–¥–∞
    const profile = [];
    
    profile.push({x: chartParams.x_L, y: chartParams.y_G, z: 0});
    profile.push({x: chartParams.x_G, y: chartParams.y_G, z: 0});
    profile.push({x: chartParams.x_F, y: chartParams.y_F, z: 0});
    
    const phiStart = chartParams.phi_F_rad;
    const phiEnd = chartParams.phi_S_rad;
    const stepsEll = 15;
    for (let i = 0; i <= stepsEll; i++) {
      const t = i / stepsEll;
      const phi = phiStart + (phiEnd - phiStart) * t;
      const x = chartParams.A * Math.cos(phi);
      const y = chartParams.B * Math.sin(phi);
      profile.push({x, y, z: 0});
    }
    
    profile.push({x: chartParams.x_S, y: chartParams.y_S, z: 0});
    profile.push({x: chartParams.x_T, y: chartParams.y_T, z: 0});
    
    const slices = isWireframe ? 8 : 16;
    const projectedPoints = [];
    
    for (let slice = 0; slice <= slices; slice++) {
      const angle = (slice / slices) * Math.PI * 2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      
      const slicePoints = [];
      for (let i = 0; i < profile.length; i++) {
        const point = profile[i];
        const x3d = point.x * cos;
        const z3d = point.x * sin;
        const projected = project(x3d, point.y, z3d);
        slicePoints.push(projected);
      }
      projectedPoints.push(slicePoints);
    }
    
    if (isWireframe) {
      drawWireframe();
    } else {
      drawSolidWithShadows();
    }
    
    document.getElementById('rotationInfo').textContent = 
      `–í—Ä–∞—â–µ–Ω–∏–µ: X:${rotationX}¬∞ Y:${rotationY}¬∞`;
    
    function drawWireframe() {
      ctx3D.strokeStyle = '#3498db';
      ctx3D.lineWidth = 1.5;
      ctx3D.globalAlpha = 0.8;
      
      // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–µ—Ä–∏–¥–∏–∞–Ω–æ–≤
      for (let slice = 0; slice <= slices; slice++) {
        ctx3D.beginPath();
        for (let i = 0; i < profile.length; i++) {
          const point = projectedPoints[slice][i];
          if (i === 0) {
            ctx3D.moveTo(point.x, point.y);
          } else {
            ctx3D.lineTo(point.x, point.y);
          }
        }
        ctx3D.stroke();
      }
      
      // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–∞—Ä–∞–ª–ª–µ–ª–µ–π
      for (let i = 0; i < profile.length; i += 2) {
        ctx3D.beginPath();
        for (let slice = 0; slice <= slices; slice++) {
          const point = projectedPoints[slice][i];
          if (slice === 0) {
            ctx3D.moveTo(point.x, point.y);
          } else {
            ctx3D.lineTo(point.x, point.y);
          }
        }
        const firstPoint = projectedPoints[0][i];
        ctx3D.lineTo(firstPoint.x, firstPoint.y);
        ctx3D.stroke();
      }
      
      ctx3D.globalAlpha = 1;
    }
    
    function drawSolidWithShadows() {
      // –†–∏—Å—É–µ–º –∑–∞–¥–Ω—é—é –ø–æ–ª–æ–≤–∏–Ω—É
      for (let slice = 0; slice < slices / 2; slice++) {
        for (let i = 0; i < profile.length - 1; i++) {
          const p1 = projectedPoints[slice][i];
          const p2 = projectedPoints[slice + 1][i];
          const p3 = projectedPoints[slice + 1][i + 1];
          const p4 = projectedPoints[slice][i + 1];
          
          const avgDepth = (p1.depth + p2.depth + p3.depth + p4.depth) / 4;
          const brightness = Math.max(0.3, Math.min(0.7, 0.7 - avgDepth * 0.05));
          
          ctx3D.fillStyle = `rgba(52, 152, 219, ${brightness})`;
          ctx3D.strokeStyle = `rgba(41, 128, 185, ${brightness * 0.8})`;
          ctx3D.lineWidth = 1;
          
          ctx3D.beginPath();
          ctx3D.moveTo(p1.x, p1.y);
          ctx3D.lineTo(p2.x, p2.y);
          ctx3D.lineTo(p3.x, p3.y);
          ctx3D.lineTo(p4.x, p4.y);
          ctx3D.closePath();
          ctx3D.fill();
          ctx3D.stroke();
        }
      }
      
      // –†–∏—Å—É–µ–º –ø–µ—Ä–µ–¥–Ω—é—é –ø–æ–ª–æ–≤–∏–Ω—É
      for (let slice = slices / 2; slice < slices; slice++) {
        for (let i = 0; i < profile.length - 1; i++) {
          const p1 = projectedPoints[slice][i];
          const p2 = projectedPoints[slice + 1][i];
          const p3 = projectedPoints[slice + 1][i + 1];
          const p4 = projectedPoints[slice][i + 1];
          
          const avgDepth = (p1.depth + p2.depth + p3.depth + p4.depth) / 4;
          const brightness = Math.max(0.6, Math.min(1, 1 - avgDepth * 0.05));
          
          const gradient = ctx3D.createLinearGradient(p1.x, p1.y, p3.x, p3.y);
          gradient.addColorStop(0, `rgba(52, 152, 219, ${brightness})`);
          gradient.addColorStop(1, `rgba(41, 128, 185, ${brightness * 0.7})`);
          
          ctx3D.fillStyle = gradient;
          ctx3D.strokeStyle = `rgba(31, 97, 141, ${brightness * 0.6})`;
          ctx3D.lineWidth = 1;
          
          ctx3D.beginPath();
          ctx3D.moveTo(p1.x, p1.y);
          ctx3D.lineTo(p2.x, p2.y);
          ctx3D.lineTo(p3.x, p3.y);
          ctx3D.lineTo(p4.x, p4.y);
          ctx3D.closePath();
          ctx3D.fill();
          ctx3D.stroke();
        }
      }
      
      addHighlights();
    }
    
    function addHighlights() {
      const highlightSlice = Math.floor(slices * 0.75);
      const highlightPoint = Math.floor(profile.length * 0.7);
      
      const center = projectedPoints[highlightSlice][highlightPoint];
      const radius = scale * 0.1;
      
      const highlightGradient = ctx3D.createRadialGradient(
        center.x, center.y, 0,
        center.x, center.y, radius
      );
      highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      ctx3D.fillStyle = highlightGradient;
      ctx3D.beginPath();
      ctx3D.arc(center.x, center.y, radius, 0, Math.PI * 2);
      ctx3D.fill();
      
      const shadowGradient = ctx3D.createRadialGradient(
        centerX, centerY + scale * 0.5, 0,
        centerX, centerY + scale * 0.5, scale * 0.8
      );
      shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
      shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      
      ctx3D.fillStyle = shadowGradient;
      ctx3D.beginPath();
      ctx3D.ellipse(centerX, centerY + scale * 0.5, scale * 0.6, scale * 0.3, 0, 0, Math.PI * 2);
      ctx3D.fill();
    }
  }
  
  function drawPlaceholder() {
    const width = canvas3D.width;
    const height = canvas3D.height;
    
    const bgGradient = ctx3D.createLinearGradient(0, 0, 0, height);
    bgGradient.addColorStop(0, '#f8f9fa');
    bgGradient.addColorStop(1, '#e9ecef');
    ctx3D.fillStyle = bgGradient;
    ctx3D.fillRect(0, 0, width, height);
    
    ctx3D.fillStyle = '#95a5a6';
    ctx3D.font = '16px Arial';
    ctx3D.textAlign = 'center';
    ctx3D.textBaseline = 'middle';
    ctx3D.fillText('–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –Ω–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å"', width / 2, height / 2);
    
    ctx3D.strokeStyle = '#bdc3c7';
    ctx3D.lineWidth = 2;
    ctx3D.beginPath();
    ctx3D.ellipse(width / 2, height / 2 + 20, 40, 20, 0, 0, Math.PI * 2);
    ctx3D.stroke();
    
    ctx3D.beginPath();
    ctx3D.moveTo(width / 2 - 30, height / 2 + 20);
    ctx3D.lineTo(width / 2 - 20, height / 2 - 30);
    ctx3D.lineTo(width / 2 + 20, height / 2 - 30);
    ctx3D.lineTo(width / 2 + 30, height / 2 + 20);
    ctx3D.stroke();
  }
  
  function rotateVessel(axis, angle) {
    if (axis === 'x') rotationX += angle;
    if (axis === 'y') rotationY += angle;
    
    rotationX = Math.max(-90, Math.min(90, rotationX));
    rotationY %= 360;
    
    drawVessel3D();
    save3DSettings();
  }
  
  function resetRotation() {
    rotationX = 25;
    rotationY = 45;
    drawVessel3D();
    save3DSettings();
  }
  
  function toggleWireframe() {
    isWireframe = !isWireframe;
    const toggleBtn = document.getElementById('toggleWireframe');
    const icon = document.getElementById('wireframeIcon');
    
    if (isWireframe) {
      toggleBtn.classList.add('active');
      icon.textContent = 'üî≤';
      toggleBtn.title = '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ —Å–ø–ª–æ—à–Ω–æ–π –≤–∏–¥';
    } else {
      toggleBtn.classList.remove('active');
      icon.textContent = 'üî≥';
      toggleBtn.title = '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –Ω–∞ –∫–∞—Ä–∫–∞—Å–Ω—ã–π –≤–∏–¥';
    }
    
    drawVessel3D();
    save3DSettings();
  }
  
  function toggleAutoRotate() {
    autoRotate = !autoRotate;
    const icon = document.getElementById('autoRotateIcon');
    
    if (autoRotate) {
      icon.textContent = '‚è∏';
      startAutoRotation();
    } else {
      icon.textContent = '‚ñ∂';
      stopAutoRotation();
    }
    
    save3DSettings();
  }
  
  function startAutoRotation() {
    if (animationId) return;
    
    function animate() {
      if (!autoRotate) return;
      
      rotationY += 0.5;
      rotationY %= 360;
      
      drawVessel3D();
      animationId = requestAnimationFrame(animate);
    }
    
    animate();
  }
  
  function stopAutoRotation() {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
  }
  
  // ========== –°–û–•–†–ê–ù–ï–ù–ò–ï –ù–ê–°–¢–†–û–ï–ö 3D ==========
  
  function save3DSettings() {
    try {
      const settings = {
        rotationX: rotationX,
        rotationY: rotationY,
        isWireframe: isWireframe,
        autoRotate: autoRotate,
        timestamp: new Date().toISOString()
      };
      localStorage.setItem('vessel_3d_settings', JSON.stringify(settings));
    } catch (e) {
      console.error('Error —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ 3D:', e);
    }
  }
  
  function load3DSettings() {
    try {
      const saved = localStorage.getItem('vessel_3d_settings');
      if (saved) {
        const settings = JSON.parse(saved);
        rotationX = settings.rotationX || 25;
        rotationY = settings.rotationY || 45;
        isWireframe = settings.isWireframe || false;
        autoRotate = settings.autoRotate || false;
        
        const toggleBtn = document.getElementById('toggleWireframe');
        const icon = document.getElementById('wireframeIcon');
        const autoIcon = document.getElementById('autoRotateIcon');
        
        if (isWireframe) {
          if (toggleBtn) toggleBtn.classList.add('active');
          if (icon) icon.textContent = 'üî≤';
        } else {
          if (toggleBtn) toggleBtn.classList.remove('active');
          if (icon) icon.textContent = 'üî≥';
        }
        
        if (autoRotate) {
          if (autoIcon) autoIcon.textContent = '‚è∏';
          startAutoRotation();
        } else {
          if (autoIcon) autoIcon.textContent = '‚ñ∂';
          stopAutoRotation();
        }
      }
    } catch (e) {
      console.error('Error loading 3D settings:', e);
    }
  }

  // ========== –†–ï–î–ê–ö–¢–û–† –û–ù–¢–û–õ–û–ì–ò–ò ==========
  
  function applyOntologyChanges() {
    Object.keys(ontologyChanges).forEach(typeKey => {
        if (ontologyRanges[typeKey]) {
            Object.keys(ontologyChanges[typeKey]).forEach(paramId => {
                if (ontologyRanges[typeKey].ranges[paramId]) {
                    Object.keys(ontologyChanges[typeKey][paramId]).forEach(field => {
                        if (field !== 'condition') {
                            ontologyRanges[typeKey].ranges[paramId][field] = ontologyChanges[typeKey][paramId][field];
                        }
                    });
                }
            });
        }
    });
  }

  function showOntologyEditor() {
    document.getElementById('ontologyModal').style.display = 'flex';
    updateOntologyTable();
    updateSaveButtonVisibility();
  }

  function hideOntologyEditor() {
    document.getElementById('ontologyModal').style.display = 'none';
  }

  function updateOntologyTable() {
    const tbody = document.getElementById('ontologyTableBody');
    tbody.innerHTML = '';
    
    const typesOrder = ['all', 'vase', 'dish', 'cup', 'glass'];
    const paramOrder = ['A', 'B', 'l_S', 'h_F', 'phi_S', 'phi_F', 'alpha_S', 'alpha_F', 'delta', 'gamma'];
    
    const formatValue = (val, step, unit) => {
      if (val === undefined || val === null) return '‚Äî';
      let formatted;
      if (step < 0.1) formatted = val.toFixed(3);
      else if (step < 1) formatted = val.toFixed(2);
      else if (step === 1) formatted = val.toFixed(0);
      else formatted = val.toFixed(1);
      return formatted + (unit ? unit : '');
    };
    
    typesOrder.forEach(typeKey => {
      const ontology = ontologyRanges[typeKey];
      const constraints = ontologyConstraints[typeKey] || { constraints: [] };
      
      const headerRow = document.createElement('tr');
      headerRow.innerHTML = `
        <td colspan="7" class="ontology-type-header">
          <strong>${ontology.name}</strong>
        </td>
      `;
      tbody.appendChild(headerRow);
      
      paramOrder.forEach(paramId => {
        const range = ontology.ranges[paramId];
        if (!range) return;
        
        const paramInfo = [...unifiedParamConfig.common, ...unifiedParamConfig.variable].find(p => p.id === paramId);
        if (!paramInfo) return;
        
        const hasChanges = ontologyChanges[typeKey] && ontologyChanges[typeKey][paramId];
        
        let conditionText = '‚Äî';
        if (hasChanges && ontologyChanges[typeKey][paramId].condition !== undefined) {
            conditionText = `<code>${ontologyChanges[typeKey][paramId].condition}</code>`;
        } else {
            const paramConditions = constraints.constraints
                .filter(c => c.param === paramId)
                .map(c => c.desc);
            
            if (paramConditions.length > 0) {
                conditionText = paramConditions.map(desc => `<code>${desc}</code>`).join('<br>');
            } else if (paramId === 'phi_S' && typeKey === 'all') {
                conditionText = '<code>œÜ‚Çõ ‚â• œÜ_F</code>';
            } else if (paramId === 'A') {
                conditionText = '<code>Scale factor</code>';
            }
        }
        
        const row = document.createElement('tr');
        row.id = `row_${typeKey}_${paramId}`;
        row.style.backgroundColor = hasChanges ? '#fff8e1' : 'transparent';
        row.innerHTML = `
            <td class="param-name-cell">${paramInfo.name} ${hasChanges ? '‚úé' : ''}</td>
            <td class="symbol-id-cell">
                <strong>${paramInfo.symbol}</strong><br>
                <small style="color:#95a5a6;">ID: ${paramInfo.id}</small>
            </td>
            <td class="range-cell" style="${hasChanges && ontologyChanges[typeKey][paramId].min !== undefined ? 'color:#e74c3c;font-weight:bold;' : ''}">
                ${formatValue(range.min, range.step, paramInfo.unit)}
            </td>
            <td class="range-cell" style="${hasChanges && ontologyChanges[typeKey][paramId].max !== undefined ? 'color:#e74c3c;font-weight:bold;' : ''}">
                ${formatValue(range.max, range.step, paramInfo.unit)}
            </td>
            <td class="range-cell" style="${hasChanges && ontologyChanges[typeKey][paramId].step !== undefined ? 'color:#e74c3c;font-weight:bold;' : ''}">
                ${formatValue(range.step, range.step, paramInfo.unit)}
            </td>
            <td class="condition-cell" style="${hasChanges && ontologyChanges[typeKey][paramId].condition !== undefined ? 'color:#e74c3c;font-weight:bold;' : ''}">
                ${conditionText}
            </td>
            <td>
                <div style="display: flex; flex-direction: column; gap: 3px; align-items: center;">
                    <button class="edit-btn" onclick="editOntologyParam('${typeKey}', '${paramId}', 'min')" 
                            title="Edit Min" style="font-size: 10px; padding: 2px 4px;">Min</button>
                    <button class="edit-btn" onclick="editOntologyParam('${typeKey}', '${paramId}', 'max')" 
                            title="Edit Max" style="font-size: 10px; padding: 2px 4px;">Max</button>
                    <button class="edit-btn" onclick="editOntologyParam('${typeKey}', '${paramId}', 'step')" 
                            title="Edit Step" style="font-size: 10px; padding: 2px 4px;">Step</button>
                    ${paramId !== 'A' ? `<button class="edit-btn" onclick="editOntologyParam('${typeKey}', '${paramId}', 'condition')" 
                            title="Edit condition" style="font-size: 10px; padding: 2px 4px;">Cond.</button>` : ''}
                </div>
            </td>
        `;
        tbody.appendChild(row);
      });
      
      const spacer = document.createElement('tr');
      spacer.innerHTML = `<td colspan="7" style="height: 10px; background: #f5f5f5;"></td>`;
      tbody.appendChild(spacer);
    });
  }

  function editOntologyParam(typeKey, paramId, field) {
    const ontology = ontologyRanges[typeKey];
    if (!ontology || !ontology.ranges[paramId]) return;
    
    const currentValue = ontology.ranges[paramId][field];
    const paramInfo = [...unifiedParamConfig.common, ...unifiedParamConfig.variable].find(p => p.id === paramId);
    
    if (field === 'condition') {
        editOntologyCondition(typeKey, paramId);
        return;
    }
    
    const newValue = prompt(
        `Editing ${field} –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ${paramInfo.symbol} (${paramInfo.name}) –≤ —Ç–∏–ø–µ "${ontology.name}"`,
        currentValue
    );
    
    if (newValue !== null) {
        const numValue = parseFloat(newValue);
        if (!isNaN(numValue)) {
            if (!ontologyChanges[typeKey]) ontologyChanges[typeKey] = {};
            if (!ontologyChanges[typeKey][paramId]) ontologyChanges[typeKey][paramId] = {};
            ontologyChanges[typeKey][paramId][field] = numValue;
            
            ontologyRanges[typeKey].ranges[paramId][field] = numValue;
            
            updateOntologyTable();
            updateSaveButtonVisibility();
            
            showStatus(`Change saved: ${typeKey}.${paramId}.${field} = ${numValue}`, 'success');
        } else {
            showStatus('Please enter a numeric value', 'error');
        }
    }
  }

  function editOntologyCondition(typeKey, paramId) {
    const constraints = ontologyConstraints[typeKey] || { constraints: [] };
    const existingCondition = constraints.constraints.find(c => c.param === paramId);
    const currentCondition = existingCondition ? existingCondition.desc : '';
    
    const newCondition = prompt(
        `Editing —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ${paramId}\n\nExamples:\n- B ‚â• A\n- l_S ‚â• A/2\n- (œÜ‚Çõ ‚â• 70) ‚à® (œÜ‚Çõ ‚â§ -40)\n\nEnter a new condition (leave empty to remove):`,
        currentCondition
    );
    
    if (newCondition !== null) {
        if (!ontologyChanges[typeKey]) ontologyChanges[typeKey] = {};
        if (!ontologyChanges[typeKey][paramId]) ontologyChanges[typeKey][paramId] = {};
        ontologyChanges[typeKey][paramId].condition = newCondition;
        
        if (!ontologyConstraints[typeKey]) {
            ontologyConstraints[typeKey] = { constraints: [] };
        }
        
        const existingIndex = ontologyConstraints[typeKey].constraints.findIndex(c => c.param === paramId);
        if (existingIndex !== -1) {
            ontologyConstraints[typeKey].constraints.splice(existingIndex, 1);
        }
        
        if (newCondition.trim() !== '') {
            try {
                const conditionFunc = createConditionFunction(newCondition);
                ontologyConstraints[typeKey].constraints.push({
                    param: paramId,
                    condition: conditionFunc,
                    desc: newCondition
                });
            } catch (e) {
                showStatus(`Error creating condition: ${e.message}`, 'error');
                return;
            }
        }
        
        updateOntologyTable();
        updateSaveButtonVisibility();
        
        showStatus(`Condition updated –¥–ª—è ${typeKey}.${paramId}`, 'success');
    }
  }

  function createConditionFunction(conditionStr) {
    return function(params) {
        try {
            let expr = conditionStr;
            
            expr = expr.replace(/œÜ‚Çõ/g, 'phi_S');
            expr = expr.replace(/œÜ_F/g, 'phi_F');
            expr = expr.replace(/Œ±‚Çõ/g, 'alpha_S');
            expr = expr.replace(/Œ±_F/g, 'alpha_F');
            expr = expr.replace(/l‚Çõ/g, 'l_S');
            expr = expr.replace(/l_S/g, 'l_S');
            expr = expr.replace(/h_F/g, 'h_F');
            
            Object.keys(params).forEach(key => {
                const regex = new RegExp(`\\b${key}\\b`, 'g');
                expr = expr.replace(regex, params[key]);
            });
            
            expr = expr.replace(/‚â•/g, '>=');
            expr = expr.replace(/‚â§/g, '<=');
            expr = expr.replace(/‚â†/g, '!=');
            expr = expr.replace(/‚àß/g, '&&');
            expr = expr.replace(/‚à®/g, '||');
            expr = expr.replace(/¬¨/g, '!');
            
            return eval(expr);
        } catch (e) {
            console.error('Error –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —É—Å–ª–æ–≤–∏—è:', conditionStr, e);
            return false;
        }
    };
  }

  function updateSaveButtonVisibility() {
    const saveBtn = document.getElementById('saveAllBtn');
    const hasChanges = Object.keys(ontologyChanges).length > 0;
    
    if (saveBtn) {
        if (hasChanges) {
            saveBtn.style.display = 'inline-block';
            saveBtn.style.background = '#2ecc71';
            saveBtn.title = '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è';
            saveBtn.textContent = 'üíæ Save all';
        } else {
            saveBtn.style.display = 'none';
            saveBtn.title = '–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è';
        }
    }
  }

  function saveAllOntologyChanges() {
    try {
        applyOntologyChanges();
        
        localStorage.setItem('vessel_ontologyRanges', JSON.stringify(ontologyRanges));
        localStorage.setItem('vessel_ontologyConstraints', JSON.stringify(ontologyConstraints));
        
        ontologyChanges = {};
        updateSaveButtonVisibility();
        
        showStatus('–í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ!', 'success');
        
        setTimeout(() => {
            hideOntologyEditor();
        }, 1000);
        
    } catch (e) {
        showStatus('Error –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π: ' + e.message, 'error');
    }
  }

  function resetOntologyToDefaults() {
    if (confirm('–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é?')) {
        ontologyChanges = {};
        
        ontologyRanges = {
            all: {
                name: 'All vessels',
                ranges: {
                    'A': { min: 4, max: 40, step: 2 },
                    'B': { min: 0.05, max: 1.25, step: 0.05 },
                    'l_S': { min: 0.0, max: 1.25, step: 0.05 },
                    'h_F': { min: 0.05, max: 0.5, step: 0.05 },
                    'phi_S': { min: -80, max: 80, step: 5 },
                    'phi_F': { min: -80, max: 0, step: 5 },
                    'alpha_S': { min: 5, max: 90, step: 5 },
                    'alpha_F': { min: -120, max: -60, step: 5 },
                    'delta': { min: 0.01, max: 0.05, step: 0.01 },
                    'gamma': { min: 1, max: 8, step: 1 }
                }
            },
            vase: {
                name: 'Vase',
                ranges: {
                    'A': { min: 4, max: 40, step: 2 },
                    'B': { min: 0.5, max: 1.25, step: 0.05 },
                    'l_S': { min: 0.25, max: 1.25, step: 0.05 },
                    'h_F': { min: 0.05, max: 0.5, step: 0.05 },
                    'phi_S': { min: 60, max: 80, step: 5 },
                    'phi_F': { min: -80, max: 0, step: 5 },
                    'alpha_S': { min: 60, max: 90, step: 5 },
                    'alpha_F': { min: -120, max: -60, step: 5 },
                    'delta': { min: 0.01, max: 0.05, step: 0.01 },
                    'gamma': { min: 1, max: 8, step: 1 }
                }
            },
            dish: {
                name: 'Dish',
                ranges: {
                    'A': { min: 4, max: 40, step: 2 },
                    'B': { min: 0.05, max: 0.5, step: 0.05 },
                    'l_S': { min: 0.5, max: 1.25, step: 0.05 },
                    'h_F': { min: 0.05, max: 0.5, step: 0.05 },
                    'phi_S': { min: -80, max: -50, step: 5 },
                    'phi_F': { min: -80, max: 0, step: 5 },
                    'alpha_S': { min: 5, max: 20, step: 5 },
                    'alpha_F': { min: -120, max: -60, step: 5 },
                    'delta': { min: 0.01, max: 0.05, step: 0.01 },
                    'gamma': { min: 1, max: 8, step: 1 }
                }
            },
            cup: {
                name: 'Cup',
                ranges: {
                    'A': { min: 4, max: 40, step: 2 },
                    'B': { min: 0.5, max: 1.25, step: 0.05 },
                    'l_S': { min: 0.0025, max: 0.0125, step: 0.0005 },
                    'h_F': { min: 0.05, max: 0.25, step: 0.05 },
                    'phi_S': { min: -20, max: 20, step: 5 },
                    'phi_F': { min: -80, max: 0, step: 5 },
                    'alpha_S': { min: 5, max: 20, step: 5 },
                    'alpha_F': { min: -120, max: -60, step: 5 },
                    'delta': { min: 0.01, max: 0.05, step: 0.01 },
                    'gamma': { min: 1, max: 8, step: 1 }
                }
            },
            glass: {
                name: 'Glass',
                ranges: {
                    'A': { min: 4, max: 40, step: 2 },
                    'B': { min: 0.5, max: 1.25, step: 0.05 },
                    'l_S': { min: 0.5, max: 1.25, step: 0.05 },
                    'h_F': { min: 0.05, max: 0.25, step: 0.05 },
                    'phi_S': { min: -80, max: 80, step: 5 },
                    'phi_F': { min: -60, max: -20, step: 5 },
                    'alpha_S': { min: 70, max: 90, step: 5 },
                    'alpha_F': { min: -120, max: -60, step: 5 },
                    'delta': { min: 0.01, max: 0.05, step: 0.01 },
                    'gamma': { min: 1, max: 8, step: 1 }
                }
            }
        };
        
        ontologyConstraints = {
            vase: {
                name: 'Vase',
                constraints: [
                    { param: 'B', condition: (params) => params.B - params.A >= 0, desc: 'B ‚â• A' },
                    { param: 'l_S', condition: (params) => params.l_S - params.A/2 >= 0, desc: 'l‚Çõ ‚â• A/2' },
                    { param: 'phi_S', condition: (params) => params.phi_S - 60 >= 0, desc: 'œÜ‚Çõ ‚â• 60' },
                    { param: 'alpha_S', condition: (params) => params.alpha_S - 60 >= 0, desc: 'Œ±‚Çõ ‚â• 60' }
                ]
            },
            dish: {
                name: 'Dish',
                constraints: [
                    { param: 'B', condition: (params) => params.A - params.B >= 0, desc: 'B ‚â§ A' },
                    { param: 'l_S', condition: (params) => params.l_S - params.A >= 0, desc: 'l‚Çõ ‚â• A' },
                    { param: 'phi_S', condition: (params) => -params.phi_S - 50 >= 0, desc: 'œÜ‚Çõ ‚â§ -50' },
                    { param: 'alpha_S', condition: (params) => 20 - params.alpha_S >= 0, desc: 'Œ±‚Çõ ‚â§ 20' }
                ]
            },
            cup: {
                name: 'Cup',
                constraints: [
                    { param: 'B', condition: (params) => params.B - params.A >= 0, desc: 'B ‚â• A' },
                    { param: 'l_S', condition: (params) => params.A/5 - params.l_S >= 0, desc: 'l‚Çõ ‚â§ A/5' },
                    { param: 'phi_S', condition: (params) => params.phi_S + 20 >= 0, desc: 'œÜ‚Çõ ‚â• -20' },
                    { param: 'phi_S', condition: (params) => 20 - params.phi_S >= 0, desc: 'œÜ‚Çõ ‚â§ 20' },
                    { param: 'alpha_S', condition: (params) => 20 - params.alpha_S >= 0, desc: 'Œ±‚Çõ ‚â§ 20' }
                ]
            },
            glass: {
                name: 'Glass',
                constraints: [
                    { param: 'l_S', condition: (params) => params.l_S - (params.A + params.B)/2 >= 0, desc: 'l‚Çõ ‚â• (A+B)/2' },
                    { param: 'phi_S', condition: (params) => (params.phi_S - 70 >= 0) || (-params.phi_S - 40 >= 0), desc: '(œÜ‚Çõ ‚â• 70) ‚à® (œÜ‚Çõ ‚â§ -40)' },
                    { param: 'alpha_S', condition: (params) => params.alpha_S - 70 >= 0, desc: 'Œ±‚Çõ ‚â• 70' },
                    { param: 'alpha_S', condition: (params) => 90 - params.alpha_S >= 0, desc: 'Œ±‚Çõ ‚â§ 90' }
                ]
            }
        };
        
        localStorage.setItem('vessel_ontologyRanges', JSON.stringify(ontologyRanges));
        localStorage.setItem('vessel_ontologyConstraints', JSON.stringify(ontologyConstraints));
        
        updateOntologyTable();
        updateSaveButtonVisibility();
        
        showStatus('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é', 'success');
    }
  }

  function exportOntologyConfig() {
    try {
        const config = {
            ontologyRanges: ontologyRanges,
            ontologyConstraints: ontologyConstraints,
            timestamp: new Date().toISOString(),
            version: '1.0'
        };
        
        const dataStr = JSON.stringify(config, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `vessel_ontology_config_${new Date().toISOString().slice(0,10)}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showStatus('–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ', 'success');
    } catch (e) {
        showStatus('Error –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ: ' + e.message, 'error');
    }
  }

  function importOntologyConfig(file) {
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const config = JSON.parse(e.target.result);
            
            if (config.ontologyRanges) {
                ontologyRanges = config.ontologyRanges;
                if (config.ontologyConstraints) {
                    ontologyConstraints = config.ontologyConstraints;
                }
                
                ontologyChanges = {};
                
                updateOntologyTable();
                updateSaveButtonVisibility();
                
                localStorage.setItem('vessel_ontologyRanges', JSON.stringify(ontologyRanges));
                localStorage.setItem('vessel_ontologyConstraints', JSON.stringify(ontologyConstraints));
                
                showStatus('–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ', 'success');
            } else {
                showStatus('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏', 'error');
            }
        } catch (e) {
            showStatus('Error –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ: ' + e.message, 'error');
        }
    };
    
    reader.readAsText(file);
  }

  function loadSavedOntologySettings() {
    try {
        const savedRanges = localStorage.getItem('vessel_ontologyRanges');
        if (savedRanges) {
            ontologyRanges = JSON.parse(savedRanges);
        }
        
        const savedConstraints = localStorage.getItem('vessel_ontologyConstraints');
        if (savedConstraints) {
            ontologyConstraints = JSON.parse(savedConstraints);
        }
    } catch (e) {
        console.error('Error –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ–Ω—Ç–æ–ª–æ–≥–∏–∏:', e);
    }
  }

  // ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
  function init() {
    initInputParams();
    
    const savedMessagesEnabled = localStorage.getItem('vessel_messagesEnabled');
    messagesEnabled = savedMessagesEnabled !== null ? JSON.parse(savedMessagesEnabled) : true;
    
    const savedPanelCollapsed = localStorage.getItem('vessel_statusPanelCollapsed');
    const statusPanel = document.getElementById('statusPanel');
    const toggleBtn = document.getElementById('toggleMessagesBtn');
    
    if (savedPanelCollapsed === 'true') {
        statusPanel.classList.add('collapsed');
        toggleBtn.innerHTML = 'üì©';
        toggleBtn.title = '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
    } else {
        statusPanel.classList.remove('collapsed');
        toggleBtn.innerHTML = 'üì®';
        toggleBtn.title = '–°–≤–µ—Ä–Ω—É—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
    }
    
    if (messagesEnabled) {
        toggleBtn.classList.add('active');
        toggleBtn.title = '–°–∫—Ä—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
        if (statusPanel) statusPanel.style.display = 'block';
    } else {
        toggleBtn.classList.remove('active');
        toggleBtn.title = '–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è';
        if (statusPanel) statusPanel.style.display = 'none';
    }
    
    initParamsUI();
    initChart();
    initVerticalScaleControl();
    initHorizontalScaleControl();
    
    updateSliderRangesForA(22);
    
    loadSavedOntologySettings();
    
    init3DCanvas();
    
    if (messagesEnabled) {
        showStatus('–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞. –°–æ–æ–±—â–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã –≤–∫–ª—é—á–µ–Ω—ã.', 'success');
        showStatus('–î–æ–±–∞–≤–ª–µ–Ω 3D –≤–∏–¥ —Å –≤—Ä–∞—â–µ–Ω–∏–µ–º –∏ —Ç–µ–Ω—è–º–∏.', 'info');
        showStatus('–î–æ–±–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ—Å—á–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. On—é—á–∏—Ç–µ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –≤ –ø–∞–Ω–µ–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.', 'info');
    } else {
        showStatus('–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞. –°–æ–æ–±—â–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã.', 'info');
    }
    
    setTimeout(() => {
        generateRandomProblem();
    }, 500);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è DOM
    const globalToggle = document.getElementById('globalMessagesToggle');
    if (globalToggle) {
        const checkbox = globalToggle.querySelector('input');
        if (checkbox) {
            checkbox.checked = messagesEnabled;
            checkbox.addEventListener('change', toggleGlobalMessages);
        }
    }
  }

  window.addEventListener('DOMContentLoaded', init);
  
  window.addEventListener('resize', () => {
    if (canvas3D) {
      canvas3D.width = canvas3D.offsetWidth;
      canvas3D.height = canvas3D.offsetHeight;
      drawVessel3D();
    }
  });
</script>
</body>
</html>