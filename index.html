<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Triangle Solver ‚Äî Inverse Geometry Tool</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
    .container { display: flex; margin: 20px 0; gap: 20px; flex-wrap: wrap; }
    .panel { background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .visualization-panel { flex: 2; min-width: 500px; position: relative; }
    .control-panel { flex: 1; min-width: 300px; display: flex; flex-direction: column; }
    h1, h2, h3 { color: #2c3e50; margin-top: 0; }
    h1 { font-size: 24px; margin-bottom: 10px; }
    h2 { font-size: 20px; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
    .param-group { margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
    .param-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
    .param-label { min-width: 40px; font-weight: bold; color: #2c3e50; }
    select.param-select { flex: 2; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: border-color 0.3s; }
    select.param-select:focus { border-color: #3498db; outline: none; }
    input.param-value { flex: 1; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; text-align: right; min-width: 80px; }
    input.param-value:focus { border-color: #3498db; outline: none; }
    .slider-container { flex: 2; display: flex; flex-direction: column; gap: 5px; }
    .slider-row { display: flex; align-items: center; gap: 10px; }
    .slider-value { min-width: 50px; text-align: right; font-weight: bold; color: #2c3e50; font-size: 13px; }
    input.param-slider { flex: 1; height: 6px; border-radius: 3px; background: #ddd; outline: none; -webkit-appearance: none; }
    input.param-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
    input.param-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
    
    /* –ß–µ–∫–±–æ–∫—Å—ã —Ñ–∏–∫—Å–∞—Ü–∏–∏ */
    .fix-checkbox-container { display: flex; align-items: center; margin-left: 5px; }
    .fix-checkbox-label { font-size: 12px; color: #7f8c8d; margin-left: 4px; white-space: nowrap; }
    input.fix-checkbox { width: 16px; height: 16px; cursor: pointer; }
    .param-row.fixed .param-select,
    .param-row.fixed .param-value,
    .param-row.fixed .slider-value { opacity: 0.7; background-color: #f5f5f5; }
    
    .button-group { display: flex; gap: 10px; margin-top: 20px; }
    button { padding: 12px 20px; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; flex: 1; }
    #solveBtn { background: #2ecc71; color: white; }
    #solveBtn:hover { background: #27ae60; transform: translateY(-2px); }
    #solveBtn:disabled { background: #95a5a6; cursor: not-allowed; transform: none; }
    #randomBtn { background: #3498db; color: white; }
    #randomBtn:hover { background: #2980b9; transform: translateY(-2px); }
    #randomParamsBtn { background: #9b59b6; color: white; }
    #randomParamsBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #randomParamsBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
    #clearBtn { background: #e74c3c; color: white; }
    #clearBtn:hover { background: #c0392b; transform: translateY(-2px); }
    #testBtn { background: #9b59b6; color: white; flex: 0.5; }
    #testBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #validateBtn { background: #f39c12; color: white; flex: 0.5; }
    #validateBtn:hover { background: #d68910; transform: translateY(-2px); }
    #debugBtn { background: #34495e; color: white; flex: 0.5; }
    #debugBtn:hover { background: #2c3e50; transform: translateY(-2px); }
    #solveAllBtn { background: #9b59b6; color: white; flex: 0.5; }
    #solveAllBtn:hover { background: #8e44ad; transform: translateY(-2px); }
    #solveAllBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
    #checkBtn { background: #f39c12; color: white; flex: 0.5; }
    #checkBtn:hover { background: #d68910; transform: translateY(-2px); }
    #feasibilityBtn { background: #1abc9c; color: white; flex: 0.5; }
    #feasibilityBtn:hover { background: #16a085; transform: translateY(-2px); }
    .type-btn { padding: 8px 12px; font-size: 14px; flex: 0.33; }
    .progress-container { margin-top: 20px; background: #ecf0f1; border-radius: 10px; overflow: hidden; height: 20px; display: none; }
    #progressBar { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); width: 0%; transition: width 0.5s; }
    #progressText { display: block; text-align: center; margin-top: 5px; font-size: 14px; color: #7f8c8d; }
    .result-info { margin-top: 20px; padding: 15px; background: #e8f6f3; border-radius: 8px; border-left: 4px solid #1abc9c; }
    .result-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
    .result-label { font-weight: bold; color: #2c3e50; }
    .result-value { color: #16a085; font-weight: bold; }
    .result-row.angle-coords { font-size: 13px; color: #7f8c8d; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #ddd; }
    .result-row.angle-coords .result-label { color: #7f8c8d; font-weight: normal; }
    .result-row.angle-coords .result-value { color: #9b59b6; font-weight: bold; }
    .result-row.triangle-type { font-size: 13px; color: #7f8c8d; font-style: italic; }
    .table-container { margin-top: 20px; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th { background: #34495e; color: white; padding: 8px; text-align: left; position: sticky; top: 0; }
    td { padding: 6px 8px; border-bottom: 1px solid #ddd; }
    tr:nth-child(even) { background: #f8f9fa; }
    tr:hover { background: #e3f2fd; }
    td.invalid { background-color: #ffeaea; color: #e74c3c; }
    td.valid { background-color: #e8f6f3; }
    .chart-container { width: 100%; height: 500px; margin-bottom: 20px; position: relative; }
    canvas { width: 100% !important; height: 100% !important; }
    .scale-control { position: absolute; right: 20px; bottom: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 10; width: 200px; }
    .scale-control h4 { margin: 0 0 8px 0; font-size: 14px; color: #2c3e50; }
    .scale-slider { width: 100%; margin: 5px 0; }
    .scale-value { font-size: 12px; color: #7f8c8d; text-align: center; margin-top: 5px; }
    .info-box { background: #fff8e1; border-left: 4px solid #ffb300; padding: 10px 15px; margin-bottom: 15px; border-radius: 4px; font-size: 14px; }
    .error-message { color: #e74c3c; font-size: 14px; margin-top: 10px; padding: 10px; background: #ffeaea; border-radius: 6px; border-left: 4px solid #e74c3c; }
    .error-message.hidden { display: none; }
    .validation-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
    .validation-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .validation-ok { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
    .validation-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
    .validation-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
    .debug-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #34495e; }
    .debug-row { display: flex; justify-content: space-between; margin: 3px 0; font-size: 12px; font-family: monospace; }
    .debug-label { color: #2c3e50; }
    .debug-value { color: #9b59b6; font-weight: bold; }
    .solutions-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #9b59b6; }
    .solutions-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .solutions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-top: 10px; }
    .solution-thumb { background: white; border-radius: 6px; padding: 10px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; text-align: center; }
    .solution-thumb:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-color: #3498db; }
    .solution-thumb.active { border-color: #2ecc71; background: #e8f6f3; }
    .solution-thumb.mirror .thumb-title::after { content: " ü™û"; font-size: 10px; }
    .solution-thumb .thumb-title { font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #2c3e50; }
    .solution-thumb .thumb-info { font-size: 10px; color: #7f8c8d; }
    .solution-actions { display: flex; gap: 5px; margin-top: 8px; }
    .solution-btn { padding: 4px 8px; font-size: 10px; border-radius: 3px; border: none; cursor: pointer; flex: 1; }
    .view-btn { background: #3498db; color: white; }
    .animate-btn { background: #9b59b6; color: white; }
    .solution-navigation { display: flex; justify-content: center; gap: 10px; margin-top: 15px; }
    .nav-btn { padding: 6px 12px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; background: #34495e; color: white; }
    .nav-btn:hover { background: #2c3e50; }
    .solution-indicator { display: inline-block; margin-left: 10px; font-size: 14px; color: #9b59b6; font-weight: bold; }
    .compatibility-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
    .compatibility-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .status-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
    .status-message { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
    .status-info { background: #d1ecf1; color: #0c5460; border-left: 3px solid #17a2b8; }
    .status-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
    .status-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
    .status-success { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
    .floating-message { 
      position: fixed; 
      top: 20px; 
      right: 20px; 
      padding: 15px; 
      border-radius: 8px; 
      color: white; 
      font-weight: bold; 
      z-index: 1000; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
      animation: fadeIn 0.3s; 
      max-width: 400px; 
      max-height: 300px; 
      overflow-y: auto; 
      line-height: 1.4; 
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 900px) {
      .container { flex-direction: column; }
      .visualization-panel, .control-panel { min-width: 100%; }
      .scale-control { position: relative; right: auto; bottom: auto; width: 100%; margin-top: 10px; }
      .solutions-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
      .param-row { flex-wrap: wrap; }
      .fix-checkbox-container { margin-left: auto; }
    }
  </style>
</head>
<body>
  <h1>üî∫ Triangle Solver ‚Äî Inverse Geometry Calculator</h1>
  <div class="info-box">
    <strong>–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞:</strong> –¢–µ–ø–µ—Ä—å –≤–∫–ª—é—á–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏, —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ –∞–¥–∞–ø—Ç–∏–≤–Ω—É—é –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é.
    <span id="allSolutionsInfo" style="display: none; color: #9b59b6; margin-left: 10px;">
      | –ù–∞–π–¥–µ–Ω–æ —Ä–µ—à–µ–Ω–∏–π: <span id="solutionsCount">0</span>
    </span>
  </div>
  
  <div class="container">
    <div class="panel visualization-panel">
      <h2>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ 
        <span id="solutionIndicator" class="solution-indicator"></span>
      </h2>
      <div class="chart-container">
        <canvas id="triangleChart"></canvas>
        <div class="scale-control">
          <h4 style="margin: 0 0 8px 0;">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±:</h4>
          <input type="range" class="scale-slider" id="yScale" min="40" max="200" step="10">
          <div class="scale-value">
            –ú–∞—Å—à—Ç–∞–±: <span id="yScaleLabel" class="percent"></span>%
          </div>
        </div>
      </div>
      <div class="result-info">
        <div class="result-row">
          <span class="result-label">–°—Ç–∞—Ç—É—Å:</span>
          <span id="statusText" class="result-value">–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö</span>
        </div>
        <div class="result-row">
          <span class="result-label">–¢–æ—á–Ω–æ—Å—Ç—å:</span>
          <span id="accuracyText" class="result-value">-</span>
        </div>
        <div class="result-row">
          <span class="result-label">–ò—Ç–µ—Ä–∞—Ü–∏–π:</span>
          <span id="iterationsText" class="result-value">0</span>
        </div>
        <div class="result-row">
          <span class="result-label">–ú–∞—Å—à—Ç–∞–± (R):</span>
          <span id="scaleText" class="result-value">1.00</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª A (Œ±):</span>
          <span id="angleAText" class="result-value">-</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª B (Œ≤):</span>
          <span id="angleBText" class="result-value">-</span>
        </div>
        <div class="result-row angle-coords">
          <span class="result-label">–£–≥–æ–ª C (Œ≥):</span>
          <span id="angleCText" class="result-value">-</span>
        </div>
        <div class="result-row triangle-type">
          <span class="result-label">–¢–∏–ø:</span>
          <span id="triangleTypeText" class="result-value">-</span>
        </div>
      </div>
      
      <div id="statusPanel" class="status-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–°—Ç–∞—Ç—É—Å –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</h4>
        <div id="statusMessages"></div>
      </div>
      
      <div id="debugPanel" class="debug-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–û—Ç–ª–∞–¥–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</h4>
        <div id="debugResults"></div>
      </div>
    </div>
    
    <div class="panel control-panel">
      <h2>–ó–∞–¥–∞–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h2>
      
      <div class="param-group">
        <div class="param-row" id="paramRow1">
          <div class="param-label">1.</div>
          <select class="param-select" id="param1">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value1" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam1" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam1" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer1" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue1">0</span>
            <input type="range" class="param-slider" id="slider1" min="0" max="100" step="0.1">
          </div>
        </div>
        
        <div class="param-row" id="paramRow2">
          <div class="param-label">2.</div>
          <select class="param-select" id="param2">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value2" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam2" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam2" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer2" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue2">0</span>
            <input type="range" class="param-slider" id="slider2" min="0" max="100" step="0.1">
          </div>
        </div>
        
        <div class="param-row" id="paramRow3">
          <div class="param-label">3.</div>
          <select class="param-select" id="param3">
            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>
          </select>
          <input type="number" class="param-value" id="value3" step="0.001" placeholder="–∑–Ω–∞—á–µ–Ω–∏–µ">
          <div class="fix-checkbox-container">
            <input type="checkbox" class="fix-checkbox" id="fixParam3" title="–ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ">
            <label for="fixParam3" class="fix-checkbox-label">–ó–∞–∫—Ä–µ–ø–∏—Ç—å</label>
          </div>
        </div>
        <div class="slider-container" id="sliderContainer3" style="display: none;">
          <div class="slider-row">
            <span class="slider-value" id="sliderValue3">0</span>
            <input type="range" class="param-slider" id="slider3" min="0" max="100" step="0.1">
          </div>
        </div>
      </div>
      
      <div class="button-group">
        <button id="solveBtn" onclick="startSolvingEnhanced()">–†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
        <button id="randomBtn" onclick="generateRandomProblem()">–°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–∞—á–∞</button>
        <button id="randomParamsBtn" onclick="randomizeNonFixedParameters()" disabled>–°–ª—É—á–∞–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</button>
        <button id="clearBtn" onclick="clearAll()">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
      
      <div class="button-group" style="margin-top: 10px;">
        <button id="solveAllBtn" onclick="findAllSolutionsEnhanced()">–í—Å–µ —Ä–µ—à–µ–Ω–∏—è</button>
        <button id="checkBtn" onclick="checkCompatibility()">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å</button>
        <button id="feasibilityBtn" onclick="checkPracticalFeasibilityUI()">–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞</button>
        <button id="testBtn" onclick="testAndDisplayFormulas()">–¢–µ—Å—Ç —Ñ–æ—Ä–º—É–ª</button>
        <button id="validateBtn" onclick="validateCurrentTriangleEnhanced()">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="debugBtn" onclick="debugCoordinates()">–û—Ç–ª–∞–¥–∫–∞</button>
      </div>
      
      <div class="button-group" style="margin-top: 10px;">
        <button onclick="generateTriangleByType('equilateral')" class="type-btn" style="background: #2ecc71;">
          –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π
        </button>
        <button onclick="generateTriangleByType('right')" class="type-btn" style="background: #e74c3c;">
          –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π
        </button>
        <button onclick="generateTriangleByType('isosceles')" class="type-btn" style="background: #3498db;">
          –†–∞–≤–Ω–æ–±–µ–¥—Ä–µ–Ω–Ω—ã–π
        </button>
      </div>
      
      <div id="errorMessage" class="error-message hidden">
        <!-- –°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
      </div>
      
      <div id="statusMessagesInline" class="status-panel" style="margin-top: 20px; display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–°–æ–æ–±—â–µ–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã</h4>
        <div id="inlineStatusContent"></div>
      </div>
      
      <div class="progress-container" id="progressContainer">
        <div id="progressBar"></div>
      </div>
      <span id="progressText">–ì–æ—Ç–æ–≤–æ</span>
      
      <div id="compatibilityPanel" class="compatibility-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</h4>
        <div id="compatibilityResults"></div>
      </div>
      
      <div id="validationPanel" class="validation-panel" style="display: none;">
        <h4 style="margin-top: 0; margin-bottom: 10px;">–ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–µ–æ–º–µ—Ç—Ä–∏–∏</h4>
        <div id="validationResults"></div>
      </div>
      
      <div class="info-box" style="margin-top: 20px;">
        <strong>–ü–æ–¥—Å–∫–∞–∑–∫–∞:</strong> –í—ã–±–µ—Ä–∏—Ç–µ 3 —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∏–∑ —Å–ø–∏—Å–∫–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–∑—É–Ω–∫–∏ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤—Ä—É—á–Ω—É—é. –û—Ç–º–µ—Ç—å—Ç–µ ¬´–ó–∞–∫—Ä–µ–ø–∏—Ç—å¬ª –¥–ª—è —Ñ–∏–∫—Å–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞. –ù–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å" –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞.
      </div>
    </div>
  </div>
  
  <div id="solutionsPanel" class="solutions-panel" style="display: none;">
    <div class="solutions-header">
      <h3 style="margin: 0;">–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è (<span id="solutionsCountDisplay">0</span>)</h3>
      <div>
        <button onclick="showPreviousSolution()" class="nav-btn">‚óÄ –ü—Ä–µ–¥—ã–¥—É—â–µ–µ</button>
        <button onclick="showNextSolution()" class="nav-btn">–°–ª–µ–¥—É—é—â–µ–µ ‚ñ∂</button>
        <button onclick="closeSolutionsPanel()" class="nav-btn" style="background: #e74c3c;">‚úï –ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
    <div class="info-box" style="margin: 10px 0; padding: 8px; font-size: 13px;">
      <strong>–í—Å–µ —Ä–µ—à–µ–Ω–∏—è –∫–æ–Ω–≥—Ä—É—ç–Ω—Ç–Ω—ã –∏–ª–∏ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã.</strong> –°–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–º–µ—á–µ–Ω—ã ü™û. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –º–∏–Ω–∏–∞—Ç—é—Ä—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞.
    </div>
    <div id="solutionsGrid" class="solutions-grid"></div>
    <div class="solution-navigation">
      <button onclick="showSolution(0)" class="nav-btn">–ü–µ—Ä–≤–æ–µ</button>
      <button onclick="showSolution(allSolutions.length-1)" class="nav-btn">–ü–æ—Å–ª–µ–¥–Ω–µ–µ</button>
    </div>
  </div>
  
  <div class="panel" style="margin-top: 20px;">
    <h2>–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞</h2>
    <div class="table-container">
      <table id="allParamsTable">
        <thead>
          <tr>
            <th>‚Ññ</th>
            <th>–ù–∞–∑–≤–∞–Ω–∏–µ</th>
            <th>–û–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ</th>
            <th>–ó–Ω–∞—á–µ–Ω–∏–µ</th>
            <th>–ü—Ä–æ–≤–µ—Ä–∫–∞</th>
          </tr>
        </thead>
        <tbody id="paramsTableBody">
        </tbody>
      </table>
    </div>
  </div>

  <script>
    let allParameters = [];
    let selectedParameters = {};
    let currentSolution = null;
    let chart = null;
    let allSolutions = [];
    let currentSolutionIndex = 0;
    let isFindingAll = false;
    let currentStatusMessages = [];
    
    const paramRanges = {
      'sideAB': { min: 0.1, max: 5.0, step: 0.01 },
      'sideBC': { min: 0.1, max: 5.0, step: 0.01 },
      'sideAC': { min: 0.1, max: 5.0, step: 0.01 },
      'angleA': { min: 10, max: 170, step: 0.1 },
      'angleB': { min: 10, max: 170, step: 0.1 },
      'angleC': { min: 10, max: 170, step: 0.1 },
      'altitudeA': { min: 0.05, max: 5.0, step: 0.01 },
      'altitudeB': { min: 0.05, max: 5.0, step: 0.01 },
      'altitudeC': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorA': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorB': { min: 0.05, max: 5.0, step: 0.01 },
      'bisectorC': { min: 0.05, max: 5.0, step: 0.01 },
      'medianA': { min: 0.05, max: 5.0, step: 0.01 },
      'medianB': { min: 0.05, max: 5.0, step: 0.01 },
      'medianC': { min: 0.05, max: 5.0, step: 0.01 },
      'inradius': { min: 0.01, max: 2.5, step: 0.01 },
      'area': { min: 0.01, max: 6.25, step: 0.01 },
      'circumradius': { min: 0.5, max: 5.0, step: 0.01 }
    };
    
    document.addEventListener('DOMContentLoaded', function() {
      initParameters();
      initChart();
      setupEventListeners();
      initVerticalScaleControl();
      document.getElementById('solveAllBtn').disabled = true;
      setupFixCheckboxes();
      setupEnhancedEventListeners();
    });
    
    function initParameters() {
      allParameters = [
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ AB', designation: 'c', key: 'sideAB' },
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ BC', designation: 'a', key: 'sideBC' },
        { name: '–°—Ç–æ—Ä–æ–Ω–∞ AC', designation: 'b', key: 'sideAC' },
        { name: '–£–≥–æ–ª A', designation: 'Œ±', key: 'angleA' },
        { name: '–£–≥–æ–ª B', designation: 'Œ≤', key: 'angleB' },
        { name: '–£–≥–æ–ª C', designation: 'Œ≥', key: 'angleC' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ A', designation: 'h‚Çê', key: 'altitudeA' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ B', designation: 'h’¢', key: 'altitudeB' },
        { name: '–í—ã—Å–æ—Ç–∞ –∏–∑ C', designation: 'hùí∏', key: 'altitudeC' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ A', designation: 'l‚Çê', key: 'bisectorA' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ B', designation: 'l’¢', key: 'bisectorB' },
        { name: '–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ C', designation: 'lùí∏', key: 'bisectorC' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ A', designation: 'm‚Çê', key: 'medianA' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ B', designation: 'm’¢', key: 'medianB' },
        { name: '–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ C', designation: 'mùí∏', key: 'medianC' },
        { name: '–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π', designation: 'r', key: 'inradius' },
        { name: '–ü–ª–æ—â–∞–¥—å', designation: 'S', key: 'area' },
        { name: '–†–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π', designation: 'R', key: 'circumradius' }
      ];
      
      fillParameterSelects();
      setupSliders();
      updateAllParamsTable();
    }
    
    function fillParameterSelects() {
      const selects = ['param1', 'param2', 'param3'];
      
      selects.forEach((selectId, index) => {
        const select = document.getElementById(selectId);
        select.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä...</option>';
        
        allParameters.forEach(param => {
          const option = document.createElement('option');
          option.value = param.key;
          option.textContent = `${param.designation} - ${param.name}`;
          select.appendChild(option);
        });
        
        select.addEventListener('change', function() {
          updateSliderForParam(index + 1, this.value);
          validateParameterSelection();
          updateRandomParamsButtonState();
          clearStatusMessages();
        });
      });
    }
    
    function setupSliders() {
      for (let i = 1; i <= 3; i++) {
        const slider = document.getElementById(`slider${i}`);
        const valueDisplay = document.getElementById(`sliderValue${i}`);
        const input = document.getElementById(`value${i}`);
        
        if (slider && valueDisplay && input) {
          slider.addEventListener('input', function() {
            const paramKey = document.getElementById(`param${i}`).value;
            if (!paramKey) return;
            
            const range = paramRanges[paramKey];
            if (!range) return;
            
            const normalizedValue = parseFloat(this.value);
            const realValue = range.min + (range.max - range.min) * (normalizedValue / 100);
            
            let displayValue;
            if (paramKey.includes('angle')) {
              displayValue = realValue.toFixed(1) + '¬∞';
              input.value = realValue.toFixed(1);
            } else {
              displayValue = realValue.toFixed(3);
              input.value = realValue.toFixed(3);
            }
            
            valueDisplay.textContent = displayValue;
            validateParameterSelection();
            clearStatusMessages();
          });
          
          input.addEventListener('input', function() {
            const paramKey = document.getElementById(`param${i}`).value;
            if (!paramKey) return;
            
            const range = paramRanges[paramKey];
            if (!range) return;
            
            const inputValue = parseFloat(this.value);
            if (isNaN(inputValue)) return;
            
            const clampedValue = Math.max(range.min, Math.min(range.max, inputValue));
            
            if (Math.abs(inputValue - clampedValue) > 0.001) {
              this.value = clampedValue.toFixed(paramKey.includes('angle') ? 1 : 3);
            }
            
            const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
            
            slider.value = normalizedValue;
            
            let displayValue;
            if (paramKey.includes('angle')) {
              displayValue = clampedValue.toFixed(1) + '¬∞';
            } else {
              displayValue = clampedValue.toFixed(3);
            }
            
            valueDisplay.textContent = displayValue;
            validateParameterSelection();
            clearStatusMessages();
          });
          
          document.getElementById(`param${i}`).addEventListener('change', function() {
            updateSliderForParam(i, this.value);
            clearStatusMessages();
          });
        }
      }
    }
    
    function updateSliderForParam(paramIndex, paramKey) {
      const sliderContainer = document.getElementById(`sliderContainer${paramIndex}`);
      const slider = document.getElementById(`slider${paramIndex}`);
      const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
      const input = document.getElementById(`value${paramIndex}`);
      
      if (!paramKey) {
        sliderContainer.style.display = 'none';
        input.value = '';
        document.getElementById(`fixParam${paramIndex}`).checked = false;
        return;
      }
      
      const range = paramRanges[paramKey];
      if (!range) {
        sliderContainer.style.display = 'none';
        return;
      }
      
      sliderContainer.style.display = 'flex';
      
      let initialValue;
      if (input.value && !isNaN(parseFloat(input.value))) {
        initialValue = parseFloat(input.value);
        initialValue = Math.max(range.min, Math.min(range.max, initialValue));
      } else {
        initialValue = (range.min + range.max) / 2;
      }
      
      if (paramKey.includes('angle')) {
        input.value = initialValue.toFixed(1);
      } else {
        input.value = initialValue.toFixed(3);
      }
      
      const normalizedValue = ((initialValue - range.min) / (range.max - range.min)) * 100;
      
      slider.value = normalizedValue;
      
      let displayValue;
      if (paramKey.includes('angle')) {
        displayValue = initialValue.toFixed(1) + '¬∞';
      } else {
        displayValue = initialValue.toFixed(3);
      }
      
      valueDisplay.textContent = displayValue;
    }
    
    function validateParameterSelection() {
      const params = [];
      const values = {};
      let isValid = true;
      
      hideErrorMessage();
      hideCompatibilityPanel();
      
      for (let i = 1; i <= 3; i++) {
        const select = document.getElementById(`param${i}`);
        const input = document.getElementById(`value${i}`);
        const paramKey = select.value;
        const value = parseFloat(input.value);
        
        if (paramKey && !isNaN(value)) {
          if (params.includes(paramKey)) {
            isValid = false;
            showErrorMessage(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(paramKey)} –≤—ã–±—Ä–∞–Ω –¥–≤–∞–∂–¥—ã!`, true);
            break;
          }
          
          if (!validateParameterValue(paramKey, value)) {
            isValid = false;
            break;
          }
          
          params.push(paramKey);
          values[paramKey] = value;
        } else if (paramKey || input.value) {
          isValid = false;
        }
      }
      
      if (params.length === 3) {
        selectedParameters = values;
        document.getElementById('solveBtn').disabled = false;
        document.getElementById('solveAllBtn').disabled = false;
        document.getElementById('statusText').textContent = '–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å—á—ë—Ç—É';
        document.getElementById('statusText').style.color = '#2ecc71';
      } else {
        selectedParameters = {};
        document.getElementById('solveBtn').disabled = true;
        document.getElementById('solveAllBtn').disabled = true;
        document.getElementById('statusText').textContent = '–í—ã–±–µ—Ä–∏—Ç–µ 3 —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞';
        document.getElementById('statusText').style.color = '#7f8c8d';
      }
      
      updateRandomParamsButtonState();
      return isValid;
    }
    
    function validateParameterValue(paramKey, value) {
      if (paramKey.includes('angle')) {
        if (value < 10 || value > 170) {
          showErrorMessage(`–£–≥–æ–ª ${getParameterName(paramKey)} –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–∂–¥—É 10¬∞ –∏ 170¬∞!`, true);
          return false;
        }
      } else if (value <= 0) {
        showErrorMessage(`${getParameterName(paramKey)} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π!`, true);
        return false;
      }
      
      const range = paramRanges[paramKey];
      if (range) {
        if (value < range.min || value > range.max) {
          showErrorMessage(`${getParameterName(paramKey)} –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ ${range.min} - ${range.max}!`, true);
          return false;
        }
      }
      
      return true;
    }
    
    function getParameterName(key) {
      const param = allParameters.find(p => p.key === key);
      return param ? `${param.designation} (${param.name})` : key;
    }
    
    // ========== –£–°–û–í–ï–†–®–ï–ù–°–¢–í–ê–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
    function checkParameterCompatibility(params) {
        const checks = [];
        const Œµ = 1e-6;
        
        // –°–±–æ—Ä –≤—Å–µ—Ö –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        const knownSides = {
            a: params.sideBC,
            b: params.sideAC,
            c: params.sideAB
        };
        
        const knownAngles = {
            A: params.angleA,
            B: params.angleB,
            C: params.angleC
        };
        
        const knownHeights = {
            ha: params.altitudeA,
            hb: params.altitudeB,
            hc: params.altitudeC
        };
        
        const knownMedians = {
            ma: params.medianA,
            mb: params.medianB,
            mc: params.medianC
        };
        
        const knownBisectors = {
            la: params.bisectorA,
            lb: params.bisectorB,
            lc: params.bisectorC
        };
        
        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ø–æ —Ç—Ä–µ–º —Å—Ç–æ—Ä–æ–Ω–∞–º
        if (params.sideAB && params.sideBC && params.sideAC) {
            const a = params.sideBC;
            const b = params.sideAC;
            const c = params.sideAB;
            
            const triangleInequality1 = a + b > c;
            const triangleInequality2 = a + c > b;
            const triangleInequality3 = b + c > a;
            
            if (!triangleInequality1) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: a(${a.toFixed(3)}) + b(${b.toFixed(3)}) > c(${c.toFixed(3)})`
                });
            }
            if (!triangleInequality2) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: a(${a.toFixed(3)}) + c(${c.toFixed(3)}) > b(${b.toFixed(3)})`
                });
            }
            if (!triangleInequality3) {
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: b(${b.toFixed(3)}) + c(${c.toFixed(3)}) > a(${a.toFixed(3)})`
                });
            }
        }
        
        // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–º–º—ã —É–≥–ª–æ–≤
        const definedAngles = [];
        let definedAnglesSum = 0;
        const angleLetters = ['A', 'B', 'C'];
        
        angleLetters.forEach(letter => {
            const angle = knownAngles[letter];
            if (angle !== undefined) {
                definedAngles.push(letter);
                definedAnglesSum += angle;
            }
        });
        
        if (definedAngles.length >= 2) {
            if (definedAnglesSum >= 180 - Œµ) {
                checks.push({
                    type: 'error',
                    message: `–°—É–º–º–∞ –∑–∞–¥–∞–Ω–Ω—ã—Ö —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å—Ç—Ä–æ–≥–æ –º–µ–Ω—å—à–µ 180¬∞`
                });
            }
        }
        
        if (definedAngles.length === 3) {
            const angleError = Math.abs(definedAnglesSum - 180);
            if (angleError > 1) {
                checks.push({
                    type: 'error',
                    message: `–°—É–º–º–∞ –≤—Å–µ—Ö —Ç—Ä–µ—Ö —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–∞–≤–Ω–∞ 180¬∞ (¬±1¬∞). –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: ${angleError.toFixed(2)}¬∞`
                });
            } else if (angleError > 0.1) {
                checks.push({
                    type: 'warning',
                    message: `–°—É–º–º–∞ —É–≥–ª–æ–≤ (${definedAnglesSum.toFixed(2)}¬∞) –Ω–µ–º–Ω–æ–≥–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç 180¬∞. –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: ${angleError.toFixed(2)}¬∞`
                });
            }
        }
        
        // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–æ—Ä–µ–º—ã —Å–∏–Ω—É—Å–æ–≤ –¥–ª—è –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–∞—Ä —Å—Ç–æ—Ä–æ–Ω–∞-–ø—Ä–æ—Ç–∏–≤–æ–ª–µ–∂–∞—â–∏–π —É–≥–æ–ª
        const sineLawPairs = [];
        
        if (knownSides.a && knownAngles.A) sineLawPairs.push({ side: knownSides.a, angle: knownAngles.A, ratio: null });
        if (knownSides.b && knownAngles.B) sineLawPairs.push({ side: knownSides.b, angle: knownAngles.B, ratio: null });
        if (knownSides.c && knownAngles.C) sineLawPairs.push({ side: knownSides.c, angle: knownAngles.C, ratio: null });
        
        if (sineLawPairs.length >= 2) {
            sineLawPairs.forEach(pair => {
                pair.ratio = pair.side / Math.sin(pair.angle * Math.PI / 180);
            });
            
            const ratios = sineLawPairs.map(p => p.ratio);
            const maxRatio = Math.max(...ratios);
            const minRatio = Math.min(...ratios);
            const ratioError = (maxRatio - minRatio) / ((maxRatio + minRatio) / 2);
            
            if (ratioError > 0.1) {
                const ratioStr = sineLawPairs.map(p => p.ratio.toFixed(3)).join(', ');
                checks.push({
                    type: 'error',
                    message: `–ù–∞—Ä—É—à–µ–Ω–∞ —Ç–µ–æ—Ä–µ–º–∞ —Å–∏–Ω—É—Å–æ–≤. –û—Ç–Ω–æ—à–µ–Ω–∏—è —Å—Ç–æ—Ä–æ–Ω–∞/sin(—É–≥–ª–∞) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–≤–Ω—ã. –ü–æ–ª—É—á–µ–Ω–æ: ${ratioStr}`
                });
            }
        }
        
        // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–π –≤—ã—Å–æ—Ç, –º–µ–¥–∏–∞–Ω –∏ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å
        const vertexChecks = [
            { vertex: 'A', side: 'a', height: knownHeights.ha, median: knownMedians.ma, bisector: knownBisectors.la },
            { vertex: 'B', side: 'b', height: knownHeights.hb, median: knownMedians.mb, bisector: knownBisectors.lb },
            { vertex: 'C', side: 'c', height: knownHeights.hc, median: knownMedians.mc, bisector: knownBisectors.lc }
        ];
        
        vertexChecks.forEach(check => {
            const sideKey = `side${check.vertex === 'A' ? 'BC' : check.vertex === 'B' ? 'AC' : 'AB'}`;
            const oppositeSide = params[sideKey];
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Å–æ—Ç—ã
            if (check.height && oppositeSide) {
                if (check.height > oppositeSide + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–í—ã—Å–æ—Ç–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.height.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã (${oppositeSide.toFixed(3)})`
                    });
                }
                
                // –í—ã—Å–æ—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π
                if (check.height <= 0) {
                    checks.push({
                        type: 'error',
                        message: `–í—ã—Å–æ—Ç–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.height.toFixed(3)}) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π`
                    });
                }
            }
            
            // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ú–µ–¥–∏–∞–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã
            if (check.median && check.height) {
                if (check.median < check.height - Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã (${check.height.toFixed(3)}). –í —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ –º–µ–¥–∏–∞–Ω–∞ –≤—Å–µ–≥–¥–∞ ‚â• –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã.`
                    });
                }
            }
            
            // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã
            if (check.bisector && check.height) {
                if (check.bisector < check.height - Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.vertex} (${check.bisector.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã (${check.height.toFixed(3)}). –í —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –≤—Å–µ–≥–¥–∞ ‚â• –≤—ã—Å–æ—Ç—ã –∏–∑ —Ç–æ–π –∂–µ –≤–µ—Ä—à–∏–Ω—ã.`
                    });
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –ú–µ–¥–∏–∞–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É –¥–≤—É—Ö –¥—Ä—É–≥–∏—Ö —Å—Ç–æ—Ä–æ–Ω
            if (check.median && knownSides.b && knownSides.c && check.vertex === 'A') {
                const maxMedian = 0.5 * (knownSides.b + knownSides.c);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã A (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω b –∏ c (${maxMedian.toFixed(3)})`
                    });
                }
            }
            if (check.median && knownSides.a && knownSides.c && check.vertex === 'B') {
                const maxMedian = 0.5 * (knownSides.a + knownSides.c);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã B (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω a –∏ c (${maxMedian.toFixed(3)})`
                });
                }
            }
            if (check.median && knownSides.a && knownSides.b && check.vertex === 'C') {
                const maxMedian = 0.5 * (knownSides.a + knownSides.b);
                if (check.median > maxMedian + Œµ) {
                    checks.push({
                        type: 'error',
                        message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã C (${check.median.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å –ø–æ–ª—É—Å—É–º–º—É —Å—Ç–æ—Ä–æ–Ω a –∏ b (${maxMedian.toFixed(3)})`
                    });
                }
            }
        });
        
        // 5. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–¥–∏—É—Å–æ–≤ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–µ–π
        if (params.inradius && params.circumradius) {
            if (params.inradius > params.circumradius) {
                checks.push({
                    type: 'error',
                    message: `–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ (${params.inradius.toFixed(3)}) –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ —Ä–∞–¥–∏—É—Å–∞ –æ–ø–∏—Å–∞–Ω–Ω–æ–π (${params.circumradius.toFixed(3)})`
                });
            }
            
            // –î–ª—è –æ—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: R ‚â• 2r
            if (params.inradius > 0 && params.circumradius > 0) {
                if (params.circumradius < 2 * params.inradius) {
                    // –ü—Ä–æ–≤–µ—Ä–∏–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Ç—É–ø–æ—É–≥–æ–ª—å–Ω—ã–º
                    let isObtuse = false;
                    if (params.angleA > 90 || params.angleB > 90 || params.angleC > 90) {
                        isObtuse = true;
                    }
                    
                    if (!isObtuse) {
                        checks.push({
                            type: 'warning',
                            message: `–î–ª—è –æ—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ R ‚â• 2r. –£ –≤–∞—Å R=${params.circumradius.toFixed(3)}, r=${params.inradius.toFixed(3)}`
                        });
                    }
                }
            }
        }
        
        // 6. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–æ—â–∞–¥–∏
        if (params.area) {
            if (params.area <= 0) {
                checks.push({
                    type: 'error',
                    message: `–ü–ª–æ—â–∞–¥—å (${params.area.toFixed(3)}) –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π`
                });
            }
            
            // –ï—Å–ª–∏ –∑–∞–¥–∞–Ω—ã —Å—Ç–æ—Ä–æ–Ω—ã, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º—É–ª—É –ì–µ—Ä–æ–Ω–∞
            if (params.sideAB && params.sideBC && params.sideAC) {
                const a = params.sideBC;
                const b = params.sideAC;
                const c = params.sideAB;
                const p = (a + b + c) / 2;
                const heronArea = Math.sqrt(p * (p - a) * (p - b) * (p - c));
                
                if (heronArea > 0) {
                    const areaError = Math.abs(params.area - heronArea) / params.area;
                    if (areaError > 0.1) {
                        checks.push({
                            type: 'error',
                            message: `–ó–∞–¥–∞–Ω–Ω–∞—è –ø–ª–æ—â–∞–¥—å (${params.area.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–ª–æ—â–∞–¥–∏ –ø–æ —Ñ–æ—Ä–º—É–ª–µ –ì–µ—Ä–æ–Ω–∞ (${heronArea.toFixed(3)})`
                        });
                    }
                }
            }
        }
        
        // 7. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–æ—Ä–µ–º—ã –∫–æ—Å–∏–Ω—É—Å–æ–≤
        if (params.sideAB && params.sideBC && params.angleC) {
            const c = params.sideAB;
            const a = params.sideBC;
            const Œ≥ = params.angleC * Math.PI / 180;
            const b_calculated = Math.sqrt(a*a + c*c - 2*a*c*Math.cos(Œ≥));
            
            if (params.sideAC && Math.abs(params.sideAC - b_calculated) / Math.max(params.sideAC, b_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ AC (${params.sideAC.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${b_calculated.toFixed(3)}`
                });
            }
        }
        
        if (params.sideBC && params.sideAC && params.angleA) {
            const a = params.sideBC;
            const b = params.sideAC;
            const Œ± = params.angleA * Math.PI / 180;
            const c_calculated = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(Œ±));
            
            if (params.sideAB && Math.abs(params.sideAB - c_calculated) / Math.max(params.sideAB, c_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ AB (${params.sideAB.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${c_calculated.toFixed(3)}`
                });
            }
        }
        
        if (params.sideAB && params.sideAC && params.angleB) {
            const c = params.sideAB;
            const b = params.sideAC;
            const Œ≤ = params.angleB * Math.PI / 180;
            const a_calculated = Math.sqrt(b*b + c*c - 2*b*c*Math.cos(Œ≤));
            
            if (params.sideBC && Math.abs(params.sideBC - a_calculated) / Math.max(params.sideBC, a_calculated) > 0.1) {
                checks.push({
                    type: 'error',
                    message: `–°—Ç–æ—Ä–æ–Ω–∞ BC (${params.sideBC.toFixed(3)}) –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–æ—Ä–µ–º–µ –∫–æ—Å–∏–Ω—É—Å–æ–≤. –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å ‚âà ${a_calculated.toFixed(3)}`
                });
            }
        }
        
        // 8. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
        if (definedAngles.length === 3) {
            if (params.angleA < 1 || params.angleB < 1 || params.angleC < 1) {
                checks.push({
                    type: 'warning',
                    message: '–£–≥–ª—ã —Å–ª–∏—à–∫–æ–º –º–∞–ª—ã (< 1¬∞), —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π'
                });
            }
            
            if (params.angleA > 179 || params.angleB > 179 || params.angleC > 179) {
                checks.push({
                    type: 'warning',
                    message: '–£–≥–ª—ã —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–∏ –∫ 180¬∞, —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π'
                });
            }
        }
        
        // 9. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
        if (params.circumradius && params.inradius) {
            // –î–ª—è —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞: R = 2r
            const ratio = params.circumradius / params.inradius;
            if (Math.abs(ratio - 2) < 0.01) {
                // –ü—Ä–æ–≤–µ—Ä–∏–º, –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª–∏ —ç—Ç–æ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
                if (params.angleA && params.angleB && params.angleC) {
                    const isEquilateral = Math.abs(params.angleA - 60) < 1 && 
                                         Math.abs(params.angleB - 60) < 1 && 
                                         Math.abs(params.angleC - 60) < 1;
                    if (!isEquilateral) {
                        checks.push({
                            type: 'warning',
                            message: `–û—Ç–Ω–æ—à–µ–Ω–∏–µ R/r ‚âà 2 —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–æ –¥–ª—è —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞, –Ω–æ –∑–∞–¥–∞–Ω–Ω—ã–µ —É–≥–ª—ã –Ω–µ —Ä–∞–≤–Ω—ã 60¬∞`
                        });
                    }
                }
            }
        }
        
        // 10. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã–µ" –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –≤—ã—Å–æ—Ç
        if (knownHeights.ha && knownHeights.hb && knownHeights.hc) {
            // –î–ª—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–æ–ª–∂–Ω—ã –≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞:
            // 1/h‚Çê + 1/h’¢ > 1/hùí∏ –∏ —Ç.–¥.
            const invSumAB = 1/knownHeights.ha + 1/knownHeights.hb;
            const invC = 1/knownHeights.hc;
            
            if (invSumAB <= invC + Œµ) {
                checks.push({
                    type: 'error',
                    message: `–ù–µ–≤—ã–ø–æ–ª–Ω–∏–º–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –≤—ã—Å–æ—Ç: 1/h‚Çê + 1/h’¢ > 1/hùí∏ –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è`
                });
            }
        }
        
        return {
            passed: !checks.some(c => c.type === 'error'),
            warnings: checks.filter(c => c.type === 'warning'),
            errors: checks.filter(c => c.type === 'error'),
            allChecks: checks
        };
    }
    
    // ========== –ü–†–û–í–ï–†–ö–ê –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ô –†–ï–ê–õ–ò–ó–£–ï–ú–û–°–¢–ò ==========
    function checkPracticalFeasibility(params) {
      const Œµ = 0.1; // –ü–æ—Ä–æ–≥ —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const warnings = [];
      const errors = [];
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–µ —É–≥–ª—ã
      ['angleA', 'angleB', 'angleC'].forEach(angleKey => {
        if (params[angleKey]) {
          const angle = params[angleKey];
          if (angle < Œµ) {
            errors.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –º–∞–ª (<${Œµ}¬∞)`);
          } else if (angle > 180 - Œµ) {
            errors.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ 180¬∞`);
          } else if (angle < 1) {
            warnings.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) –æ—á–µ–Ω—å –º–∞–ª, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
          } else if (angle > 179) {
            warnings.push(`–£–≥–æ–ª ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) –æ—á–µ–Ω—å –±–ª–∏–∑–æ–∫ –∫ 180¬∞, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
          }
        }
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è
      if (params.inradius && params.circumradius) {
        const ratio = params.inradius / params.circumradius;
        if (ratio > 0.9) {
          warnings.push(`–û—Ç–Ω–æ—à–µ–Ω–∏–µ r/R (${ratio.toFixed(3)}) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ 1, —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø–æ—á—Ç–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π`);
        }
        if (ratio < 0.001) {
          warnings.push(`–û—Ç–Ω–æ—à–µ–Ω–∏–µ r/R (${ratio.toFixed(6)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ, –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–π —Å—Ç–æ—Ä–æ–Ω
      if (params.sideAB && params.sideBC && params.sideAC) {
        const sides = [params.sideBC, params.sideAC, params.sideAB];
        const maxSide = Math.max(...sides);
        const minSide = Math.min(...sides);
        const ratio = maxSide / minSide;
        
        if (ratio > 100) {
          warnings.push(`–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ (${ratio.toFixed(1)}:1), –≤–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏`);
        } else if (ratio > 50) {
          warnings.push(`–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ (${ratio.toFixed(1)}:1)`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
      Object.entries(params).forEach(([key, value]) => {
        if (value && Math.abs(value) < 1e-6 && !key.includes('angle')) {
          warnings.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —Ç–æ—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π`);
        }
        
        if (value && Math.abs(value) > 1e6) {
          warnings.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π –¥–ª—è —Ç–æ—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π`);
        }
      });
      
      return {
        feasible: errors.length === 0,
        errors: errors,
        warnings: warnings,
        allIssues: [...errors, ...warnings]
      };
    }
    
    // ========== –ê–î–ê–ü–¢–ò–í–ù–ê–Ø –°–ö–û–†–û–°–¢–¨ –û–ë–£–ß–ï–ù–ò–Ø ==========
    function adaptiveLearningRate(error, iteration, hasStagnated = false) {
      // –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
      const baseLR = 0.02;
      const minLR = 0.0001;
      const maxLR = 0.1;
      
      // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —Å–ø–∞–¥
      const decayFactor = Math.exp(-iteration / 2000);
      
      // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ –æ—à–∏–±–∫–µ
      let adaptiveFactor = 1.0;
      
      if (error > 1.0) {
        // –î–ª—è –±–æ–ª—å—à–∏—Ö –æ—à–∏–±–æ–∫ - –º–µ–¥–ª–µ–Ω–Ω–µ–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—Å—Ü–∏–ª–ª—è—Ü–∏–π
        adaptiveFactor = 0.5;
      } else if (error < 0.01) {
        // –î–ª—è –º–∞–ª—ã—Ö –æ—à–∏–±–æ–∫ - —Ç–æ—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
        adaptiveFactor = 0.2;
      } else if (error < 0.1) {
        adaptiveFactor = 0.5;
      }
      
      // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞—Å—Ç–æ–µ
      if (hasStagnated) {
        adaptiveFactor *= 0.3;
      }
      
      // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
      let lr = baseLR * decayFactor * adaptiveFactor;
      
      // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
      lr = Math.max(minLR, Math.min(maxLR, lr));
      
      return lr;
    }
    
    // ========== –ü–†–û–í–ï–†–ö–ê –ß–ò–°–õ–ï–ù–ù–û–ô –£–°–¢–û–ô–ß–ò–í–û–°–¢–ò ==========
    function checkNumericalFeasibility(params) {
      const issues = [];
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ NaN –∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          if (isNaN(value)) {
            issues.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} —Å–æ–¥–µ—Ä–∂–∏—Ç NaN`);
          }
          if (!isFinite(value)) {
            issues.push(`–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} —Å–æ–¥–µ—Ä–∂–∏—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ`);
          }
        }
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const definedAngles = [];
      let anglesSum = 0;
      
      if (params.angleA) {
        definedAngles.push('A');
        anglesSum += params.angleA;
      }
      if (params.angleB) {
        definedAngles.push('B');
        anglesSum += params.angleB;
      }
      if (params.angleC) {
        definedAngles.push('C');
        anglesSum += params.angleC;
      }
      
      if (definedAngles.length === 3) {
        const angleError = Math.abs(anglesSum - 180);
        if (angleError > 0.1) {
          issues.push(`–°—É–º–º–∞ —É–≥–ª–æ–≤ (${anglesSum.toFixed(2)}¬∞) –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç 180¬∞ (–æ—à–∏–±–∫–∞: ${angleError.toFixed(2)}¬∞)`);
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
      if (params.angleA && params.angleB && params.angleC) {
        const minAngle = Math.min(params.angleA, params.angleB, params.angleC);
        const maxAngle = Math.max(params.angleA, params.angleB, params.angleC);
        
        if (minAngle < 0.1) {
          issues.push(`–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª (${minAngle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`);
        }
        
        if (maxAngle > 179.9) {
          issues.push(`–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É–≥–æ–ª (${maxAngle.toFixed(2)}¬∞) —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ 180¬∞`);
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ—á—Ç–∏ –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
        if (anglesSum > 179.9 && anglesSum < 180.1) {
          if (maxAngle > 179.5 || minAngle < 0.5) {
            issues.push("–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—ã—Ä–æ–∂–¥–µ–Ω–Ω—ã–π (–æ–¥–∏–Ω —É–≥–æ–ª –æ—á–µ–Ω—å –±–ª–∏–∑–æ–∫ –∫ 180¬∞)");
          }
        }
      }
      
      return {
        feasible: issues.length === 0,
        issues: issues
      };
    }
    
    // ========== –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–†–ï–î–í–ê–†–ò–¢–ï–õ–¨–ù–û–ô –ü–†–û–í–ï–†–ö–ò ==========
    function preValidateParametersEnhanced(params) {
      // –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      const compatibility = checkParameterCompatibility(params);
      
      if (!compatibility.passed) {
        const errorMessages = compatibility.errors.map(e => e.message).join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏
      const practicalCheck = checkPracticalFeasibility(params);
      if (!practicalCheck.feasible) {
        const errorMessages = practicalCheck.errors.join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Ä–µ–∞–ª–∏–∑—É–µ–º—ã –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
      const numericalCheck = checkNumericalFeasibility(params);
      if (!numericalCheck.feasible) {
        const errorMessages = numericalCheck.issues.join('\n‚Ä¢ ');
        return {
          valid: false,
          message: `–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —á–∏—Å–ª–µ–Ω–Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã:\n‚Ä¢ ${errorMessages}`
        };
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ "–∑–∞–≤–µ–¥–æ–º–æ –Ω–µ—Ä–µ—à–∞–µ–º—ã–µ" –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏
      const vertexChecks = [
        { v: 'A', h: params.altitudeA, m: params.medianA, b: params.bisectorA },
        { v: 'B', h: params.altitudeB, m: params.medianB, b: params.bisectorB },
        { v: 'C', h: params.altitudeC, m: params.medianC, b: params.bisectorC }
      ];
      
      for (const check of vertexChecks) {
        // –ï—Å–ª–∏ –º–µ–¥–∏–∞–Ω–∞ –∑–∞–¥–∞–Ω–∞ –∏ –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã
        if (check.m && check.h && check.m < check.h) {
          return {
            valid: false,
            message: `–ú–µ–¥–∏–∞–Ω–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.v} (${check.m.toFixed(3)}) –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã (${check.h.toFixed(3)}). –≠—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ.`
          };
        }
        
        // –ï—Å–ª–∏ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∑–∞–¥–∞–Ω–∞ –∏ –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã
        if (check.b && check.h && check.b < check.h) {
          return {
            valid: false,
            message: `–ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ –∏–∑ –≤–µ—Ä—à–∏–Ω—ã ${check.v} (${check.b.toFixed(3)}) –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã (${check.h.toFixed(3)}). –≠—Ç–æ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ.`
          };
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ/–º–∞–ª–µ–Ω—å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
      const maxReasonableValue = 1e6;
      const minReasonableValue = 1e-6;
      
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined) {
          if (Math.abs(value) > maxReasonableValue) {
            return {
              valid: false,
              message: `–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`
            };
          }
          
          if (Math.abs(value) < minReasonableValue && !key.includes('angle')) {
            return {
              valid: false,
              message: `–ü–∞—Ä–∞–º–µ—Ç—Ä ${getParameterName(key)} (${value.toExponential(2)}) —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è —á–∏—Å–ª–µ–Ω–Ω–æ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏`
            };
          }
        }
      }
      
      // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
      const allWarnings = [
        ...compatibility.warnings.map(w => w.message),
        ...practicalCheck.warnings,
        ...numericalCheck.issues.filter(issue => !issue.includes('–æ—à–∏–±–∫–∞') && !issue.includes('–Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã'))
      ];
      
      if (allWarnings.length > 0) {
        return {
          valid: true,
          message: '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É',
          warnings: allWarnings
        };
      }
      
      return {
        valid: true,
        message: '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É'
      };
    }
    
    // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –°–û–û–ë–©–ï–ù–ò–ô (–û–°–¢–ê–Æ–¢–°–Ø –í –ò–ù–¢–ï–†–§–ï–ô–°–ï) ==========
    function showErrorMessage(message, persist = false) {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 10px;">
          <span style="font-size: 20px; color: #e74c3c;">‚ùå</span>
          <div style="flex: 1;">
            <strong style="color: #e74c3c;">–û—à–∏–±–∫–∞:</strong>
            <div style="white-space: pre-line; margin-top: 5px;">${message}</div>
          </div>
          ${persist ? '<button onclick="hideErrorMessage()" style="background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 18px;">√ó</button>' : ''}
        </div>
      `;
      errorDiv.classList.remove('hidden');
      
      // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å—Å—è, —Å–∫—Ä—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
      if (!persist) {
        setTimeout(hideErrorMessage, 10000);
      }
    }
    
    function hideErrorMessage() {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.classList.add('hidden');
      errorDiv.innerHTML = '';
    }
    
    function showStatusMessage(message, type = 'info') {
      currentStatusMessages.push({ message, type, timestamp: Date.now() });
      updateStatusPanel();
    }
    
    function updateStatusPanel() {
      const panel = document.getElementById('statusPanel');
      const messagesDiv = document.getElementById('statusMessages');
      const inlinePanel = document.getElementById('statusMessagesInline');
      const inlineContent = document.getElementById('inlineStatusContent');
      
      if (!messagesDiv || !inlineContent) return;
      
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (—Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç)
      const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
      currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp > fiveMinutesAgo);
      
      if (currentStatusMessages.length === 0) {
        panel.style.display = 'none';
        inlinePanel.style.display = 'none';
        return;
      }
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ç–∏–ø—É (–æ—à–∏–±–∫–∏ –≤–≤–µ—Ä—Ö—É)
      currentStatusMessages.sort((a, b) => {
        const typeOrder = { 'error': 0, 'warning': 1, 'info': 2, 'success': 3 };
        return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
      });
      
      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
      messagesDiv.innerHTML = '';
      inlineContent.innerHTML = '';
      
      const icons = {
        'error': '‚ùå',
        'warning': '‚ö†Ô∏è',
        'info': '‚ÑπÔ∏è',
        'success': '‚úÖ'
      };
      
      currentStatusMessages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message status-${msg.type}`;
        
        const icon = icons[msg.type] || '‚ÑπÔ∏è';
        const timeAgo = Math.floor((Date.now() - msg.timestamp) / 1000);
        const timeText = timeAgo < 60 ? `${timeAgo} —Å–µ–∫ –Ω–∞–∑–∞–¥` : 
                        timeAgo < 3600 ? `${Math.floor(timeAgo/60)} –º–∏–Ω –Ω–∞–∑–∞–¥` : 
                        `${Math.floor(timeAgo/3600)} —á –Ω–∞–∑–∞–¥`;
        
        messageDiv.innerHTML = `
          <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 16px;">${icon}</span>
            <div style="flex: 1;">
              <div style="white-space: pre-line;">${msg.message}</div>
              <div style="font-size: 10px; color: #666; margin-top: 3px;">${timeText}</div>
            </div>
            <button onclick="removeStatusMessage(${msg.timestamp})" style="background: none; border: none; color: #666; cursor: pointer; font-size: 14px;">√ó</button>
          </div>
        `;
        
        messagesDiv.appendChild(messageDiv.cloneNode(true));
        inlineContent.appendChild(messageDiv);
      });
      
      panel.style.display = 'block';
      inlinePanel.style.display = 'block';
    }
    
    function removeStatusMessage(timestamp) {
      currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp !== timestamp);
      updateStatusPanel();
    }
    
    function clearStatusMessages() {
      currentStatusMessages = [];
      updateStatusPanel();
    }
    
    // ========== –£–õ–£–ß–®–ï–ù–ù–´–ô –û–ü–¢–ò–ú–ò–ó–ê–¢–û–† ==========
    async function optimizeTriangleWithScaleEnhanced(targetParams, progressCallback) {
      return new Promise((resolve, reject) => {
        try {
          // –ü–†–û–í–ï–†–ö–ê –ß–ò–°–õ–ï–ù–ù–û–ô –°–¢–ê–ë–ò–õ–¨–ù–û–°–¢–ò –ü–ï–†–ï–î –ù–ê–ß–ê–õ–û–ú
          const numericalCheck = checkNumericalFeasibility(targetParams);
          if (!numericalCheck.feasible) {
            reject(new Error(`–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —á–∏—Å–ª–µ–Ω–Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã:\n‚Ä¢ ${numericalCheck.issues.join('\n‚Ä¢ ')}`));
            return;
          }
          
          // –ü–†–û–í–ï–†–ö–ê –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ô –†–ï–ê–õ–ò–ó–£–ï–ú–û–°–¢–ò
          const practicalCheck = checkPracticalFeasibility(targetParams);
          if (!practicalCheck.feasible) {
            reject(new Error(`–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Ä–µ–∞–ª–∏–∑—É–µ–º—ã –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–µ:\n‚Ä¢ ${practicalCheck.errors.join('\n‚Ä¢ ')}`));
            return;
          }
          
          // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
          if (practicalCheck.warnings.length > 0) {
            practicalCheck.warnings.forEach(warning => {
              showStatusMessage(warning, 'warning');
            });
          }
          
          const MAX_ITERATIONS = 8000;
          const TARGET_ERROR = 1e-12;
          
          let bestSolution = null;
          let bestError = Infinity;
          let stagnationCounter = 0;
          let lastImprovement = 0;
          
          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∑–∞–¥–∞–Ω –ª–∏ —Ä–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
          const hasCircumradius = targetParams.circumradius !== undefined;
          
          // –ï—Å–ª–∏ –∑–∞–¥–∞–Ω —Ä–∞–¥–∏—É—Å, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±
          let initialScale = 1.0;
          if (hasCircumradius) {
            initialScale = Math.max(0.1, Math.min(10.0, targetParams.circumradius));
          }
          
          // –†–ê–ó–ù–û–û–ë–†–ê–ó–ù–´–ï –ù–ê–ß–ê–õ–¨–ù–´–ï –¢–û–ß–ö–ò –î–õ–Ø –ü–û–ò–°–ö–ê
          const initialPoints = [
            // –ë–∞–∑–æ–≤—ã–µ —Ç–æ—á–∫–∏
            {Œ±: Math.PI/3, Œ≤: Math.PI/3, scale: initialScale}, // –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π
            {Œ±: Math.PI/2, Œ≤: Math.PI/4, scale: initialScale}, // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π
            {Œ±: Math.PI*0.4, Œ≤: Math.PI*0.4, scale: initialScale}, // –û—Å—Ç—Ä–æ—É–≥–æ–ª—å–Ω—ã–π
            {Œ±: Math.PI*0.2, Œ≤: Math.PI*0.3, scale: initialScale}, // –†–∞–∑–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
            {Œ±: Math.PI*0.7, Œ≤: Math.PI*0.2, scale: initialScale}, // –¢—É–ø–æ—É–≥–æ–ª—å–Ω—ã–π
            {Œ±: Math.PI*0.1, Œ≤: Math.PI*0.1, scale: initialScale}, // –û—á–µ–Ω—å –æ—Å—Ç—Ä—ã–π
            {Œ±: Math.PI*0.8, Œ≤: Math.PI*0.1, scale: initialScale}, // –û—á–µ–Ω—å —Ç—É–ø–æ–π
            
            // –°–ª—É—á–∞–π–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
            ...Array(3).fill(0).map(() => ({
              Œ±: 0.1 + Math.random() * (Math.PI - 0.2),
              Œ≤: 0.1 + Math.random() * (Math.PI - 0.2),
              scale: initialScale * (0.5 + Math.random())
            }))
          ];
          
          let completedRuns = 0;
          let totalIterations = 0;
          
          initialPoints.forEach((initialPoint, runIndex) => {
            setTimeout(() => {
              try {
                let Œ± = initialPoint.Œ±;
                let Œ≤ = initialPoint.Œ≤;
                let scale = initialPoint.scale;
                
                let localBestError = Infinity;
                let localBestSolution = null;
                let localStagnation = 0;
                
                function optimizationStep(iteration) {
                  if (totalIterations >= MAX_ITERATIONS) {
                    completedRuns++;
                    checkAllRunsCompleted();
                    return;
                  }
                  
                  totalIterations++;
                  
                  try {
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≥–ª—ã —Å –∑–∞–ø–∞—Å–æ–º
                    Œ± = Math.max(0.005, Math.min(Math.PI - 0.01, Œ±));
                    Œ≤ = Math.max(0.005, Math.min(Math.PI - Œ± - 0.005, Œ≤));
                    
                    const Œ≥ = Math.PI - Œ± - Œ≤;
                    
                    if (Œ≥ < 0.005 || Œ≥ > Math.PI - 0.005) {
                      // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å –Ω–æ–≤–æ–π —Å–ª—É—á–∞–π–Ω–æ–π —Ç–æ—á–∫–∏
                      Œ± = 0.1 + Math.random() * (Math.PI - 0.2);
                      Œ≤ = 0.1 + Math.random() * (Math.PI - Œ± - 0.1);
                      setTimeout(() => optimizationStep(iteration), 0);
                      return;
                    }
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å —Ç–µ–∫—É—â–∏–º –º–∞—Å—à—Ç–∞–±–æ–º
                    const currentParams = calculateAllParamsFromAngles(Œ±, Œ≤, scale);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –æ—à–∏–±–∫—É
                    let error = calculateErrorWithScale(currentParams, targetParams);
                    
                    // –ï—Å–ª–∏ –∑–∞–¥–∞–Ω —Ä–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π, –¥–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –≤–µ—Å –∫ –æ—à–∏–±–∫–µ
                    if (hasCircumradius) {
                      const targetR = targetParams.circumradius;
                      const circumError = Math.abs(scale - targetR) / Math.max(0.1, targetR);
                      error += circumError * 3.0;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–ª—É—á—à–µ–Ω–∏–µ
                    if (error < localBestError) {
                      localBestError = error;
                      localBestSolution = {
                        points: calculateTrianglePoints(Œ±, Œ≤, scale),
                        params: currentParams,
                        scale: scale,
                        angles: {
                          Œ±: Œ± * 180 / Math.PI,
                          Œ≤: Œ≤ * 180 / Math.PI,
                          Œ≥: Œ≥ * 180 / Math.PI
                        },
                        type: determineTriangleType(currentParams),
                        error: error,
                        iterations: totalIterations
                      };
                      localStagnation = 0;
                      
                      // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ
                      if (error < bestError) {
                        bestError = error;
                        bestSolution = localBestSolution;
                        stagnationCounter = 0;
                        lastImprovement = totalIterations;
                      }
                    } else {
                      localStagnation++;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞—Å—Ç–æ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º –ø–æ–∏—Å–∫–µ
                    if (localStagnation > 100) {
                      completedRuns++;
                      checkAllRunsCompleted();
                      return;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∑–∞—Å—Ç–æ–π
                    if (totalIterations - lastImprovement > 1000) {
                      stagnationCounter++;
                      if (stagnationCounter > 3) {
                        completedRuns = initialPoints.length;
                        checkAllRunsCompleted();
                        return;
                      }
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    const progress = Math.min(100, (totalIterations / MAX_ITERATIONS) * 100);
                    progressCallback(progress, totalIterations, error);
                    
                    // –ö–†–ò–¢–ï–†–ò–ô –û–°–¢–ê–ù–û–í–ê
                    if (error < TARGET_ERROR) {
                      bestError = error;
                      bestSolution = localBestSolution;
                      completedRuns = initialPoints.length;
                      checkAllRunsCompleted();
                      return;
                    }
                    
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—Å—Ç–æ–π
                    const hasStagnated = localStagnation > 20;
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è
                    const currentLR = adaptiveLearningRate(error, iteration, hasStagnated);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã —Å —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–º–∏ —Ä–∞–∑–Ω–æ—Å—Ç—è–º–∏
                    const delta = 1e-6;
                    
                    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è Œ±
                    const Œ±Plus = calculateAllParamsFromAngles(Œ± + delta, Œ≤, scale);
                    const Œ±Minus = calculateAllParamsFromAngles(Œ± - delta, Œ≤, scale);
                    const errorŒ±Plus = calculateErrorWithScale(Œ±Plus, targetParams);
                    const errorŒ±Minus = calculateErrorWithScale(Œ±Minus, targetParams);
                    const gradŒ± = (errorŒ±Plus - errorŒ±Minus) / (2 * delta);
                    
                    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è Œ≤
                    const Œ≤Plus = calculateAllParamsFromAngles(Œ±, Œ≤ + delta, scale);
                    const Œ≤Minus = calculateAllParamsFromAngles(Œ±, Œ≤ - delta, scale);
                    const errorŒ≤Plus = calculateErrorWithScale(Œ≤Plus, targetParams);
                    const errorŒ≤Minus = calculateErrorWithScale(Œ≤Minus, targetParams);
                    const gradŒ≤ = (errorŒ≤Plus - errorŒ≤Minus) / (2 * delta);
                    
                    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –º–∞—Å—à—Ç–∞–±–∞
                    let gradScale = 0;
                    if (hasCircumradius) {
                      const targetR = targetParams.circumradius;
                      const scaleDiff = scale - targetR;
                      gradScale = scaleDiff / (Math.abs(targetR) + 1e-10);
                      
                      const scalePlus = calculateAllParamsFromAngles(Œ±, Œ≤, scale + delta);
                      const scaleMinus = calculateAllParamsFromAngles(Œ±, Œ≤, scale - delta);
                      const errorScalePlus = calculateErrorWithScale(scalePlus, targetParams);
                      const errorScaleMinus = calculateErrorWithScale(scaleMinus, targetParams);
                      const numericGrad = (errorScalePlus - errorScaleMinus) / (2 * delta);
                      gradScale += numericGrad * 0.5;
                    } else {
                      const scalePlus = calculateAllParamsFromAngles(Œ±, Œ≤, scale + delta);
                      const scaleMinus = calculateAllParamsFromAngles(Œ±, Œ≤, scale - delta);
                      const errorScalePlus = calculateErrorWithScale(scalePlus, targetParams);
                      const errorScaleMinus = calculateErrorWithScale(scaleMinus, targetParams);
                      gradScale = (errorScalePlus - errorScaleMinus) / (2 * delta);
                    }
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–æ–º–µ–Ω—Ç—É–º –¥–ª—è —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
                    let momentumŒ± = 0;
                    let momentumŒ≤ = 0;
                    let momentumScale = 0;
                    const momentumFactor = 0.9;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –º–æ–º–µ–Ω—Ç—É–º–æ–º
                    momentumŒ± = momentumFactor * momentumŒ± + currentLR * gradŒ±;
                    momentumŒ≤ = momentumFactor * momentumŒ≤ + currentLR * gradŒ≤;
                    momentumScale = momentumFactor * momentumScale + currentLR * gradScale;
                    
                    Œ± -= momentumŒ±;
                    Œ≤ -= momentumŒ≤;
                    scale -= momentumScale;
                    
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
                    Œ± = Math.max(0.005, Math.min(Math.PI - 0.01, Œ±));
                    Œ≤ = Math.max(0.005, Math.min(Math.PI - Œ± - 0.005, Œ≤));
                    
                    if (hasCircumradius) {
                      const targetR = targetParams.circumradius;
                      // –ú—è–≥–∫–∞—è —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è –∫ —Ü–µ–ª–µ–≤–æ–º—É —Ä–∞–¥–∏—É—Å—É
                      scale = scale * 0.9 + targetR * 0.1;
                    }
                    
                    scale = Math.max(0.001, Math.min(100.0, scale));
                    
                    // –°–ª–µ–¥—É—é—â–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è
                    setTimeout(() => optimizationStep(iteration + 1), 0);
                    
                  } catch (error) {
                    console.warn('–û—à–∏–±–∫–∞ –≤ —à–∞–≥–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:', error);
                    completedRuns++;
                    checkAllRunsCompleted();
                  }
                }
                
                optimizationStep(0);
                
              } catch (error) {
                console.warn('–û—à–∏–±–∫–∞ –≤ –∑–∞–ø—É—Å–∫–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:', error);
                completedRuns++;
                checkAllRunsCompleted();
              }
            }, runIndex * 50);
          });
          
          function checkAllRunsCompleted() {
            if (completedRuns >= initialPoints.length) {
              if (bestSolution && bestError < 0.05) {
                // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω —Ä–∞–¥–∏—É—Å
                if (hasCircumradius) {
                  const targetR = targetParams.circumradius;
                  const Œ± = bestSolution.angles.Œ± * Math.PI / 180;
                  const Œ≤ = bestSolution.angles.Œ≤ * Math.PI / 180;
                  
                  bestSolution.params = calculateAllParamsFromAngles(Œ±, Œ≤, targetR);
                  bestSolution.points = calculateTrianglePoints(Œ±, Œ≤, targetR);
                  bestSolution.scale = targetR;
                  bestSolution.error = calculateErrorWithScale(bestSolution.params, targetParams);
                }
                
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ç–æ–Ω–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞
                bestSolution = fineTuneSolution(bestSolution, targetParams);
                
                resolve(bestSolution);
              } else {
                reject(new Error(`–†–µ—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –õ—É—á—à–∞—è –æ—à–∏–±–∫–∞: ${bestError.toFixed(6)}. –í–æ–∑–º–æ–∂–Ω–æ, –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã –∏–ª–∏ —Ç—Ä–µ–±—É—é—Ç –±–æ–ª–µ–µ —Ç–æ—á–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è.`));
              }
            }
          }
          
        } catch (error) {
          reject(error);
        }
      });
    }
    
    function calculateErrorWithScale(currentParams, targetParams) {
      let totalError = 0;
      let weight = 0;
      const Œµ = 1e-10;
      
      for (const [key, targetValue] of Object.entries(targetParams)) {
        const currentValue = parseFloat(currentParams[key]);
        
        if (isNaN(currentValue)) {
          totalError += 1.0;
          weight += 1;
          continue;
        }
        
        let error;
        
        if (key.includes('angle')) {
          const diff = Math.abs(currentValue - targetValue);
          error = Math.min(diff, 360 - diff) / 180.0;
        } else if (key === 'circumradius') {
          const denominator = Math.max(Math.abs(targetValue), Œµ);
          error = Math.abs((currentValue - targetValue) / denominator);
        } else {
          const denominator = Math.max(Math.abs(targetValue), Œµ);
          error = Math.abs((currentValue - targetValue) / denominator);
        }
        
        const paramWeight = key.includes('angle') ? 2.0 : 
                           key === 'circumradius' ? 4.0 : 1.0;
        totalError += error * paramWeight;
        weight += paramWeight;
      }
      
      return weight > 0 ? totalError / weight : Infinity;
    }
    
    // ========== –§–£–ù–ö–¶–ò–Ø –¢–û–ù–ö–û–ô –ù–ê–°–¢–†–û–ô–ö–ò –†–ï–®–ï–ù–ò–Ø ==========
    function fineTuneSolution(solution, targetParams) {
      if (!solution || solution.error < 1e-6) return solution;
      
      const MAX_FINE_TUNE_ITERATIONS = 1000;
      const FINE_TUNE_LR = 0.001;
      
      let Œ± = solution.angles.Œ± * Math.PI / 180;
      let Œ≤ = solution.angles.Œ≤ * Math.PI / 180;
      let scale = solution.scale;
      
      for (let i = 0; i < MAX_FINE_TUNE_ITERATIONS; i++) {
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≥–ª—ã
        Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, Œ±));
        Œ≤ = Math.max(0.01, Math.min(Math.PI - Œ± - 0.01, Œ≤));
        
        const currentParams = calculateAllParamsFromAngles(Œ±, Œ≤, scale);
        const error = calculateErrorWithScale(currentParams, targetParams);
        
        if (error < solution.error) {
          solution = {
            points: calculateTrianglePoints(Œ±, Œ≤, scale),
            params: currentParams,
            scale: scale,
            angles: {
              Œ±: Œ± * 180 / Math.PI,
              Œ≤: Œ≤ * 180 / Math.PI,
              Œ≥: (Math.PI - Œ± - Œ≤) * 180 / Math.PI
            },
            type: determineTriangleType(currentParams),
            error: error,
            iterations: solution.iterations + i + 1
          };
        }
        
        if (error < 1e-8) break;
        
        // –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã –¥–ª—è —Ç–æ–Ω–∫–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        const delta = 1e-8;
        
        const Œ±Plus = calculateAllParamsFromAngles(Œ± + delta, Œ≤, scale);
        const Œ±Minus = calculateAllParamsFromAngles(Œ± - delta, Œ≤, scale);
        const errorŒ±Plus = calculateErrorWithScale(Œ±Plus, targetParams);
        const errorŒ±Minus = calculateErrorWithScale(Œ±Minus, targetParams);
        const gradŒ± = (errorŒ±Plus - errorŒ±Minus) / (2 * delta);
        
        const Œ≤Plus = calculateAllParamsFromAngles(Œ±, Œ≤ + delta, scale);
        const Œ≤Minus = calculateAllParamsFromAngles(Œ±, Œ≤ - delta, scale);
        const errorŒ≤Plus = calculateErrorWithScale(Œ≤Plus, targetParams);
        const errorŒ≤Minus = calculateErrorWithScale(Œ≤Minus, targetParams);
        const gradŒ≤ = (errorŒ≤Plus - errorŒ≤Minus) / (2 * delta);
        
        Œ± -= FINE_TUNE_LR * gradŒ±;
        Œ≤ -= FINE_TUNE_LR * gradŒ≤;
      }
      
      return solution;
    }
    
    // ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    function startSolvingEnhanced() {
      if (isFindingAll) return;
      closeSolutionsPanel();
      hideCompatibilityPanel();
      
      if (!validateParameterSelection()) return;
      
      // –£–°–û–í–ï–†–®–ï–ù–°–¢–í–ê–ù–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–ò
      const preCheck = preValidateParametersEnhanced(selectedParameters);
      if (!preCheck.valid) {
        showErrorMessage(preCheck.message, true);
        clearSolutionOnInvalidParams();
        return;
      }
      
      // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
      if (preCheck.warnings && preCheck.warnings.length > 0) {
        preCheck.warnings.forEach(warning => {
          showStatusMessage(warning, 'warning');
        });
      }
      
      const solveBtn = document.getElementById('solveBtn');
      solveBtn.disabled = true;
      solveBtn.textContent = '–í—ã—á–∏—Å–ª–µ–Ω–∏–µ...';
      
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const statusText = document.getElementById('statusText');
      
      progressContainer.style.display = 'block';
      progressText.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞...';
      statusText.textContent = '–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è...';
      statusText.style.color = '#f39c12';
      
      setTimeout(async () => {
        try {
          const solution = await optimizeTriangleWithScaleEnhanced(selectedParameters, (progress, iteration, error) => {
            progressBar.style.width = progress + '%';
            let status = '–ò—Ç–µ—Ä–∞—Ü–∏—è';
            if (error > 1.0) status = '–ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫';
            else if (error > 0.1) status = '–õ–æ–∫–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è';
            else status = '–¢–æ–Ω–∫–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞';
            progressText.textContent = `${status}: ${iteration}, –æ—à–∏–±–∫–∞: ${error.toFixed(6)}`;
          });
          
          displaySolution(solution);
          
        } catch (error) {
          showErrorMessage(`–û—à–∏–±–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: ${error.message}`, true);
          clearSolutionOnInvalidParams();
        } finally {
          solveBtn.disabled = false;
          solveBtn.textContent = '–†–∞—Å—Å—á–∏—Ç–∞—Ç—å';
          progressText.textContent = '–ì–æ—Ç–æ–≤–æ';
          
          setTimeout(() => {
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
          }, 2000);
        }
      }, 100);
    }
    
    function initChart() {
      const ctx = document.getElementById('triangleChart').getContext('2d');
      
      chart = new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              min: -3.5, max: 3.5,
              grid: { color: 'rgba(0,0,0,0.1)' },
              title: { display: true, text: 'x' }
            },
            y: {
              min: -3.5, max: 3.5,
              grid: { color: 'rgba(0,0,0,0.1)' },
              title: { display: true, text: 'y' }
            }
          },
          plugins: {
            legend: { 
              display: true,
              position: 'top',
              labels: { font: { size: 10 }, boxWidth: 12 }
            },
            tooltip: { enabled: true }
          }
        }
      });
      
      applyTriangleYscale();
    }
    
    let triYscale = parseFloat(localStorage.getItem("triangle_yScale") || "100");
    const triBaseYmin = -3.5;
    const triBaseYmax = 3.5;

    function applyTriangleYscale() {
      if (!chart) return;
      const k = triYscale / 100;
      chart.options.scales.y.min = triBaseYmin * k;
      chart.options.scales.y.max = triBaseYmax * k;
      chart.update();
    }

    function initVerticalScaleControl() {
      const slider = document.getElementById("yScale");
      const label = document.getElementById("yScaleLabel");
      if (!slider || !label) return;
      
      slider.value = triYscale;
      label.textContent = triYscale + "%";
      
      slider.addEventListener("input", () => {
        triYscale = parseFloat(slider.value);
        label.textContent = triYscale + "%";
        localStorage.setItem("triangle_yScale", triYscale);
        applyTriangleYscale();
      });
    }
    
    function generateCirclePoints(radius, points = 100) {
      const circlePoints = [];
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        circlePoints.push({
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)
        });
      }
      return circlePoints;
    }
    
    function setupEventListeners() {
      ['value1', 'value2', 'value3'].forEach(id => {
        const input = document.getElementById(id);
        
        input.addEventListener('keypress', function(e) {
          if (e.key === 'Enter' && !document.getElementById('solveBtn').disabled) {
            startSolvingEnhanced();
          }
        });
        
        input.addEventListener('blur', function() {
          const index = parseInt(id.replace('value', ''));
          const paramKey = document.getElementById(`param${index}`).value;
          
          if (!paramKey) return;
          
          const range = paramRanges[paramKey];
          if (!range) return;
          
          const value = parseFloat(this.value);
          if (isNaN(value)) return;
          
          const clampedValue = Math.max(range.min, Math.min(range.max, value));
          
          if (Math.abs(value - clampedValue) > 0.001) {
            if (paramKey.includes('angle')) {
              this.value = clampedValue.toFixed(1);
            } else {
              this.value = clampedValue.toFixed(3);
            }
          }
          
          updateSliderFromInput(index, this.value);
        });
      });
    }
    
    function updateSliderFromInput(paramIndex, inputValue) {
      const paramKey = document.getElementById(`param${paramIndex}`).value;
      if (!paramKey) return;
      
      const range = paramRanges[paramKey];
      if (!range) return;
      
      const value = parseFloat(inputValue);
      if (isNaN(value)) return;
      
      const clampedValue = Math.max(range.min, Math.min(range.max, value));
      
      const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
      
      const slider = document.getElementById(`slider${paramIndex}`);
      const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
      const input = document.getElementById(`value${paramIndex}`);
      
      if (slider && valueDisplay && input) {
        slider.value = normalizedValue;
        
        let displayValue;
        if (paramKey.includes('angle')) {
          displayValue = clampedValue.toFixed(1) + '¬∞';
        } else {
          displayValue = clampedValue.toFixed(3);
        }
        
        valueDisplay.textContent = displayValue;
        
        const currentInputValue = parseFloat(input.value);
        if (isNaN(currentInputValue) || Math.abs(currentInputValue - clampedValue) > 0.001) {
          if (paramKey.includes('angle')) {
            input.value = clampedValue.toFixed(1);
          } else {
            input.value = clampedValue.toFixed(3);
          }
        }
      }
    }
    
    // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –ü–ê–†–ê–ú–ï–¢–†–û–í ==========
    function calculateAllParamsFromAngles(Œ±, Œ≤, R = 1) {
      const Œ≥ = Math.PI - Œ± - Œ≤;
      
      if (!isValidTriangle(Œ±, Œ≤, Œ≥)) {
        return {
          sideBC: "0", sideAC: "0", sideAB: "0",
          angleA: "0", angleB: "0", angleC: "0",
          altitudeA: "0", altitudeB: "0", altitudeC: "0",
          bisectorA: "0", bisectorB: "0", bisectorC: "0",
          medianA: "0", medianB: "0", medianC: "0",
          circumradius: "0", inradius: "0", area: "0"
        };
      }
      
      const a = 2 * R * Math.sin(Œ±);
      const b = 2 * R * Math.sin(Œ≤);
      const c = 2 * R * Math.sin(Œ≥);
      
      const p = (a + b + c) / 2;
      const S = Math.sqrt(p * (p - a) * (p - b) * (p - c));
      
      const ha = 2 * S / a;
      const hb = 2 * S / b;
      const hc = 2 * S / c;
      
      const la = (2 * b * c * Math.cos(Œ± / 2)) / (b + c);
      const lb = (2 * a * c * Math.cos(Œ≤ / 2)) / (a + c);
      const lc = (2 * a * b * Math.cos(Œ≥ / 2)) / (a + b);
      
      const ma = 0.5 * Math.sqrt(2 * b * b + 2 * c * c - a * a);
      const mb = 0.5 * Math.sqrt(2 * a * a + 2 * c * c - b * b);
      const mc = 0.5 * Math.sqrt(2 * a * a + 2 * b * b - c * c);
      
      const r = S / p;
      
      const params = {};
      
      params.sideBC = a.toFixed(8);
      params.sideAC = b.toFixed(8);
      params.sideAB = c.toFixed(8);
      params.angleA = (Œ± * 180 / Math.PI).toFixed(8);
      params.angleB = (Œ≤ * 180 / Math.PI).toFixed(8);
      params.angleC = (Œ≥ * 180 / Math.PI).toFixed(8);
      params.altitudeA = ha.toFixed(8);
      params.altitudeB = hb.toFixed(8);
      params.altitudeC = hc.toFixed(8);
      params.bisectorA = la.toFixed(8);
      params.bisectorB = lb.toFixed(8);
      params.bisectorC = lc.toFixed(8);
      params.medianA = ma.toFixed(8);
      params.medianB = mb.toFixed(8);
      params.medianC = mc.toFixed(8);
      params.circumradius = R.toFixed(8);
      params.inradius = r.toFixed(8);
      params.area = S.toFixed(8);
      
      return params;
    }
    
    function calculateTrianglePoints(Œ±, Œ≤, R = 1) {
      const Œ≥ = Math.PI - Œ± - Œ≤;

      const A = { x: R, y: 0 };
      
      const Œ∏_B = 2 * Œ≥;
      const B = { 
        x: R * Math.cos(Œ∏_B), 
        y: R * Math.sin(Œ∏_B) 
      };
      
      const Œ∏_C = -2 * Œ≤;
      const C = { 
        x: R * Math.cos(Œ∏_C), 
        y: R * Math.sin(Œ∏_C) 
      };

      return { A, B, C };
    }
    
    function isValidTriangle(Œ±, Œ≤, Œ≥) {
      const Œµ = 1e-6;
      return (
        Œ± > Œµ && Œ≤ > Œµ && Œ≥ > Œµ &&
        Math.abs(Œ± + Œ≤ + Œ≥ - Math.PI) < Œµ
      );
    }
    
    // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ==========
    function displaySolution(solution) {
      if (!solution) return;

      const normalized = normalizeSolutionOrientation(solution);
      currentSolution = normalized;

      const statusText = document.getElementById('statusText');
      const accuracyText = document.getElementById('accuracyText');
      const iterationsText = document.getElementById('iterationsText');
      const scaleText = document.getElementById('scaleText');
      const angleAText = document.getElementById('angleAText');
      const angleBText = document.getElementById('angleBText');
      const angleCText = document.getElementById('angleCText');
      const triangleTypeText = document.getElementById('triangleTypeText');

      statusText.textContent = '–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ!';
      statusText.style.color = '#2ecc71';

      const accuracy = normalized.error ? Math.max(0, 100 - normalized.error * 100) : 100;
      accuracyText.textContent = accuracy >= 99.99 ? '>99.99%' : accuracy.toFixed(2) + '%';

      iterationsText.textContent = normalized.iterations || '0';
      scaleText.textContent = normalized.scale.toFixed(4);
      angleAText.textContent = `${normalized.angles.Œ±.toFixed(2)}¬∞`;
      angleBText.textContent = `${normalized.angles.Œ≤.toFixed(2)}¬∞`;
      angleCText.textContent = `${normalized.angles.Œ≥.toFixed(2)}¬∞`;
      triangleTypeText.textContent = getTriangleTypeName(normalized.type);

      updateChart(normalized);
      updateAllParamsTable(normalized);

      showStatusMessage(`–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é ${accuracy.toFixed(2)}%`, 'success');

      if (accuracy < 95) {
        showStatusMessage(`–†–µ—à–µ–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–æ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é ${accuracy.toFixed(2)}%`, 'warning');
      }
    }
    
    function normalizeSolutionOrientation(solution) {
      if (!solution || !solution.points) return solution;

      const points = solution.points;
      const A = points.A;
      const B = points.B;
      const C = points.C;

      if (!A || !B || !C) return solution;

      const cross = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);

      if (cross > 0) {
        return solution;
      }

      const newPoints = { A: A, B: C, C: B };

      const newAngles = solution.angles ? {
        Œ±: solution.angles.Œ±,
        Œ≤: solution.angles.Œ≥,
        Œ≥: solution.angles.Œ≤
      } : solution.angles;

      let newParams = solution.params ? { ...solution.params } : solution.params;

      if (newParams) {
        const oldSideAB = newParams.sideAB;
        const oldSideBC = newParams.sideBC;
        const oldSideAC = newParams.sideAC;

        newParams.sideAB = oldSideAC;
        newParams.sideBC = oldSideBC;
        newParams.sideAC = oldSideAB;

        if ('altitudeB' in newParams && 'altitudeC' in newParams) {
          const oldAltB = newParams.altitudeB;
          const oldAltC = newParams.altitudeC;
          newParams.altitudeB = oldAltC;
          newParams.altitudeC = oldAltB;
        }

        if ('medianB' in newParams && 'medianC' in newParams) {
          const oldMedB = newParams.medianB;
          const oldMedC = newParams.medianC;
          newParams.medianB = oldMedC;
          newParams.medianC = oldMedB;
        }

        if ('bisectorB' in newParams && 'bisectorC' in newParams) {
          const oldBisB = newParams.bisectorB;
          const oldBisC = newParams.bisectorC;
          newParams.bisectorB = oldBisC;
          newParams.bisectorC = oldBisB;
        }
      }

      return {
        ...solution,
        points: newPoints,
        angles: newAngles,
        params: newParams
      };
    }
    
    // ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –ì–†–ê–§–ò–ö–ê ==========
    function updateChart(solution) {
      if (!solution || !chart) return;
      
      const { A, B, C } = solution.points;
      const R = solution.scale;
      
      // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
      const Œ± = solution.angles.Œ± * Math.PI / 180;
      const Œ≤ = solution.angles.Œ≤ * Math.PI / 180;
      const Œ≥ = solution.angles.Œ≥ * Math.PI / 180;
      
      const a = parseFloat(solution.params.sideBC);
      const b = parseFloat(solution.params.sideAC);
      const c = parseFloat(solution.params.sideAB);
      const S = parseFloat(solution.params.area);
      
      // –¶–µ–Ω—Ç—Ä –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏
      const incenter = {
        x: (a * A.x + b * B.x + c * C.x) / (a + b + c),
        y: (a * A.y + b * B.y + c * C.y) / (a + b + c)
      };
      
      const r = parseFloat(solution.params.inradius);
      
      const unitCirclePoints = generateCirclePoints(1, 100);
      const circumCirclePoints = generateCirclePoints(R, 100);
      const inCirclePoints = generateCirclePoints(r, 100).map(p => ({
        x: p.x + incenter.x,
        y: p.y + incenter.y
      }));
      
      const datasets = [
        {
          label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: unitCirclePoints,
          borderColor: '#3498db',
          backgroundColor: 'transparent',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderDash: [5, 5],
          borderWidth: 1
        },
        {
          label: '–û–ø–∏—Å–∞–Ω–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: circumCirclePoints,
          borderColor: '#9b59b6',
          backgroundColor: 'rgba(155, 89, 182, 0.05)',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderWidth: 2
        },
        {
          label: '–í–ø–∏—Å–∞–Ω–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: inCirclePoints,
          borderColor: '#2ecc71',
          backgroundColor: 'rgba(46, 204, 113, 0.1)',
          pointRadius: 0,
          showLine: true,
          fill: true,
          borderWidth: 1.5
        },
        {
          label: '–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫',
          data: [A, B, C, A],
          borderColor: '#e74c3c',
          backgroundColor: 'rgba(231, 76, 60, 0.2)',
          pointRadius: 0,
          showLine: true,
          fill: true,
          borderWidth: 2
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ A',
          data: [A],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ B',
          data: [B],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–í–µ—Ä—à–∏–Ω–∞ C',
          data: [C],
          backgroundColor: '#e74c3c',
          pointRadius: 8,
          showLine: false,
          pointStyle: 'circle'
        },
        {
          label: '–ò–Ω—Ü–µ–Ω—Ç—Ä',
          data: [incenter],
          backgroundColor: '#2ecc71',
          pointRadius: 6,
          showLine: false,
          pointStyle: 'rect'
        }
      ];
      
      chart.data.datasets = datasets;
      
      chart.options.plugins.annotation = {
        annotations: {
          labelA: {
            type: 'label',
            xValue: A.x,
            yValue: A.y,
            content: 'A',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          },
          labelB: {
            type: 'label',
            xValue: B.x,
            yValue: B.y,
            content: 'B',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          },
          labelC: {
            type: 'label',
            xValue: C.x,
            yValue: C.y,
            content: 'C',
            font: { size: 16, weight: 'bold' },
            color: '#2c3e50',
            xAdjust: 20,
            yAdjust: 20
          }
        }
      };
      
      applyTriangleYscale();
    }
    
    // ========== –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
    function checkCompatibility() {
      if (Object.keys(selectedParameters).length === 0) {
        showStatusMessage('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã', 'warning');
        return;
      }
      
      const compatibility = checkParameterCompatibility(selectedParameters);
      const panel = document.getElementById('compatibilityPanel');
      const resultsDiv = document.getElementById('compatibilityResults');
      
      resultsDiv.innerHTML = '';
      
      if (compatibility.passed) {
        const div = document.createElement('div');
        div.className = 'compatibility-result validation-ok';
        div.innerHTML = `
          <div><strong>‚úì –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã</strong></div>
          <div>–ú–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å —Ä–∞—Å—á—ë—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞</div>
        `;
        resultsDiv.appendChild(div);
        
        if (compatibility.warnings.length > 0) {
          compatibility.warnings.forEach(warning => {
            const warnDiv = document.createElement('div');
            warnDiv.className = 'compatibility-result validation-warning';
            warnDiv.innerHTML = `
              <div><strong>‚ö† –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:</strong></div>
              <div>${warning.message}</div>
            `;
            resultsDiv.appendChild(warnDiv);
          });
        }
      } else {
        const div = document.createElement('div');
        div.className = 'compatibility-result validation-error';
        div.innerHTML = `
          <div><strong>‚úó –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã</strong></div>
          <div>–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Å –∑–∞–¥–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏</div>
        `;
        resultsDiv.appendChild(div);
        
        compatibility.errors.forEach(error => {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'compatibility-result validation-error';
          errorDiv.innerHTML = `
            <div><strong>‚úó –û—à–∏–±–∫–∞:</strong></div>
            <div>${error.message}</div>
          `;
          resultsDiv.appendChild(errorDiv);
        });
      }
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    function hideCompatibilityPanel() {
      document.getElementById('compatibilityPanel').style.display = 'none';
    }
    
    function debugCoordinates() {
      if (!currentSolution) {
        showStatusMessage('–ù–µ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏', 'warning');
        return;
      }
      
      const panel = document.getElementById('debugPanel');
      const resultsDiv = document.getElementById('debugResults');
      
      const { A, B, C } = currentSolution.points;
      const { Œ±, Œ≤, Œ≥ } = currentSolution.angles;
      const R = currentSolution.scale;
      
      const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
      const a_actual = dist(B, C);
      const b_actual = dist(A, C);
      const c_actual = dist(A, B);
      
      const angleFromCoords = (p1, p2, p3) => {
        const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
        const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x**2 + v1.y**2);
        const mag2 = Math.sqrt(v2.x**2 + v2.y**2);
        const cosAngle = dot / (mag1 * mag2);
        const clamped = Math.max(-1, Math.min(1, cosAngle));
        return Math.acos(clamped) * 180 / Math.PI;
      };
      
      const Œ±_actual = angleFromCoords(B, A, C);
      const Œ≤_actual = angleFromCoords(A, B, C);
      const Œ≥_actual = angleFromCoords(A, C, B);
      
      resultsDiv.innerHTML = '';
      
      const coordsDiv = document.createElement('div');
      coordsDiv.innerHTML = '<strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–µ—Ä—à–∏–Ω:</strong>';
      resultsDiv.appendChild(coordsDiv);
      
      addDebugRow('A (–≤–µ—Ä—à–∏–Ω–∞ Œ±)', `(${A.x.toFixed(4)}, ${A.y.toFixed(4)})`, resultsDiv);
      addDebugRow('B (–≤–µ—Ä—à–∏–Ω–∞ Œ≤)', `(${B.x.toFixed(4)}, ${B.y.toFixed(4)})`, resultsDiv);
      addDebugRow('C (–≤–µ—Ä—à–∏–Ω–∞ Œ≥)', `(${C.x.toFixed(4)}, ${C.y.toFixed(4)})`, resultsDiv);
      addDebugRow('–†–∞–¥–∏—É—Å R', R.toFixed(4), resultsDiv);
      
      const sidesDiv = document.createElement('div');
      sidesDiv.innerHTML = '<br><strong>–§–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong>';
      resultsDiv.appendChild(sidesDiv);
      
      addDebugRow('AB (c)', `${c_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideAB).toFixed(4)})`, resultsDiv);
      addDebugRow('BC (a)', `${a_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideBC).toFixed(4)})`, resultsDiv);
      addDebugRow('AC (b)', `${b_actual.toFixed(4)} (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${parseFloat(currentSolution.params.sideAC).toFixed(4)})`, resultsDiv);
      
      const anglesDiv = document.createElement('div');
      anglesDiv.innerHTML = '<br><strong>–§–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —É–≥–ª—ã –∏–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong>';
      resultsDiv.appendChild(anglesDiv);
      
      addDebugRow('‚à†A (Œ±)', `${Œ±_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ±.toFixed(2)}¬∞)`, resultsDiv);
      addDebugRow('‚à†B (Œ≤)', `${Œ≤_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ≤.toFixed(2)}¬∞)`, resultsDiv);
      addDebugRow('‚à†C (Œ≥)', `${Œ≥_actual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è: ${Œ≥.toFixed(2)}¬∞)`, resultsDiv);
      
      const sumAnglesActual = Œ±_actual + Œ≤_actual + Œ≥_actual;
      addDebugRow('–°—É–º–º–∞ —É–≥–ª–æ–≤', `${sumAnglesActual.toFixed(2)}¬∞ (–æ–∂–∏–¥–∞–µ—Ç—Å—è 180¬∞)`, resultsDiv);
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    function addDebugRow(label, value, container) {
      const row = document.createElement('div');
      row.className = 'debug-row';
      row.innerHTML = `
        <span class="debug-label">${label}:</span>
        <span class="debug-value">${value}</span>
      `;
      container.appendChild(row);
    }
    
    function validateTriangleGeometry(params) {
      const results = [];
      const Œµ = 1e-6;
      
      const a = parseFloat(params.sideBC);
      const b = parseFloat(params.sideAC);
      const c = parseFloat(params.sideAB);
      const Œ± = parseFloat(params.angleA);
      const Œ≤ = parseFloat(params.angleB);
      const Œ≥ = parseFloat(params.angleC);
      const R = parseFloat(params.circumradius);
      const S = parseFloat(params.area);
      const r = parseFloat(params.inradius);
      
      const sumAngles = Œ± + Œ≤ + Œ≥;
      const angleError = Math.abs(sumAngles - 180);
      results.push({
        test: '–°—É–º–º–∞ —É–≥–ª–æ–≤',
        value: sumAngles.toFixed(6),
        expected: '180.000000',
        error: angleError,
        passed: angleError < 0.001
      });
      
      const sinRatioA = a / Math.sin(Œ± * Math.PI / 180);
      const sinRatioB = b / Math.sin(Œ≤ * Math.PI / 180);
      const sinRatioC = c / Math.sin(Œ≥ * Math.PI / 180);
      const sinError = Math.max(
        Math.abs(sinRatioA - sinRatioB),
        Math.abs(sinRatioB - sinRatioC),
        Math.abs(sinRatioA - sinRatioC)
      );
      results.push({
        test: '–¢–µ–æ—Ä–µ–º–∞ —Å–∏–Ω—É—Å–æ–≤',
        value: `${sinRatioA.toFixed(3)} ‚âà ${sinRatioB.toFixed(3)} ‚âà ${sinRatioC.toFixed(3)}`,
        expected: '–†–∞–≤–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è',
        error: sinError,
        passed: sinError < 0.01
      });
      
      const R_from_sides = (a * b * c) / (4 * S);
      const R_error = Math.abs(R - R_from_sides);
      results.push({
        test: '–†–∞–¥–∏—É—Å –æ–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏',
        value: R.toFixed(6),
        expected: R_from_sides.toFixed(6),
        error: R_error,
        passed: R_error < 0.001
      });
      
      const p = (a + b + c) / 2;
      const r_from_sides = S / p;
      const r_error = Math.abs(r - r_from_sides);
      results.push({
        test: '–†–∞–¥–∏—É—Å –≤–ø–∏—Å–∞–Ω–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏',
        value: r.toFixed(6),
        expected: r_from_sides.toFixed(6),
        error: r_error,
        passed: r_error < 0.001
      });
      
      const triangleInequality = (a + b > c) && (a + c > b) && (b + c > a);
      results.push({
        test: '–ù–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞',
        value: triangleInequality ? '–í—ã–ø–æ–ª–Ω–µ–Ω–æ' : '–ù–∞—Ä—É—à–µ–Ω–æ',
        expected: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ',
        error: triangleInequality ? 0 : 1,
        passed: triangleInequality
      });
      
      return {
        results: results,
        passed: results.every(r => r.passed),
        score: results.filter(r => r.passed).length / results.length * 100
      };
    }
    
    function validateCurrentTriangleEnhanced() {
      if (!currentSolution) {
        showStatusMessage('–ù–µ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏', 'warning');
        return;
      }
      
      const validation = validateTriangleGeometry(currentSolution.params);
      const practicalCheck = checkPracticalFeasibility(currentSolution.params);
      const numericalCheck = checkNumericalFeasibility(currentSolution.params);
      
      const panel = document.getElementById('validationPanel');
      const resultsDiv = document.getElementById('validationResults');
      
      resultsDiv.innerHTML = '';
      
      // –ó–∞–≥–æ–ª–æ–≤–æ–∫
      const header = document.createElement('div');
      header.className = 'validation-result';
      header.style.backgroundColor = '#34495e';
      header.style.color = 'white';
      header.style.fontWeight = 'bold';
      header.innerHTML = '<div style="text-align: center;">–ü–û–õ–ù–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø –¢–†–ï–£–ì–û–õ–¨–ù–ò–ö–ê</div>';
      resultsDiv.appendChild(header);
      
      // –ë–∞–∑–æ–≤—ã–µ –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
      validation.results.forEach(result => {
        const div = document.createElement('div');
        div.className = `validation-result ${result.passed ? 'validation-ok' : 'validation-error'}`;
        
        let status = result.passed ? '‚úì' : '‚úó';
        
        div.innerHTML = `
          <div><strong>${status} ${result.test}:</strong></div>
          <div>–ü–æ–ª—É—á–µ–Ω–æ: ${result.value}</div>
          <div>–û–∂–∏–¥–∞–µ—Ç—Å—è: ${result.expected}</div>
          <div style="font-size: 11px; color: #666;">–û—à–∏–±–∫–∞: ${result.error.toExponential(2)}</div>
        `;
        
        resultsDiv.appendChild(div);
      });
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏
      if (practicalCheck.allIssues.length > 0) {
        const practicalDiv = document.createElement('div');
        practicalDiv.className = `validation-result ${practicalCheck.feasible ? 'validation-warning' : 'validation-error'}`;
        practicalDiv.innerHTML = `
          <div><strong>${practicalCheck.feasible ? '‚ö†' : '‚úó'} –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å:</strong></div>
          <div>${practicalCheck.feasible ? '–ï—Å—Ç—å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è' : '–ï—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã'}</div>
        `;
        resultsDiv.appendChild(practicalDiv);
        
        practicalCheck.allIssues.forEach((issue, index) => {
          if (index < 3) {
            const issueDiv = document.createElement('div');
            issueDiv.className = 'validation-result validation-warning';
            issueDiv.style.marginLeft = '20px';
            issueDiv.style.fontSize = '12px';
            issueDiv.innerHTML = `‚Ä¢ ${issue}`;
            resultsDiv.appendChild(issueDiv);
          }
        });
      }
      
      // –ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      const overallPassed = validation.passed && practicalCheck.feasible && numericalCheck.feasible;
      const summary = document.createElement('div');
      summary.className = `validation-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
      summary.innerHTML = `
        <div><strong>${overallPassed ? '‚úì –¢–†–ï–£–ì–û–õ–¨–ù–ò–ö –ö–û–†–†–ï–ö–¢–ï–ù' : '‚úó –ï–°–¢–¨ –ü–†–û–ë–õ–ï–ú–´'}</strong></div>
        <div>–ì–µ–æ–º–µ—Ç—Ä–∏—è: ${validation.results.filter(r => r.passed).length}/${validation.results.length}</div>
        <div>–û—Ü–µ–Ω–∫–∞: ${validation.score.toFixed(1)}%</div>
        <div>–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å: ${practicalCheck.feasible ? '‚úì' : '‚úó'}</div>
        <div>–ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å: ${numericalCheck.feasible ? '‚úì' : '‚úó'}</div>
      `;
      resultsDiv.appendChild(summary);
      
      panel.style.display = 'block';
      updateAllParamsTable(currentSolution);
    }
    
    function determineTriangleType(params) {
      const a = parseFloat(params.sideBC);
      const b = parseFloat(params.sideAC);
      const c = parseFloat(params.sideAB);
      const Œ± = parseFloat(params.angleA);
      const Œ≤ = parseFloat(params.angleB);
      const Œ≥ = parseFloat(params.angleC);
      
      const Œµ = 0.01;
      
      if (Math.abs(a - b) < Œµ && Math.abs(b - c) < Œµ && 
          Math.abs(Œ± - 60) < 1 && Math.abs(Œ≤ - 60) < 1 && Math.abs(Œ≥ - 60) < 1) {
        return 'equilateral';
      }
      
      if (Math.abs(Œ± - 90) < 1 || Math.abs(Œ≤ - 90) < 1 || Math.abs(Œ≥ - 90) < 1) {
        return 'right';
      }
      
      if (Math.abs(a - b) < Œµ || Math.abs(a - c) < Œµ || Math.abs(b - c) < Œµ) {
        return 'isosceles';
      }
      
      return 'scalene';
    }
    
    function updateAllParamsTable(solution = null) {
      const tbody = document.getElementById('paramsTableBody');
      tbody.innerHTML = '';
      
      let validation = null;
      if (solution && solution.params) {
        validation = validateTriangleGeometry(solution.params);
      }
      
      allParameters.forEach((param, index) => {
        let value = '-';
        let isGiven = false;
        let isValid = true;
        let validationInfo = '';
        
        if (solution && solution.params && solution.params[param.key] !== undefined) {
          value = solution.params[param.key];
          
          if (validation) {
            const numValue = parseFloat(value);
            
            if (param.key.includes('side')) {
              const a = parseFloat(solution.params.sideBC);
              const b = parseFloat(solution.params.sideAC);
              const c = parseFloat(solution.params.sideAB);
              isValid = (a + b > c && a + c > b && b + c > a);
              if (!isValid) validationInfo = '–ù–∞—Ä—É—à–µ–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞';
            } else if (param.key.includes('angle')) {
              const sum = parseFloat(solution.params.angleA || 0) + 
                         parseFloat(solution.params.angleB || 0) + 
                         parseFloat(solution.params.angleC || 0);
              isValid = Math.abs(sum - 180) < 0.001;
              if (!isValid) validationInfo = `–°—É–º–º–∞ —É–≥–ª–æ–≤: ${sum.toFixed(2)}¬∞`;
            }
          }
        }
        
        if (selectedParameters && selectedParameters[param.key] !== undefined) {
          isGiven = true;
          value = selectedParameters[param.key].toFixed(6);
        }
        
        const row = document.createElement('tr');
        if (isGiven) {
          row.style.backgroundColor = '#e8f6f3';
        }
        
        const numValue = parseFloat(value);
        const cellClass = !isNaN(numValue) && numValue <= 0 ? 'invalid' : 'valid';
        
        row.innerHTML = `
          <td>${index + 1}</td>
          <td>${param.name}</td>
          <td>${param.designation}</td>
          <td class="${cellClass}"><strong>${value}</strong></td>
          <td>${isGiven ? '‚úì' : ''} ${validationInfo ? `<span style="color: #e74c3c; font-size: 10px;">${validationInfo}</span>` : ''}</td>
        `;
        
        tbody.appendChild(row);
      });
    }
    
    function getTriangleTypeName(type) {
      const names = {
        'equilateral': '—Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π',
        'right': '–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π',
        'isosceles': '—Ä–∞–≤–Ω–æ–±–µ–¥—Ä–µ–Ω–Ω—ã–π',
        'scalene': '—Ä–∞–∑–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π'
      };
      return names[type] || type;
    }
    
    function generateTriangleByType(type) {
      clearAll();
      
      let solution;
      switch(type) {
        case 'equilateral':
          solution = generateEquilateralTriangle();
          break;
        case 'right':
          solution = generateRightTriangle();
          break;
        case 'isosceles':
          solution = generateIsoscelesTriangle();
          break;
        default:
          solution = generateRandomTriangle();
      }
      
      displayGeneratedTriangle(solution);
      showStatusMessage(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω ${getTriangleTypeName(solution.type)} —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫`, 'info');
    }
    
    function generateEquilateralTriangle() {
      const Œ± = 60, Œ≤ = 60, Œ≥ = 60;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'equilateral'
      };
    }
    
    function generateRightTriangle() {
      const Œ± = 90, Œ≤ = 45, Œ≥ = 45;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'right'
      };
    }
    
    function generateIsoscelesTriangle() {
      const Œ± = 70, Œ≤ = 70, Œ≥ = 40;
      const R = 1;
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: 'isosceles'
      };
    }
    
    function generateRandomTriangle() {
      let Œ±, Œ≤;
      do {
        Œ± = 10 + Math.random() * 160;
        Œ≤ = 10 + Math.random() * (160 - Œ±);
      } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
      
      const Œ≥ = 180 - Œ± - Œ≤;
      const R = 1.0 + Math.random() * 1.5;
      
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      const type = determineTriangleType(params);
      
      return {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: type,
        validated: validateTriangleGeometry(params)
      };
    }
    
    function displayGeneratedTriangle(solution) {
      if (!solution) return;
      
      currentSolution = solution;
      
      updateChart(solution);
      updateAllParamsTable(solution);
      
      document.getElementById('statusText').textContent = `–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫: ${getTriangleTypeName(solution.type)}`;
      document.getElementById('statusText').style.color = '#9b59b6';
      document.getElementById('accuracyText').textContent = '100%';
      document.getElementById('iterationsText').textContent = '0';
      document.getElementById('scaleText').textContent = solution.scale.toFixed(2);
      document.getElementById('angleAText').textContent = `${solution.angles.Œ±.toFixed(2)}¬∞`;
      document.getElementById('angleBText').textContent = `${solution.angles.Œ≤.toFixed(2)}¬∞`;
      document.getElementById('angleCText').textContent = `${solution.angles.Œ≥.toFixed(2)}¬∞`;
      document.getElementById('triangleTypeText').textContent = getTriangleTypeName(solution.type);
    }
    
    function generateRandomProblem() {
      clearAll();
      
      const R = 1.0 + Math.random() * 1.5;
      let Œ±, Œ≤;
      
      do {
        Œ± = 10 + Math.random() * 160;
        Œ≤ = 10 + Math.random() * (160 - Œ±);
      } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
      
      const Œ≥ = 180 - Œ± - Œ≤;
      
      if (Œ≥ < 10 || Œ≥ > 170) {
        return generateRandomProblem();
      }
      
      const Œ±Rad = Œ± * Math.PI / 180;
      const Œ≤Rad = Œ≤ * Math.PI / 180;
      
      const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
      const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
      const type = determineTriangleType(params);
      
      const solution = {
        points: points,
        params: params,
        scale: R,
        angles: { Œ±, Œ≤, Œ≥ },
        type: type,
        validated: validateTriangleGeometry(params)
      };
      
      const allKeys = Object.keys(solution.params).filter(key => {
        const value = parseFloat(solution.params[key]);
        return !isNaN(value) && value > 0;
      });
      
      let selectedKeys = [];
      let attempts = 0;
      const maxAttempts = 100;
      
      while (selectedKeys.length < 3 && attempts < maxAttempts) {
        const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
        const candidateKeys = shuffled.slice(0, 3);
        
        const hasAngle = candidateKeys.some(k => k.includes('angle'));
        const hasSide = candidateKeys.some(k => k.includes('side'));
        const hasOther = candidateKeys.some(k => !k.includes('angle') && !k.includes('side'));
        
        if ((hasAngle && hasSide) || (hasAngle && hasOther) || (hasSide && hasOther)) {
          selectedKeys = candidateKeys;
          break;
        }
        
        attempts++;
      }
      
      if (selectedKeys.length < 3) {
        selectedKeys = allKeys.slice(0, 3);
      }
      
      selectedKeys.forEach((key, index) => {
        const value = solution.params[key];
        if (value) {
          const select = document.getElementById(`param${index + 1}`);
          select.value = key;
          
          const numValue = parseFloat(value);
          const input = document.getElementById(`value${index + 1}`);
          
          if (key.includes('angle')) {
            input.value = numValue.toFixed(1);
          } else {
            input.value = numValue.toFixed(3);
          }
          
          updateSliderForParam(index + 1, key);
          
          const range = paramRanges[key];
          if (range) {
            const clampedValue = Math.max(range.min, Math.min(range.max, numValue));
            const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
            
            const slider = document.getElementById(`slider${index + 1}`);
            const valueDisplay = document.getElementById(`sliderValue${index + 1}`);
            
            if (slider && valueDisplay) {
              slider.value = normalizedValue;
              
              let displayValue;
              if (key.includes('angle')) {
                displayValue = clampedValue.toFixed(1) + '¬∞';
              } else {
                displayValue = clampedValue.toFixed(3);
              }
              
              valueDisplay.textContent = displayValue;
            }
          }
        }
      });
      
      displayGeneratedTriangle(solution);
      validateParameterSelection();
      
      showStatusMessage(`–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞ –∑–∞–¥–∞—á–∞ —Å ${getTriangleTypeName(solution.type)} —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–º`, 'info');
    }
    
    function testAndDisplayFormulas() {
      console.clear();
      console.log('=== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –§–û–†–ú–£–õ ===');
      
      const equilateral = generateEquilateralTriangle();
      console.log('\n1. –†–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ (Œ±=Œ≤=Œ≥=60¬∞, R=1):');
      console.log('–°—Ç–æ—Ä–æ–Ω—ã (–æ–∂–∏–¥–∞–µ—Ç—Å—è ~1.732):', 
        equilateral.params.sideAB, equilateral.params.sideBC, equilateral.params.sideAC);
      
      const right = generateRightTriangle();
      console.log('\n2. –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ (Œ±=90¬∞, Œ≤=Œ≥=45¬∞, R=1):');
      console.log('–°—Ç–æ—Ä–æ–Ω—ã:', right.params.sideAB, right.params.sideBC, right.params.sideAC);
      
      const validation = validateTriangleGeometry(equilateral.params);
      console.log('\n3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–µ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞:');
      console.log(`–ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: ${validation.results.filter(r => r.passed).length}/${validation.results.length}`);
      console.log(`–û—Ü–µ–Ω–∫–∞: ${validation.score.toFixed(1)}%`);
      
      displayGeneratedTriangle(equilateral);
      
      setTimeout(() => {
        debugCoordinates();
      }, 500);
      
      showStatusMessage('–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ (F12).', 'info');
    }
    
    function clearAll() {
      closeSolutionsPanel();
      hideCompatibilityPanel();
      allSolutions = [];
      currentSolutionIndex = 0;
      currentStatusMessages = [];
      
      for (let i = 1; i <= 3; i++) {
        document.getElementById(`param${i}`).value = '';
        document.getElementById(`value${i}`).value = '';
        document.getElementById(`sliderContainer${i}`).style.display = 'none';
        document.getElementById(`param${i}`).style.borderColor = '#ddd';
        document.getElementById(`value${i}`).style.borderColor = '#ddd';
        document.getElementById(`fixParam${i}`).checked = false;
        document.getElementById(`paramRow${i}`).classList.remove('fixed');
      }
      
      selectedParameters = {};
      currentSolution = null;
      
      document.getElementById('solveBtn').disabled = true;
      document.getElementById('solveAllBtn').disabled = true;
      document.getElementById('randomParamsBtn').disabled = true;
      document.getElementById('solveBtn').textContent = '–†–∞—Å—Å—á–∏—Ç–∞—Ç—å';
      document.getElementById('statusText').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö';
      document.getElementById('statusText').style.color = '#7f8c8d';
      document.getElementById('accuracyText').textContent = '-';
      document.getElementById('iterationsText').textContent = '0';
      document.getElementById('scaleText').textContent = '1.00';
      document.getElementById('angleAText').textContent = '-';
      document.getElementById('angleBText').textContent = '-';
      document.getElementById('angleCText').textContent = '-';
      document.getElementById('triangleTypeText').textContent = '-';
      
      hideErrorMessage();
      updateStatusPanel();
      
      document.getElementById('validationPanel').style.display = 'none';
      document.getElementById('debugPanel').style.display = 'none';
      
      if (chart) {
        chart.data.datasets = [
          {
            label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
            data: generateCirclePoints(1, 100),
            borderColor: '#3498db',
            backgroundColor: 'transparent',
            pointRadius: 0,
            showLine: true,
            fill: false,
            borderDash: [5, 5],
            borderWidth: 1
          }
        ];
        chart.options.scales.x.min = -3.5;
        chart.options.scales.x.max = 3.5;
        chart.options.scales.y.min = -3.5;
        chart.options.scales.y.max = 3.5;
        chart.options.plugins.annotation = { annotations: {} };
        applyTriangleYscale();
      }
      
      updateAllParamsTable();
    }
    
    function clearSolutionOnInvalidParams() {
      const statusText = document.getElementById('statusText');
      const accuracyText = document.getElementById('accuracyText');
      const iterationsText = document.getElementById('iterationsText');
      
      statusText.textContent = '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã';
      statusText.style.color = '#e74c3c';
      accuracyText.textContent = '-';
      iterationsText.textContent = '0';
      document.getElementById('scaleText').textContent = '1.00';
      document.getElementById('angleAText').textContent = '-';
      document.getElementById('angleBText').textContent = '-';
      document.getElementById('angleCText').textContent = '-';
      document.getElementById('triangleTypeText').textContent = '-';
      
      currentSolution = null;
      
      if (chart) {
        chart.data.datasets = [{
          label: '–ï–¥–∏–Ω–∏—á–Ω–∞—è –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å',
          data: generateCirclePoints(1, 100),
          borderColor: '#3498db',
          backgroundColor: 'transparent',
          pointRadius: 0,
          showLine: true,
          fill: false,
          borderDash: [5, 5],
          borderWidth: 1
        }];
        chart.update();
      }
      
      updateAllParamsTable();
    }
    
    async function findAllSolutionsEnhanced() {
      if (!validateParameterSelection()) return;
      
      const preCheck = preValidateParametersEnhanced(selectedParameters);
      if (!preCheck.valid) {
        showErrorMessage(preCheck.message, true);
        clearSolutionOnInvalidParams();
        return;
      }
      
      const solveAllBtn = document.getElementById('solveAllBtn');
      solveAllBtn.disabled = true;
      solveAllBtn.textContent = '–ü–æ–∏—Å–∫...';
      
      isFindingAll = true;
      
      const progressContainer = document.getElementById('progressContainer');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      
      progressContainer.style.display = 'block';
      progressText.textContent = '–ü–æ–∏—Å–∫ –≤—Å–µ—Ö —Ä–µ—à–µ–Ω–∏–π (—É–ª—É—á—à–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º)...';
      
      try {
        const mainSolution = await optimizeTriangleWithScaleEnhanced(selectedParameters, (progress, iteration, error) => {
          progressBar.style.width = Math.min(50, progress) + '%';
          progressText.textContent = `–û—Å–Ω–æ–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ: ${iteration} –∏—Ç–µ—Ä–∞—Ü–∏–π, –æ—à–∏–±–∫–∞: ${error.toFixed(6)}`;
        });
        
        allSolutions = generateAllTriangleVariantsEnhanced(mainSolution);
        displaySolutionsPanel(allSolutions);
        
        if (allSolutions.length > 0) {
          showSolution(0);
        }
        
        showStatusMessage(`–ù–∞–π–¥–µ–Ω–æ ${allSolutions.length} —Ä–µ—à–µ–Ω–∏–π`, 'success');
        
      } catch (error) {
        showErrorMessage(`–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: ${error.message}`, true);
        clearSolutionOnInvalidParams();
      } finally {
        solveAllBtn.disabled = false;
        solveAllBtn.textContent = '–í—Å–µ —Ä–µ—à–µ–Ω–∏—è';
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
        isFindingAll = false;
      }
    }
    
    function generateAllTriangleVariantsEnhanced(mainSolution) {
      if (!mainSolution) return [];
      
      const variants = [mainSolution];
      
      if (mainSolution.type !== 'equilateral') {
        // –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
        const mirrored = createMirroredTriangle(mainSolution);
        if (mirrored) {
          variants.push({
            ...mirrored,
            isMirror: true,
            displayName: "–°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ"
          });
        }
        
        // –í—Ä–∞—â–µ–Ω–∏—è (–¥–ª—è –Ω–µ —Ä–∞–≤–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤)
        const rotated1 = rotateTriangle(mainSolution, 120);
        if (rotated1 && !isDuplicateSolution(variants, rotated1)) {
          variants.push({
            ...rotated1,
            displayName: "–ü–æ–≤–æ—Ä–æ—Ç 120¬∞"
          });
        }
        
        const rotated2 = rotateTriangle(mainSolution, 240);
        if (rotated2 && !isDuplicateSolution(variants, rotated2)) {
          variants.push({
            ...rotated2,
            displayName: "–ü–æ–≤–æ—Ä–æ—Ç 240¬∞"
          });
        }
      }
      
      return variants.map(s => normalizeSolutionOrientation(s));
    }
    
    function createMirroredTriangle(original) {
      if (!original || !original.points) return null;
      
      const { A, B, C } = original.points;
      
      return {
        ...original,
        points: {
          A: { x: A.x, y: -A.y },
          B: { x: B.x, y: -B.y },
          C: { x: C.x, y: -C.y }
        },
        isMirror: true
      };
    }
    
    function rotateTriangle(solution, angleDeg) {
      if (!solution || !solution.points) return null;
      
      const angleRad = angleDeg * Math.PI / 180;
      const cosA = Math.cos(angleRad);
      const sinA = Math.sin(angleRad);
      
      const rotatePoint = (p) => ({
        x: p.x * cosA - p.y * sinA,
        y: p.x * sinA + p.y * cosA
      });
      
      return {
        ...solution,
        points: {
          A: rotatePoint(solution.points.A),
          B: rotatePoint(solution.points.B),
          C: rotatePoint(solution.points.C)
        }
      };
    }
    
    function isDuplicateSolution(solutions, newSolution) {
      if (!newSolution || !newSolution.points) return true;
      
      return solutions.some(existing => {
        if (!existing || !existing.points) return false;
        
        const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
        
        const distances = [
          dist(existing.points.A, newSolution.points.A),
          dist(existing.points.B, newSolution.points.B),
          dist(existing.points.C, newSolution.points.C)
        ];
        
        return distances.every(d => d < 0.001);
      });
    }
    
    function displaySolutionsPanel(solutions) {
      if (!solutions || solutions.length === 0) return;
      
      const panel = document.getElementById('solutionsPanel');
      const grid = document.getElementById('solutionsGrid');
      const countDisplay = document.getElementById('solutionsCountDisplay');
      const infoSpan = document.getElementById('allSolutionsInfo');
      const solutionsCount = document.getElementById('solutionsCount');
      
      countDisplay.textContent = solutions.length;
      solutionsCount.textContent = solutions.length;
      infoSpan.style.display = 'inline';
      
      grid.innerHTML = '';
      
      solutions.forEach((solution, index) => {
        const thumb = document.createElement('div');
        thumb.className = `solution-thumb ${solution.isMirror ? 'mirror' : ''}`;
        thumb.onclick = () => showSolution(index);
        
        const typeName = getTriangleTypeName(solution.type);
        const errorPercent = solution.error ? 
          Math.max(0, 100 - solution.error * 100).toFixed(1) : '100.0';
        
        let title = `–†–µ—à–µ–Ω–∏–µ ${index + 1}`;
        if (solution.displayName) {
          title = solution.displayName;
        } else if (solution.isMirror) {
          title = "–°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ";
        }
        
        thumb.innerHTML = `
          <div class="thumb-title">${title}</div>
          <div class="thumb-info">
            Œ±=${solution.angles.Œ±.toFixed(1)}¬∞<br>
            Œ≤=${solution.angles.Œ≤.toFixed(1)}¬∞<br>
            ${typeName}<br>
            <small>–¢–æ—á–Ω–æ—Å—Ç—å: ${errorPercent}%</small>
          </div>
          <div class="solution-actions">
            <button class="solution-btn view-btn" onclick="event.stopPropagation(); showSolution(${index})">
              üëÅ –ü—Ä–æ—Å–º–æ—Ç—Ä
            </button>
            <button class="solution-btn animate-btn" onclick="event.stopPropagation(); animateToSolution(${index})">
              ‚Üí –ê–Ω–∏–º–∞—Ü–∏—è
            </button>
          </div>
        `;
        
        grid.appendChild(thumb);
      });
      
      panel.style.display = 'block';
    }
    
    function showSolution(index) {
      if (!allSolutions || index < 0 || index >= allSolutions.length) return;
      
      document.querySelectorAll('.solution-thumb').forEach((thumb, i) => {
        thumb.classList.toggle('active', i === index);
      });
      
      const solution = allSolutions[index];
      displaySolution(solution);
      currentSolution = solution;
      currentSolutionIndex = index;
      
      updateSolutionIndicator();
    }
    
    function showPreviousSolution() {
      if (allSolutions.length <= 1) return;
      const newIndex = (currentSolutionIndex - 1 + allSolutions.length) % allSolutions.length;
      showSolution(newIndex);
    }
    
    function showNextSolution() {
      if (allSolutions.length <= 1) return;
      const newIndex = (currentSolutionIndex + 1) % allSolutions.length;
      showSolution(newIndex);
    }
    
    function animateToSolution(targetIndex) {
      if (!allSolutions || targetIndex === currentSolutionIndex || allSolutions.length <= 1) return;
      
      const steps = 20;
      const duration = 800;
      const stepTime = duration / steps;
      
      const startSolution = allSolutions[currentSolutionIndex];
      const endSolution = allSolutions[targetIndex];
      
      let currentStep = 0;
      
      const animate = () => {
        if (currentStep > steps) {
          showSolution(targetIndex);
          return;
        }
        
        const t = currentStep / steps;
        const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        
        const interpolatedPoints = {
          A: {
            x: startSolution.points.A.x + (endSolution.points.A.x - startSolution.points.A.x) * easeT,
            y: startSolution.points.A.y + (endSolution.points.A.y - startSolution.points.A.y) * easeT
          },
          B: {
            x: startSolution.points.B.x + (endSolution.points.B.x - startSolution.points.B.x) * easeT,
            y: startSolution.points.B.y + (endSolution.points.B.y - startSolution.points.B.y) * easeT
          },
          C: {
            x: startSolution.points.C.x + (endSolution.points.C.x - startSolution.points.C.x) * easeT,
            y: startSolution.points.C.y + (endSolution.points.C.y - startSolution.points.C.y) * easeT
          }
        };
        
        const intermediateSolution = {
          ...startSolution,
          points: interpolatedPoints
        };
        
        updateChart(intermediateSolution);
        
        currentStep++;
        setTimeout(animate, stepTime);
      };
      
      animate();
    }
    
    function updateSolutionIndicator() {
      const indicator = document.getElementById('solutionIndicator');
      if (!allSolutions || allSolutions.length <= 1) {
        indicator.textContent = '';
        return;
      }
      
      indicator.textContent = `[${currentSolutionIndex + 1}/${allSolutions.length}]`;
    }
    
    function closeSolutionsPanel() {
      const panel = document.getElementById('solutionsPanel');
      panel.style.display = 'none';
      
      const infoSpan = document.getElementById('allSolutionsInfo');
      infoSpan.style.display = 'none';
      
      allSolutions = [];
      currentSolutionIndex = 0;
      updateSolutionIndicator();
    }
    
    // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ö–ù–û–ü–ö–ò "–°–õ–£–ß–ê–ô–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´" ==========
    function setupFixCheckboxes() {
      for (let i = 1; i <= 3; i++) {
        const checkbox = document.getElementById(`fixParam${i}`);
        const paramRow = document.getElementById(`paramRow${i}`);
        
        checkbox.addEventListener('change', function() {
          if (this.checked) {
            paramRow.classList.add('fixed');
          } else {
            paramRow.classList.remove('fixed');
          }
          updateRandomParamsButtonState();
        });
      }
    }
    
    function updateRandomParamsButtonState() {
      const param1Selected = document.getElementById('param1').value !== '';
      const param2Selected = document.getElementById('param2').value !== '';
      const param3Selected = document.getElementById('param3').value !== '';
      
      const allParamsSelected = param1Selected && param2Selected && param3Selected;
      
      const fix1 = document.getElementById('fixParam1').checked;
      const fix2 = document.getElementById('fixParam2').checked;
      const fix3 = document.getElementById('fixParam3').checked;
      
      const allFixed = fix1 && fix2 && fix3;
      
      const randomParamsBtn = document.getElementById('randomParamsBtn');
      
      if (allParamsSelected && !allFixed) {
        randomParamsBtn.disabled = false;
      } else {
        randomParamsBtn.disabled = true;
      }
    }
    
    function randomizeNonFixedParameters() {
      if (!validateParameterSelection()) return;
      
      let changedAny = false;
      
      for (let i = 1; i <= 3; i++) {
        const paramKey = document.getElementById(`param${i}`).value;
        const isFixed = document.getElementById(`fixParam${i}`).checked;
        
        if (!paramKey || isFixed) continue;
        
        const range = paramRanges[paramKey];
        if (!range) continue;
        
        let randomValue;
        
        if (paramKey.includes('angle')) {
          const otherAngles = getOtherAngleValues(i);
          const maxAngle = 170 - otherAngles.reduce((a, b) => a + b, 0);
          
          if (maxAngle < 10) {
            continue;
          }
          
          randomValue = 10 + Math.random() * (maxAngle - 10);
          randomValue = Math.max(10, Math.min(maxAngle, randomValue));
        } else {
          randomValue = range.min + Math.random() * (range.max - range.min);
        }
        
        const input = document.getElementById(`value${i}`);
        const slider = document.getElementById(`slider${i}`);
        const valueDisplay = document.getElementById(`sliderValue${i}`);
        
        if (paramKey.includes('angle')) {
          input.value = randomValue.toFixed(1);
        } else {
          input.value = randomValue.toFixed(3);
        }
        
        const normalizedValue = ((randomValue - range.min) / (range.max - range.min)) * 100;
        
        if (slider) slider.value = normalizedValue;
        
        let displayValue;
        if (paramKey.includes('angle')) {
          displayValue = randomValue.toFixed(1) + '¬∞';
        } else {
          displayValue = randomValue.toFixed(3);
        }
        
        if (valueDisplay) valueDisplay.textContent = displayValue;
        
        changedAny = true;
      }
      
      if (changedAny) {
        validateParameterSelection();
        showStatusMessage('–ó–Ω–∞—á–µ–Ω–∏—è –Ω–µ–∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω—ã', 'info');
      } else {
        showStatusMessage('–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω—ã', 'warning');
      }
    }
    
    function getOtherAngleValues(currentIndex) {
      const otherAngles = [];
      
      for (let i = 1; i <= 3; i++) {
        if (i === currentIndex) continue;
        
        const paramKey = document.getElementById(`param${i}`).value;
        const isFixed = document.getElementById(`fixParam${i}`).checked;
        
        if (paramKey && paramKey.includes('angle') && isFixed) {
          const value = parseFloat(document.getElementById(`value${i}`).value);
          if (!isNaN(value)) {
            otherAngles.push(value);
          }
        }
      }
      
      return otherAngles;
    }
    
    // ========== –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ü–†–û–í–ï–†–ö–ò –ü–†–ê–ö–¢–ò–ß–ï–°–ö–û–ô –†–ï–ê–õ–ò–ó–£–ï–ú–û–°–¢–ò UI ==========
    function checkPracticalFeasibilityUI() {
      if (Object.keys(selectedParameters).length === 0) {
        showStatusMessage('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã', 'warning');
        return;
      }
      
      const compatibility = checkParameterCompatibility(selectedParameters);
      const practicalCheck = checkPracticalFeasibility(selectedParameters);
      const numericalCheck = checkNumericalFeasibility(selectedParameters);
      
      const panel = document.getElementById('compatibilityPanel');
      const resultsDiv = document.getElementById('compatibilityResults');
      
      resultsDiv.innerHTML = '';
      
      // –ó–∞–≥–æ–ª–æ–≤–æ–∫
      const header = document.createElement('div');
      header.className = 'compatibility-result';
      header.style.backgroundColor = '#34495e';
      header.style.color = 'white';
      header.style.fontWeight = 'bold';
      header.innerHTML = '<div style="text-align: center;">–ü–û–õ–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –ü–ê–†–ê–ú–ï–¢–†–û–í</div>';
      resultsDiv.appendChild(header);
      
      // 1. –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      const compatDiv = document.createElement('div');
      compatDiv.className = `compatibility-result ${compatibility.passed ? 'validation-ok' : 'validation-error'}`;
      compatDiv.innerHTML = `
        <div><strong>${compatibility.passed ? '‚úì' : '‚úó'} –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:</strong></div>
        <div>${compatibility.passed ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–≤–º–µ—Å—Ç–∏–º—ã' : '–ï—Å—Ç—å –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã'}</div>
        <div style="font-size: 11px;">–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: ${compatibility.allChecks.length} —É—Å–ª–æ–≤–∏–π</div>
      `;
      resultsDiv.appendChild(compatDiv);
      
      // 2. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å
      const practicalDiv = document.createElement('div');
      practicalDiv.className = `compatibility-result ${practicalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
      practicalDiv.innerHTML = `
        <div><strong>${practicalCheck.feasible ? '‚úì' : '‚úó'} –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å:</strong></div>
        <div>${practicalCheck.feasible ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∞–ª–∏–∑—É–µ–º—ã' : '–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π'}</div>
        <div style="font-size: 11px;">–û—à–∏–±–æ–∫: ${practicalCheck.errors.length}, –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π: ${practicalCheck.warnings.length}</div>
      `;
      resultsDiv.appendChild(practicalDiv);
      
      // 3. –ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å
      const numericalDiv = document.createElement('div');
      numericalDiv.className = `compatibility-result ${numericalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
      numericalDiv.innerHTML = `
        <div><strong>${numericalCheck.feasible ? '‚úì' : '‚úó'} –ß–∏—Å–ª–µ–Ω–Ω–∞—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:</strong></div>
        <div>${numericalCheck.feasible ? '–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç–∞–±–∏–ª—å–Ω—ã' : '–í–æ–∑–º–æ–∂–Ω—ã —á–∏—Å–ª–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏'}</div>
        <div style="font-size: 11px;">–ü—Ä–æ–±–ª–µ–º: ${numericalCheck.issues.length}</div>
      `;
      resultsDiv.appendChild(numericalDiv);
      
      // –í—ã–≤–æ–¥ –≤—Å–µ—Ö –ø—Ä–æ–±–ª–µ–º
      const allProblems = [
        ...compatibility.errors.map(e => ({type: 'error', message: e.message})),
        ...practicalCheck.errors.map(e => ({type: 'error', message: e})),
        ...practicalCheck.warnings.map(w => ({type: 'warning', message: w})),
        ...numericalCheck.issues.map(i => ({type: i.includes('–æ—à–∏–±–∫–∞') ? 'error' : 'warning', message: i}))
      ];
      
      if (allProblems.length > 0) {
        const problemsDiv = document.createElement('div');
        problemsDiv.className = 'compatibility-result';
        problemsDiv.style.backgroundColor = '#f8f9fa';
        problemsDiv.innerHTML = '<div><strong>–î–µ—Ç–∞–ª–∏:</strong></div>';
        resultsDiv.appendChild(problemsDiv);
        
        allProblems.forEach(problem => {
          const problemDiv = document.createElement('div');
          problemDiv.className = `compatibility-result ${problem.type === 'error' ? 'validation-error' : 'validation-warning'}`;
          problemDiv.style.marginTop = '5px';
          problemDiv.innerHTML = `
            <div><strong>${problem.type === 'error' ? '‚úó' : '‚ö†'} ${problem.type === 'error' ? '–û—à–∏–±–∫–∞' : '–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ'}:</strong></div>
            <div>${problem.message}</div>
          `;
          resultsDiv.appendChild(problemDiv);
        });
      }
      
      // –ò—Ç–æ–≥–æ–≤—ã–π –≤–µ—Ä–¥–∏–∫—Ç
      const overallPassed = compatibility.passed && practicalCheck.feasible && numericalCheck.feasible;
      const verdictDiv = document.createElement('div');
      verdictDiv.className = `compatibility-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
      verdictDiv.style.fontWeight = 'bold';
      verdictDiv.style.fontSize = '14px';
      verdictDiv.innerHTML = `
        <div><strong>${overallPassed ? '‚úì –ì–û–¢–û–í–û –ö –†–ê–°–ß–Å–¢–£' : '‚úó –¢–†–ï–ë–£–Æ–¢–°–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø'}</strong></div>
        <div>${overallPassed ? '–í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ' : '–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å'}</div>
      `;
      resultsDiv.appendChild(verdictDiv);
      
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
    
    // ========== –£–õ–£–ß–®–ï–ù–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ==========
    function setupEnhancedEventListeners() {
      // –î–æ–±–∞–≤–ª—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é –ø—Ä–∏ –≤–≤–æ–¥–µ –∑–Ω–∞—á–µ–Ω–∏–π
      ['value1', 'value2', 'value3'].forEach(id => {
        const input = document.getElementById(id);
        
        input.addEventListener('input', function() {
          const index = parseInt(id.replace('value', ''));
          const paramKey = document.getElementById(`param${index}`).value;
          
          if (!paramKey) return;
          
          const value = parseFloat(this.value);
          if (isNaN(value)) return;
          
          // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç–∏ –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
          if (paramKey.includes('angle')) {
            if (value < 0.1 || value > 179.9) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–£–≥–æ–ª —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–æ–∫ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º (${value}¬∞)`, 'warning');
            } else {
              this.style.borderColor = '#2ecc71';
            }
          } else {
            if (value < 0.001) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–ó–Ω–∞—á–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ (${value})`, 'warning');
            } else if (value > 1000) {
              this.style.borderColor = '#e74c3c';
              showStatusMessage(`–ó–Ω–∞—á–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫–æ (${value})`, 'warning');
            } else {
              this.style.borderColor = '#2ecc71';
            }
          }
        });
      });
    }
    
    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–ª–∞–≥–∏–Ω–∞ –¥–ª—è –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π Chart.js
    if (typeof Chart !== 'undefined' && Chart.register) {
      Chart.register({
        id: 'annotation',
        afterDraw: function(chart) {
          const ctx = chart.ctx;
          const annotations = chart.options.plugins?.annotation?.annotations;
          
          if (!annotations) return;
          
          Object.values(annotations).forEach(annotation => {
            if (!annotation || !annotation.xValue || !annotation.yValue) return;
            
            const meta = chart.getDatasetMeta(0);
            const xScale = chart.scales.x;
            const yScale = chart.scales.y;
            
            const x = xScale.getPixelForValue(annotation.xValue);
            const y = yScale.getPixelForValue(annotation.yValue);
            
            ctx.save();
            ctx.font = annotation.font?.size + 'px ' + (annotation.font?.weight || 'normal') + ' Arial';
            ctx.fillStyle = annotation.color || '#2c3e50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const xAdj = annotation.xAdjust || 0;
            const yAdj = annotation.yAdjust || 0;
            
            ctx.fillText(annotation.content, x + xAdj, y + yAdj);
            ctx.restore();
          });
        }
      });
    }
  </script>
</body>
</html>