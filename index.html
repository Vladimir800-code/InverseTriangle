<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Triangle Solver ‚Äî Inverse Geometry Tool</title>
 <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
 <style>
 body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
 .container { display: flex; margin: 20px 0; gap: 20px; flex-wrap: wrap; }
 .panel { background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
 .visualization-panel { flex: 2; min-width: 500px; position: relative; }
 .control-panel { flex: 1; min-width: 300px; display: flex; flex-direction: column; }
 h1, h2, h3 { color: #2c3e50; margin-top: 0; }
 h1 { font-size: 24px; margin-bottom: 10px; }
 h2 { font-size: 20px; margin-bottom: 15px; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
 .param-group { margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
 .param-row { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
 .param-label { min-width: 40px; font-weight: bold; color: #2c3e50; }
 select.param-select { flex: 2; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; transition: border-color 0.3s; }
 select.param-select:focus { border-color: #3498db; outline: none; }
 input.param-value { flex: 1; padding: 8px 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; text-align: right; min-width: 80px; }
 input.param-value:focus { border-color: #3498db; outline: none; }
 .slider-container { flex: 2; display: flex; flex-direction: column; gap: 5px; }
 .slider-row { display: flex; align-items: center; gap: 10px; }
 .slider-value { min-width: 50px; text-align: right; font-weight: bold; color: #2c3e50; font-size: 13px; }
 input.param-slider { flex: 1; height: 6px; border-radius: 3px; background: #ddd; outline: none; -webkit-appearance: none; }
 input.param-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
 input.param-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #3498db; cursor: pointer; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }
 /* andandand */
 .fix-checkbox-container { display: flex; align-items: center; margin-left: 5px; }
 .fix-checkbox-label { font-size: 12px; color: #7f8c8d; margin-left: 4px; white-space: nowrap; }
 input.fix-checkbox { width: 16px; height: 16px; cursor: pointer; }
 .param-row.fixed .param-select,
 .param-row.fixed .param-value,
 .param-row.fixed .slider-value { opacity: 0.7; background-color: #f5f5f5; }
 .button-group { display: flex; gap: 10px; margin-top: 20px; }
 button { padding: 12px 20px; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; flex: 1; }
 #solveBtn { background: #2ecc71; color: white; }
 #solveBtn:hover { background: #27ae60; transform: translateY(-2px); }
 #solveBtn:disabled { background: #95a5a6; cursor: not-allowed; transform: none; }
 #randomBtn { background: #3498db; color: white; }
 #randomBtn:hover { background: #2980b9; transform: translateY(-2px); }
 #randomParamsBtn { background: #9b59b6; color: white; }
 #randomParamsBtn:hover { background: #8e44ad; transform: translateY(-2px); }
 #randomParamsBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
 #clearBtn { background: #e74c3c; color: white; }
 #clearBtn:hover { background: #c0392b; transform: translateY(-2px); }
 #testBtn { background: #9b59b6; color: white; flex: 0.5; }
 #testBtn:hover { background: #8e44ad; transform: translateY(-2px); }
 #validateBtn { background: #f39c12; color: white; flex: 0.5; }
 #validateBtn:hover { background: #d68910; transform: translateY(-2px); }
 #debugBtn { background: #34495e; color: white; flex: 0.5; }
 #debugBtn:hover { background: #2c3e50; transform: translateY(-2px); }
 #solveAllBtn { background: #9b59b6; color: white; flex: 0.5; }
 #solveAllBtn:hover { background: #8e44ad; transform: translateY(-2px); }
 #solveAllBtn:disabled { background: #bdc3c7; cursor: not-allowed; transform: none; }
 #checkBtn { background: #f39c12; color: white; flex: 0.5; }
 #checkBtn:hover { background: #d68910; transform: translateY(-2px); }
 #feasibilityBtn { background: #1abc9c; color: white; flex: 0.5; }
 #feasibilityBtn:hover { background: #16a085; transform: translateY(-2px); }
 .type-btn { padding: 8px 12px; font-size: 14px; flex: 0.33; }
 .progress-container { margin-top: 20px; background: #ecf0f1; border-radius: 10px; overflow: hidden; height: 20px; display: none; }
 #progressBar { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); width: 0%; transition: width 0.5s; }
 #progressText { display: block; text-align: center; margin-top: 5px; font-size: 14px; color: #7f8c8d; }
 .result-info { margin-top: 20px; padding: 15px; background: #e8f6f3; border-radius: 8px; border-left: 4px solid #1abc9c; }
 .result-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
 .result-label { font-weight: bold; color: #2c3e50; }
 .result-value { color: #16a085; font-weight: bold; }
 .result-row.angle-coords { font-size: 13px; color: #7f8c8d; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #ddd; }
 .result-row.angle-coords .result-label { color: #7f8c8d; font-weight: normal; }
 .result-row.angle-coords .result-value { color: #9b59b6; font-weight: bold; }
 .result-row.triangle-type { font-size: 13px; color: #7f8c8d; font-style: italic; }
 .table-container { margin-top: 20px; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; }
 table { width: 100%; border-collapse: collapse; font-size: 12px; }
 th { background: #34495e; color: white; padding: 8px; text-align: left; position: sticky; top: 0; }
 td { padding: 6px 8px; border-bottom: 1px solid #ddd; }
 tr:nth-child(even) { background: #f8f9fa; }
 tr:hover { background: #e3f2fd; }
 td.invalid { background-color: #ffeaea; color: #e74c3c; }
 td.valid { background-color: #e8f6f3; }
 .chart-container { width: 100%; height: 500px; margin-bottom: 20px; position: relative; }
 canvas { width: 100% !important; height: 100% !important; }
 .scale-control { position: absolute; right: 20px; bottom: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 10; width: 200px; }
 .scale-control h4 { margin: 0 0 8px 0; font-size: 14px; color: #2c3e50; }
 .scale-slider { width: 100%; margin: 5px 0; }
 .scale-value { font-size: 12px; color: #7f8c8d; text-align: center; margin-top: 5px; }
 .info-box { background: #fff8e1; border-left: 4px solid #ffb300; padding: 10px 15px; margin-bottom: 15px; border-radius: 4px; font-size: 14px; }
 .error-message { color: #e74c3c; font-size: 14px; margin-top: 10px; padding: 10px; background: #ffeaea; border-radius: 6px; border-left: 4px solid #e74c3c; }
 .error-message.hidden { display: none; }
 .validation-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
 .validation-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
 .validation-ok { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
 .validation-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
 .validation-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
 .debug-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #34495e; }
 .debug-row { display: flex; justify-content: space-between; margin: 3px 0; font-size: 12px; font-family: monospace; }
 .debug-label { color: #2c3e50; }
 .debug-value { color: #9b59b6; font-weight: bold; }
 .solutions-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #9b59b6; }
 .solutions-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
 .solutions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin-top: 10px; }
 .solution-thumb { background: white; border-radius: 6px; padding: 10px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; text-align: center; }
 .solution-thumb:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-color: #3498db; }
 .solution-thumb.active { border-color: #2ecc71; background: #e8f6f3; }
 .solution-thumb.mirror .thumb-title::after { content: " ü™û"; font-size: 10px; }
 .solution-thumb .thumb-title { font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #2c3e50; }
 .solution-thumb .thumb-info { font-size: 10px; color: #7f8c8d; }
 .solution-actions { display: flex; gap: 5px; margin-top: 8px; }
 .solution-btn { padding: 4px 8px; font-size: 10px; border-radius: 3px; border: none; cursor: pointer; flex: 1; }
 .view-btn { background: #3498db; color: white; }
 .animate-btn { background: #9b59b6; color: white; }
 .solution-navigation { display: flex; justify-content: center; gap: 10px; margin-top: 15px; }
 .nav-btn { padding: 6px 12px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; background: #34495e; color: white; }
 .nav-btn:hover { background: #2c3e50; }
 .solution-indicator { display: inline-block; margin-left: 10px; font-size: 14px; color: #9b59b6; font-weight: bold; }
 .compatibility-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #f39c12; }
 .compatibility-result { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
 .status-panel { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
 .status-message { margin: 5px 0; padding: 8px; border-radius: 4px; font-size: 13px; }
 .status-info { background: #d1ecf1; color: #0c5460; border-left: 3px solid #17a2b8; }
 .status-warning { background: #fff3cd; color: #856404; border-left: 3px solid #ffc107; }
 .status-error { background: #f8d7da; color: #721c24; border-left: 3px solid #dc3545; }
 .status-success { background: #d4edda; color: #155724; border-left: 3px solid #28a745; }
 .floating-message {
 position: fixed;
 top: 20px;
 right: 20px;
 padding: 15px;
 border-radius: 8px;
 color: white;
 font-weight: bold;
 z-index: 1000;
 box-shadow: 0 4px 12px rgba(0,0,0,0.2);
 animation: fadeIn 0.3s;
 max-width: 400px;
 max-height: 300px;
 overflow-y: auto;
 line-height: 1.4;
 }
 @keyframes fadeIn {
 from { opacity: 0; transform: translateY(-20px); }
 to { opacity: 1; transform: translateY(0); }
 }
 @media (max-width: 900px) {
 .container { flex-direction: column; }
 .visualization-panel, .control-panel { min-width: 100%; }
 .scale-control { position: relative; right: auto; bottom: auto; width: 100%; margin-top: 10px; }
 .solutions-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
 .param-row { flex-wrap: wrap; }
 .fix-checkbox-container { margin-left: auto; }
 }
 </style>
</head>
<body>
 <h1>Triangle Solver ‚Äî Inverse Geometry Calculator</h1>
 <div class="info-box">
 <strong>Enhanced system:</strong> Now includes practical feasibility checks, numerical stability, and adaptive optimization.
 <span id="allSolutionsInfo" style="display: none; color: #9b59b6; margin-left: 10px;">
 | Solutions found: <span id="solutionsCount">0</span>
 </span>
 </div>
 <div class="container">
 <div class="panel visualization-panel">
 <h2>Triangle visualization
 <span id="solutionIndicator" class="solution-indicator"></span>
 </h2>
 <div class="chart-container">
 <canvas id="triangleChart"></canvas>
 <div class="scale-control">
 <h4 style="margin: 0 0 8px 0;">Vertical scale:</h4>
 <input type="range" class="scale-slider" id="yScale" min="40" max="200" step="10">
 <div class="scale-value">
 Scale: <span id="yScaleLabel" class="percent"></span>%
 </div>
 </div>
 </div>
 <div class="result-info">
 <div class="result-row">
 <span class="result-label">Status:</span>
 <span id="statusText" class="result-value">Waiting for input</span>
 </div>
 <div class="result-row">
 <span class="result-label">Accuracy:</span>
 <span id="accuracyText" class="result-value">-</span>
 </div>
 <div class="result-row">
 <span class="result-label">Iterations:</span>
 <span id="iterationsText" class="result-value">0</span>
 </div>
 <div class="result-row">
 <span class="result-label">Scale (R):</span>
 <span id="scaleText" class="result-value">1.00</span>
 </div>
 <div class="result-row angle-coords">
 <span class="result-label">Angle A (Œ±):</span>
 <span id="angleAText" class="result-value">-</span>
 </div>
 <div class="result-row angle-coords">
 <span class="result-label">Angle B (Œ≤):</span>
 <span id="angleBText" class="result-value">-</span>
 </div>
 <div class="result-row angle-coords">
 <span class="result-label">Angle C (Œ≥):</span>
 <span id="angleCText" class="result-value">-</span>
 </div>
 <div class="result-row triangle-type">
 <span class="result-label">Type:</span>
 <span id="triangleTypeText" class="result-value">-</span>
 </div>
 </div>
 <div id="statusPanel" class="status-panel" style="display: none;">
 <h4 style="margin-top: 0; margin-bottom: 10px;">Status and warnings</h4>
 <div id="statusMessages"></div>
 </div>
 <div id="debugPanel" class="debug-panel" style="display: none;">
 <h4 style="margin-top: 0; margin-bottom: 10px;">Coordinate debugging</h4>
 <div id="debugResults"></div>
 </div>
 </div>
 <div class="panel control-panel">
 <h2>Parameter setup</h2>
 <div class="param-group">
 <div class="param-row" id="paramRow1">
 <div class="param-label">1.</div>
 <select class="param-select" id="param1">
 <option value="">Select parameter...</option>
 </select>
 <input type="number" class="param-value" id="value1" step="0.001" placeholder="value">
 <div class="fix-checkbox-container">
 <input type="checkbox" class="fix-checkbox" id="fixParam1" title="Lock value">
 <label for="fixParam1" class="fix-checkbox-label">Lock</label>
 </div>
 </div>
 <div class="slider-container" id="sliderContainer1" style="display: none;">
 <div class="slider-row">
 <span class="slider-value" id="sliderValue1">0</span>
 <input type="range" class="param-slider" id="slider1" min="0" max="100" step="0.1">
 </div>
 </div>
 <div class="param-row" id="paramRow2">
 <div class="param-label">2.</div>
 <select class="param-select" id="param2">
 <option value="">Select parameter...</option>
 </select>
 <input type="number" class="param-value" id="value2" step="0.001" placeholder="value">
 <div class="fix-checkbox-container">
 <input type="checkbox" class="fix-checkbox" id="fixParam2" title="Lock value">
 <label for="fixParam2" class="fix-checkbox-label">Lock</label>
 </div>
 </div>
 <div class="slider-container" id="sliderContainer2" style="display: none;">
 <div class="slider-row">
 <span class="slider-value" id="sliderValue2">0</span>
 <input type="range" class="param-slider" id="slider2" min="0" max="100" step="0.1">
 </div>
 </div>
 <div class="param-row" id="paramRow3">
 <div class="param-label">3.</div>
 <select class="param-select" id="param3">
 <option value="">Select parameter...</option>
 </select>
 <input type="number" class="param-value" id="value3" step="0.001" placeholder="value">
 <div class="fix-checkbox-container">
 <input type="checkbox" class="fix-checkbox" id="fixParam3" title="Lock value">
 <label for="fixParam3" class="fix-checkbox-label">Lock</label>
 </div>
 </div>
 <div class="slider-container" id="sliderContainer3" style="display: none;">
 <div class="slider-row">
 <span class="slider-value" id="sliderValue3">0</span>
 <input type="range" class="param-slider" id="slider3" min="0" max="100" step="0.1">
 </div>
 </div>
 </div>
 <div class="button-group">
 <button id="solveBtn" onclick="startSolvingEnhanced()">Solve</button>
 <button id="randomBtn" onclick="generateRandomProblem()">Random problem</button>
 <button id="randomParamsBtn" onclick="randomizeNonFixedParameters()" disabled>Random parameters</button>
 <button id="clearBtn" onclick="clearAll()">Clear</button>
 </div>
 <div class="button-group" style="margin-top: 10px;">
 <button id="solveAllBtn" onclick="findAllSolutionsEnhanced()">All solutions</button>
 <button id="checkBtn" onclick="checkCompatibility()">Check compatibility</button>
 <button id="feasibilityBtn" onclick="checkPracticalFeasibilityUI()">Practical check</button>
 <button id="testBtn" onclick="testAndDisplayFormulas()">Test formulas</button>
 <button id="validateBtn" onclick="validateCurrentTriangleEnhanced()">Validate</button>
 <button id="debugBtn" onclick="debugCoordinates()">Debug</button>
 </div>
 <div class="button-group" style="margin-top: 10px;">
 <button onclick="generateTriangleByType('equilateral')" class="type-btn" style="background: #2ecc71;">
 Equilateral
 </button>
 <button onclick="generateTriangleByType('right')" class="type-btn" style="background: #e74c3c;">
 Right
 </button>
 <button onclick="generateTriangleByType('isosceles')" class="type-btn" style="background: #3498db;">
 Isosceles
 </button>
 </div>
 <div id="errorMessage" class="error-message hidden">
 <!-- Errors will appear here -->
 </div>
 <div id="statusMessagesInline" class="status-panel" style="margin-top: 20px; display: none;">
 <h4 style="margin-top: 0; margin-bottom: 10px;">System messages</h4>
 <div id="inlineStatusContent"></div>
 </div>
 <div class="progress-container" id="progressContainer">
 <div id="progressBar"></div>
 </div>
 <span id="progressText">Ready</span>
 <div id="compatibilityPanel" class="compatibility-panel" style="display: none;">
 <h4 style="margin-top: 0; margin-bottom: 10px;">Parameter compatibility check</h4>
 <div id="compatibilityResults"></div>
 </div>
 <div id="validationPanel" class="validation-panel" style="display: none;">
 <h4 style="margin-top: 0; margin-bottom: 10px;">Geometry validation</h4>
 <div id="validationResults"></div>
 </div>
 <div class="info-box" style="margin-top: 20px;">
 <strong>Hint:</strong> Select 3 different parameters from the list. Use sliders or enter values manually. Check ‚ÄúLock‚Äù to fix a parameter. Click "Solve" to compute the triangle.</div>
 </div>
 </div>
 <div id="solutionsPanel" class="solutions-panel" style="display: none;">
 <div class="solutions-header">
 <h3 style="margin: 0;">Found solutions (<span id="solutionsCountDisplay">0</span>)</h3>
 <div>
 <button onclick="showPreviousSolution()" class="nav-btn">‚óÄ Previous</button>
 <button onclick="showNextSolution()" class="nav-btn">Next ‚ñ∂</button>
 <button onclick="closeSolutionsPanel()" class="nav-btn" style="background: #e74c3c;">‚úï Close</button>
 </div>
 </div>
 <div class="info-box" style="margin: 10px 0; padding: 8px; font-size: 13px;">
 <strong>All solutions or andand.</strong> Symmetric variants are marked with ü™û. Click a thumbnail to view.
 </div>
 <div id="solutionsGrid" class="solutions-grid"></div>
 <div class="solution-navigation">
 <button onclick="showSolution(0)" class="nav-btn">First</button>
 <button onclick="showSolution(allSolutions.length-1)" class="nav-btn">Last</button>
 </div>
 </div>
 <div class="panel" style="margin-top: 20px;">
 <h2>All triangle parameters</h2>
 <div class="table-container">
 <table id="allParamsTable">
 <thead>
 <tr>
 <th>No.</th>
 <th>Name</th>
 <th>Symbol</th>
 <th>Value</th>
 <th>Check</th>
 </tr>
 </thead>
 <tbody id="paramsTableBody">
 </tbody>
 </table>
 </div>
 </div>
 <script>
 let allParameters = [];
 let selectedParameters = {};
 let currentSolution = null;
 let chart = null;
 let allSolutions = [];
 let currentSolutionIndex = 0;
 let isFindingAll = false;
 let currentStatusMessages = [];
 let autoCalculateTimer = null; // for
 const paramRanges = {
 'sideAB': { min: 0.1, max: 5.0, step: 0.01 },
 'sideBC': { min: 0.1, max: 5.0, step: 0.01 },
 'sideAC': { min: 0.1, max: 5.0, step: 0.01 },
 'angleA': { min: 10, max: 170, step: 0.1 },
 'angleB': { min: 10, max: 170, step: 0.1 },
 'angleC': { min: 10, max: 170, step: 0.1 },
 'altitudeA': { min: 0.05, max: 5.0, step: 0.01 },
 'altitudeB': { min: 0.05, max: 5.0, step: 0.01 },
 'altitudeC': { min: 0.05, max: 5.0, step: 0.01 },
 'bisectorA': { min: 0.05, max: 5.0, step: 0.01 },
 'bisectorB': { min: 0.05, max: 5.0, step: 0.01 },
 'bisectorC': { min: 0.05, max: 5.0, step: 0.01 },
 'medianA': { min: 0.05, max: 5.0, step: 0.01 },
 'medianB': { min: 0.05, max: 5.0, step: 0.01 },
 'medianC': { min: 0.05, max: 5.0, step: 0.01 },
 'inradius': { min: 0.01, max: 2.5, step: 0.01 },
 'area': { min: 0.01, max: 6.25, step: 0.01 },
 'circumradius': { min: 0.5, max: 5.0, step: 0.01 }
 };
 document.addEventListener('DOMContentLoaded', function() {
 initParameters();
 initChart();
 setupEventListeners();
 initVerticalScaleControl();
 document.getElementById('solveAllBtn').disabled = true;
 setupFixCheckboxes();
 setupEnhancedEventListeners();
 });
 function initParameters() {
 allParameters = [
 { name: 'Side AB', designation: 'c', key: 'sideAB' },
 { name: 'Side BC', designation: 'a', key: 'sideBC' },
 { name: 'Side AC', designation: 'b', key: 'sideAC' },
 { name: 'Angle A', designation: 'Œ±', key: 'angleA' },
 { name: 'Angle B', designation: 'Œ≤', key: 'angleB' },
 { name: 'Angle C', designation: 'Œ≥', key: 'angleC' },
 { name: 'Height from A', designation: 'h‚Çê', key: 'altitudeA' },
 { name: 'Height from B', designation: 'h’¢', key: 'altitudeB' },
 { name: 'Height from C', designation: 'hùí∏', key: 'altitudeC' },
 { name: 'Angle bisector from A', designation: 'l‚Çê', key: 'bisectorA' },
 { name: 'Angle bisector from B', designation: 'l’¢', key: 'bisectorB' },
 { name: 'Angle bisector from C', designation: 'lùí∏', key: 'bisectorC' },
 { name: 'Median from A', designation: 'm‚Çê', key: 'medianA' },
 { name: 'Median from B', designation: 'm’¢', key: 'medianB' },
 { name: 'Median from C', designation: 'mùí∏', key: 'medianC' },
 { name: 'Inradius', designation: 'r', key: 'inradius' },
 { name: 'Area', designation: 'S', key: 'area' },
 { name: 'Circumradius', designation: 'R', key: 'circumradius' }
 ];
 fillParameterSelects();
 setupSliders();
 updateAllParamsTable();
 }
 function fillParameterSelects() {
 const selects = ['param1', 'param2', 'param3'];
 selects.forEach((selectId, index) => {
 const select = document.getElementById(selectId);
 select.innerHTML = '<option value="">Select parameter...</option>';
 allParameters.forEach(param => {
 const option = document.createElement('option');
 option.value = param.key;
 option.textContent = `${param.designation} - ${param.name}`;
 select.appendChild(option);
 });
 select.addEventListener('change', function() {
 updateSliderForParam(index + 1, this.value);
 validateParameterSelection();
 updateRandomParamsButtonState();
 clearStatusMessages();
 // and andnotandand (and not andand)
 setTimeout(() => {
 const isFixed = document.getElementById(`fixParam${index + 1}`).checked;
 if (this.value && !isFixed && validateParameterSelection()) {
 triggerAutoCalculate();
 }
 }, 100);
 });
 });
 }
 function setupSliders() {
 for (let i = 1; i <= 3; i++) {
 const slider = document.getElementById(`slider${i}`);
 const valueDisplay = document.getElementById(`sliderValue${i}`);
 const input = document.getElementById(`value${i}`);
 const select = document.getElementById(`param${i}`);
 const fixCheckbox = document.getElementById(`fixParam${i}`);
 if (slider && valueDisplay && input) {
 // and for and, and and
 const canAutoCalculate = () => {
 // , and not andand
 const paramKey = select.value;
 const isFixed = fixCheckbox && fixCheckbox.checked;
 // true and and not andand
 return paramKey && !isFixed && validateParameterSelection();
 };
 // and
 const triggerAutoCalculate = () => {
 // and and
 if (autoCalculateTimer) {
 clearTimeout(autoCalculateTimer);
 }
 // 300 (and)
 autoCalculateTimer = setTimeout(() => {
 if (canAutoCalculate()) {
 console.log(`andand : ${i} andnot`);
 startSolvingEnhanced();
 }
 }, 300);
 };
 // and and slider +
 slider.addEventListener('input', function() {
 const paramKey = document.getElementById(`param${i}`).value;
 if (!paramKey) return;
 const range = paramRanges[paramKey];
 if (!range) return;
 const normalizedValue = parseFloat(this.value);
 const realValue = range.min + (range.max - range.min) * (normalizedValue / 100);
 let displayValue;
 if (paramKey.includes('angle')) {
 displayValue = realValue.toFixed(1) + '¬∞';
 input.value = realValue.toFixed(1);
 } else {
 displayValue = realValue.toFixed(3);
 input.value = realValue.toFixed(3);
 }
 valueDisplay.textContent = displayValue;
 validateParameterSelection();
 clearStatusMessages();
 // for notandand
 if (canAutoCalculate()) {
 triggerAutoCalculate();
 }
 });
 // and and input +
 input.addEventListener('input', function() {
 const paramKey = document.getElementById(`param${i}`).value;
 if (!paramKey) return;
 const range = paramRanges[paramKey];
 if (!range) return;
 const inputValue = parseFloat(this.value);
 if (isNaN(inputValue)) return;
 const clampedValue = Math.max(range.min, Math.min(range.max, inputValue));
 if (Math.abs(inputValue - clampedValue) > 0.001) {
 this.value = clampedValue.toFixed(paramKey.includes('angle') ? 1 : 3);
 }
 const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
 slider.value = normalizedValue;
 let displayValue;
 if (paramKey.includes('angle')) {
 displayValue = clampedValue.toFixed(1) + '¬∞';
 } else {
 displayValue = clampedValue.toFixed(3);
 }
 valueDisplay.textContent = displayValue;
 validateParameterSelection();
 clearStatusMessages();
 // for notandand
 if (canAutoCalculate()) {
 triggerAutoCalculate();
 }
 });
 // for select andto in fillParameterSelects()
 }
 }
 }
 function updateSliderForParam(paramIndex, paramKey) {
 const sliderContainer = document.getElementById(`sliderContainer${paramIndex}`);
 const slider = document.getElementById(`slider${paramIndex}`);
 const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
 const input = document.getElementById(`value${paramIndex}`);
 if (!paramKey) {
 sliderContainer.style.display = 'none';
 input.value = '';
 document.getElementById(`fixParam${paramIndex}`).checked = false;
 return;
 }
 const range = paramRanges[paramKey];
 if (!range) {
 sliderContainer.style.display = 'none';
 return;
 }
 sliderContainer.style.display = 'flex';
 let initialValue;
 if (input.value && !isNaN(parseFloat(input.value))) {
 initialValue = parseFloat(input.value);
 initialValue = Math.max(range.min, Math.min(range.max, initialValue));
 } else {
 initialValue = (range.min + range.max) / 2;
 }
 if (paramKey.includes('angle')) {
 input.value = initialValue.toFixed(1);
 } else {
 input.value = initialValue.toFixed(3);
 }
 const normalizedValue = ((initialValue - range.min) / (range.max - range.min)) * 100;
 slider.value = normalizedValue;
 let displayValue;
 if (paramKey.includes('angle')) {
 displayValue = initialValue.toFixed(1) + '¬∞';
 } else {
 displayValue = initialValue.toFixed(3);
 }
 valueDisplay.textContent = displayValue;
 }
 function validateParameterSelection() {
 const params = [];
 const values = {};
 let isValid = true;
 hideErrorMessage();
 hideCompatibilityPanel();
 for (let i = 1; i <= 3; i++) {
 const select = document.getElementById(`param${i}`);
 const input = document.getElementById(`value${i}`);
 const paramKey = select.value;
 const value = parseFloat(input.value);
 if (paramKey && !isNaN(value)) {
 if (params.includes(paramKey)) {
 isValid = false;
 showErrorMessage(`Parameter ${getParameterName(paramKey)} selected twice!`, true);
 break;
 }
 if (!validateParameterValue(paramKey, value)) {
 isValid = false;
 break;
 }
 params.push(paramKey);
 values[paramKey] = value;
 } else if (paramKey || input.value) {
 isValid = false;
 }
 }
 if (params.length === 3) {
 selectedParameters = values;
 document.getElementById('solveBtn').disabled = false;
 document.getElementById('solveAllBtn').disabled = false;
 document.getElementById('statusText').textContent = 'Ready to ';
 document.getElementById('statusText').style.color = '#2ecc71';
 } else {
 selectedParameters = {};
 document.getElementById('solveBtn').disabled = true;
 document.getElementById('solveAllBtn').disabled = true;
 document.getElementById('statusText').textContent = 'Select 3 different parameters';
 document.getElementById('statusText').style.color = '#7f8c8d';
 }
 updateRandomParamsButtonState();
 return isValid;
 }
 function validateParameterValue(paramKey, value) {
 if (paramKey.includes('angle')) {
 if (value < 10 || value > 170) {
 showErrorMessage(`angle ${getParameterName(paramKey)} must be between 10¬∞ and 170¬∞!`, true);
 return false;
 }
 } else if (value <= 0) {
 showErrorMessage(`${getParameterName(paramKey)} must be positive!`, true);
 return false;
 }
 const range = paramRanges[paramKey];
 if (range) {
 if (value < range.min || value > range.max) {
 showErrorMessage(`${getParameterName(paramKey)} must be within the range ${range.min} - ${range.max}!`, true);
 return false;
 }
 }
 return true;
 }
 function getParameterName(key) {
 const param = allParameters.find(p => p.key === key);
 return param ? `${param.designation} (${param.name})` : key;
 }
 // ========== check ==========
 function checkParameterCompatibility(params) {
 const checks = [];
 const Œµ = 1e-6;
 // and for and
 const knownSides = {
 a: params.sideBC,
 b: params.sideAC,
 c: params.sideAB
 };
 const knownAngles = {
 A: params.angleA,
 B: params.angleB,
 C: params.angleC
 };
 const knownHeights = {
 ha: params.altitudeA,
 hb: params.altitudeB,
 hc: params.altitudeC
 };
 const knownMedians = {
 ma: params.medianA,
 mb: params.medianB,
 mc: params.medianC
 };
 const knownBisectors = {
 la: params.bisectorA,
 lb: params.bisectorB,
 lc: params.bisectorC
 };
 // 1. Check and
 if (params.sideAB && params.sideBC && params.sideAC) {
 const a = params.sideBC;
 const b = params.sideAC;
 const c = params.sideAB;
 const triangleInequality1 = a + b > c;
 const triangleInequality2 = a + c > b;
 const triangleInequality3 = b + c > a;
 if (!triangleInequality1) {
 checks.push({
 type: 'error',
 message: `Triangle inequality violated: a(${a.toFixed(3)}) + b(${b.toFixed(3)}) > c(${c.toFixed(3)})`
 });
 }
 if (!triangleInequality2) {
 checks.push({
 type: 'error',
 message: `Triangle inequality violated: a(${a.toFixed(3)}) + c(${c.toFixed(3)}) > b(${b.toFixed(3)})`
 });
 }
 if (!triangleInequality3) {
 checks.push({
 type: 'error',
 message: `Triangle inequality violated: b(${b.toFixed(3)}) + c(${c.toFixed(3)}) > a(${a.toFixed(3)})`
 });
 }
 }
 // 2. Check
 const definedAngles = [];
 let definedAnglesSum = 0;
 const angleLetters = ['A', 'B', 'C'];
 angleLetters.forEach(letter => {
 const angle = knownAngles[letter];
 if (angle !== undefined) {
 definedAngles.push(letter);
 definedAnglesSum += angle;
 }
 });
 if (definedAngles.length >= 2) {
 if (definedAnglesSum >= 180 - Œµ) {
 checks.push({
 type: 'error',
 message: `Sum of the specified angles (${definedAnglesSum.toFixed(2)}¬∞) must be strictly less than 180¬∞`
 });
 }
 }
 if (definedAngles.length === 3) {
 const angleError = Math.abs(definedAnglesSum - 180);
 if (angleError > 1) {
 checks.push({
 type: 'error',
 message: `Sum of all three angles (${definedAnglesSum.toFixed(2)}¬∞) must be equal to 180¬∞ (¬±1¬∞). Deviation: ${angleError.toFixed(2)}¬∞`
 });
 } else if (angleError > 0.1) {
 checks.push({
 type: 'warning',
 message: `Sum of angles (${definedAnglesSum.toFixed(2)}¬∞) not and from 180¬∞. Deviation: ${angleError.toFixed(2)}¬∞`
 });
 }
 }
 // 3. Check and for and side-andand angle
 const sineLawPairs = [];
 if (knownSides.a && knownAngles.A) sineLawPairs.push({ side: knownSides.a, angle: knownAngles.A, ratio: null });
 if (knownSides.b && knownAngles.B) sineLawPairs.push({ side: knownSides.b, angle: knownAngles.B, ratio: null });
 if (knownSides.c && knownAngles.C) sineLawPairs.push({ side: knownSides.c, angle: knownAngles.C, ratio: null });
 if (sineLawPairs.length >= 2) {
 sineLawPairs.forEach(pair => {
 pair.ratio = pair.side / Math.sin(pair.angle * Math.PI / 180);
 });
 const ratios = sineLawPairs.map(p => p.ratio);
 const maxRatio = Math.max(...ratios);
 const minRatio = Math.min(...ratios);
 const ratioError = (maxRatio - minRatio) / ((maxRatio + minRatio) / 2);
 if (ratioError > 0.1) {
 const ratioStr = sineLawPairs.map(p => p.ratio.toFixed(3)).join(', ');
 checks.push({
 type: 'error',
 message: `Law of sines violated. The ratios side/sin(angle) must be equal. Obtained: ${ratioStr}`
 });
 }
 }
 // 4. Check and altitudes, and and andand
 const vertexChecks = [
 { vertex: 'A', side: 'a', height: knownHeights.ha, median: knownMedians.ma, bisector: knownBisectors.la },
 { vertex: 'B', side: 'b', height: knownHeights.hb, median: knownMedians.mb, bisector: knownBisectors.lb },
 { vertex: 'C', side: 'c', height: knownHeights.hc, median: knownMedians.mc, bisector: knownBisectors.lc }
 ];
 vertexChecks.forEach(check => {
 const sideKey = `side${check.vertex === 'A' ? 'BC' : check.vertex === 'B' ? 'AC' : 'AB'}`;
 const oppositeSide = params[sideKey];
 // Check altitudes
 if (check.height && oppositeSide) {
 if (check.height > oppositeSide + Œµ) {
 checks.push({
 type: 'error',
 message: `Height from vertex ${check.vertex} (${check.height.toFixed(3)}) cannot be greater than the opposite side (${oppositeSide.toFixed(3)})`
 });
 }
 // must be positive
 if (check.height <= 0) {
 checks.push({
 type: 'error',
 message: `Height from vertex ${check.vertex} (${check.height.toFixed(3)}) must be positive`
 });
 }
 }
 // check: and cannot be smaller than the altitude from the same vertex
 if (check.median && check.height) {
 if (check.median < check.height - Œµ) {
 checks.push({
 type: 'error',
 message: `Median from vertex ${check.vertex} (${check.median.toFixed(3)}) cannot be smaller than the altitude from the same vertex (${check.height.toFixed(3)}). In any triangle, a median is always ‚â• the altitude from the same vertex.`
 });
 }
 }
 // check: andand cannot be smaller than the altitude from the same vertex
 if (check.bisector && check.height) {
 if (check.bisector < check.height - Œµ) {
 checks.push({
 type: 'error',
 message: `Angle bisector from vertex ${check.vertex} (${check.bisector.toFixed(3)}) cannot be smaller than the altitude from the same vertex (${check.height.toFixed(3)}). In any triangle, an angle bisector is always ‚â• the altitude from the same vertex.`
 });
 }
 }
 // Check: and not and sides
 if (check.median && knownSides.b && knownSides.c && check.vertex === 'A') {
 const maxMedian = 0.5 * (knownSides.b + knownSides.c);
 if (check.median > maxMedian + Œµ) {
 checks.push({
 type: 'error',
 message: `Median from vertex A (${check.median.toFixed(3)}) cannot exceed half the sum of the other two sides b and c (${maxMedian.toFixed(3)})`
 });
 }
 }
 if (check.median && knownSides.a && knownSides.c && check.vertex === 'B') {
 const maxMedian = 0.5 * (knownSides.a + knownSides.c);
 if (check.median > maxMedian + Œµ) {
 checks.push({
 type: 'error',
 message: `Median from vertex B (${check.median.toFixed(3)}) cannot exceed half the sum of the other two sides a and c (${maxMedian.toFixed(3)})`
 });
 }
 }
 if (check.median && knownSides.a && knownSides.b && check.vertex === 'C') {
 const maxMedian = 0.5 * (knownSides.a + knownSides.b);
 if (check.median > maxMedian + Œµ) {
 checks.push({
 type: 'error',
 message: `Median from vertex C (${check.median.toFixed(3)}) cannot exceed half the sum of the other two sides a and b (${maxMedian.toFixed(3)})`
 });
 }
 }
 });
 // 5. Check and
 if (params.inradius && params.circumradius) {
 if (params.inradius > params.circumradius) {
 checks.push({
 type: 'error',
 message: `Inradius and (${params.inradius.toFixed(3)}) cannot be greater than the circumradius (${params.circumradius.toFixed(3)})`
 });
 }
 // For an acute triangle: R ‚â• 2r
 if (params.inradius > 0 && params.circumradius > 0) {
 if (params.circumradius < 2 * params.inradius) {
 // and, not and andto
 let isObtuse = false;
 if (params.angleA > 90 || params.angleB > 90 || params.angleC > 90) {
 isObtuse = true;
 }
 if (!isObtuse) {
 checks.push({
 type: 'warning',
 message: `For an acute triangle R ‚â• 2r. You have R=${params.circumradius.toFixed(3)}, r=${params.inradius.toFixed(3)}`
 });
 }
 }
 }
 }
 // 6. Check and
 if (params.area) {
 if (params.area <= 0) {
 checks.push({
 type: 'error',
 message: `Area (${params.area.toFixed(3)}) must be positive`
 });
 }
 // and ,
 if (params.sideAB && params.sideBC && params.sideAC) {
 const a = params.sideBC;
 const b = params.sideAC;
 const c = params.sideAB;
 const p = (a + b + c) / 2;
 const heronArea = Math.sqrt(p * (p - a) * (p - b) * (p - c));
 if (heronArea > 0) {
 const areaError = Math.abs(params.area - heronArea) / params.area;
 if (areaError > 0.1) {
 checks.push({
 type: 'error',
 message: `Specified area (${params.area.toFixed(3)}) does not match the Heron area (${heronArea.toFixed(3)})`
 });
 }
 }
 }
 }
 // 7. Check and
 if (params.sideAB && params.sideBC && params.angleC) {
 const c = params.sideAB;
 const a = params.sideBC;
 const Œ≥ = params.angleC * Math.PI / 180;
 const b_calculated = Math.sqrt(a*a + c*c - 2*a*c*Math.cos(Œ≥));
 if (params.sideAC && Math.abs(params.sideAC - b_calculated) / Math.max(params.sideAC, b_calculated) > 0.1) {
 checks.push({
 type: 'error',
 message: `Side AC (${params.sideAC.toFixed(3)}) does not match the law of cosines. Should be ‚âà ${b_calculated.toFixed(3)}`
 });
 }
 }
 if (params.sideBC && params.sideAC && params.angleA) {
 const a = params.sideBC;
 const b = params.sideAC;
 const Œ± = params.angleA * Math.PI / 180;
 const c_calculated = Math.sqrt(a*a + b*b - 2*a*b*Math.cos(Œ±));
 if (params.sideAB && Math.abs(params.sideAB - c_calculated) / Math.max(params.sideAB, c_calculated) > 0.1) {
 checks.push({
 type: 'error',
 message: `Side AB (${params.sideAB.toFixed(3)}) does not match the law of cosines. Should be ‚âà ${c_calculated.toFixed(3)}`
 });
 }
 }
 if (params.sideAB && params.sideAC && params.angleB) {
 const c = params.sideAB;
 const b = params.sideAC;
 const Œ≤ = params.angleB * Math.PI / 180;
 const a_calculated = Math.sqrt(b*b + c*c - 2*b*c*Math.cos(Œ≤));
 if (params.sideBC && Math.abs(params.sideBC - a_calculated) / Math.max(params.sideBC, a_calculated) > 0.1) {
 checks.push({
 type: 'error',
 message: `Side BC (${params.sideBC.toFixed(3)}) does not match the law of cosines. Should be ‚âà ${a_calculated.toFixed(3)}`
 });
 }
 }
 // 8. Check on andto
 if (definedAngles.length === 3) {
 if (params.angleA < 1 || params.angleB < 1 || params.angleC < 1) {
 checks.push({
 type: 'warning',
 message: 'angles are too small (< 1¬∞), triangle is nearly degenerate'
 });
 }
 if (params.angleA > 179 || params.angleB > 179 || params.angleC > 179) {
 checks.push({
 type: 'warning',
 message: 'angles are too close to 180¬∞, triangle is nearly degenerate'
 });
 }
 }
 // 9. and and for and
 if (params.circumradius && params.inradius) {
 // for an equilateral triangle: R = 2r
 const ratio = params.circumradius / params.inradius;
 if (Math.abs(ratio - 2) < 0.01) {
 // and, and and this and andto
 if (params.angleA && params.angleB && params.angleC) {
 const isEquilateral = Math.abs(params.angleA - 60) < 1 &&
 Math.abs(params.angleB - 60) < 1 &&
 Math.abs(params.angleC - 60) < 1;
 if (!isEquilateral) {
 checks.push({
 type: 'warning',
 message: `Ratio R/r ‚âà 2 is characteristic of an equilateral triangle, but the specified angles are not 60¬∞`
 });
 }
 }
 }
 }
 // 10. Check on "not" andandand altitudes
 if (knownHeights.ha && knownHeights.hb && knownHeights.hc) {
 // for and not:
 // 1/h‚Çê + 1/h’¢ > 1/hùí∏ and ..
 const invSumAB = 1/knownHeights.ha + 1/knownHeights.hb;
 const invC = 1/knownHeights.hc;
 if (invSumAB <= invC + Œµ) {
 checks.push({
 type: 'error',
 message: `Infeasible altitude relation: 1/h‚Çê + 1/h’¢ > 1/hùí∏ is not satisfied`
 });
 }
 }
 return {
 passed: !checks.some(c => c.type === 'error'),
 warnings: checks.filter(c => c.type === 'warning'),
 errors: checks.filter(c => c.type === 'error'),
 allChecks: checks
 };
 }
 // ========== check ==========
 function checkPracticalFeasibility(params) {
 const Œµ = 0.1; // and andand
 const warnings = [];
 const errors = [];
 // Check on and angles
 ['angleA', 'angleB', 'angleC'].forEach(angleKey => {
 if (params[angleKey]) {
 const angle = params[angleKey];
 if (angle < Œµ) {
 errors.push(`angle ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) is too small (<${Œµ}¬∞)`);
 } else if (angle > 180 - Œµ) {
 errors.push(`angle ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) is too close to 180¬∞`);
 } else if (angle < 1) {
 warnings.push(`angle ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) is very small, numerical errors may occur`);
 } else if (angle > 179) {
 warnings.push(`angle ${angleKey.replace('angle', '')} (${angle.toFixed(2)}¬∞) is very close to 180¬∞, numerical errors may occur`);
 }
 }
 });
 // Check on and and
 if (params.inradius && params.circumradius) {
 const ratio = params.inradius / params.circumradius;
 if (ratio > 0.9) {
 warnings.push(`Ratio r/R (${ratio.toFixed(3)}) and and to 1, triangle is nearly degenerate`);
 }
 if (ratio < 0.001) {
 warnings.push(`Ratio r/R (${ratio.toFixed(6)}) is too small, numerical errors may occur`);
 }
 }
 // Check and sides
 if (params.sideAB && params.sideBC && params.sideAC) {
 const sides = [params.sideBC, params.sideAC, params.sideAB];
 const maxSide = Math.max(...sides);
 const minSide = Math.min(...sides);
 const ratio = maxSide / minSide;
 if (ratio > 100) {
 warnings.push(`Side ratio and (${ratio.toFixed(1)}:1), numerical errors may occur`);
 } else if (ratio > 50) {
 warnings.push(`Side ratio very (${ratio.toFixed(1)}:1)`);
 }
 }
 // Check on is very smalland and
 Object.entries(params).forEach(([key, value]) => {
 if (value && Math.abs(value) < 1e-6 && !key.includes('angle')) {
 warnings.push(`Parameter ${getParameterName(key)} (${value.toExponential(2)}) is too small for andand`);
 }
 if (value && Math.abs(value) > 1e6) {
 warnings.push(`Parameter ${getParameterName(key)} (${value.toExponential(2)}) very for andand`);
 }
 });
 return {
 feasible: errors.length === 0,
 errors: errors,
 warnings: warnings,
 allIssues: [...errors, ...warnings]
 };
 }
 // ========== ==========
 // for and and SA
 class AutoSAConfigurator {
 static analyzeProblem(targetParams) {
 const analysis = {
 // and
 complexity: this.estimateComplexity(targetParams),
 // and
 hasAngles: this.hasParameterType(targetParams, 'angle'),
 hasSides: this.hasParameterType(targetParams, 'side'),
 hasSpecial: this.hasSpecialParameters(targetParams),
 // and
 valueRanges: this.getValueRanges(targetParams),
 // and and
 expectedBehavior: this.predictBehavior(targetParams)
 };
 return analysis;
 }
 static estimateComplexity(params) {
 let score = 0;
 const weights = {
 angle: 1, //
 side: 2, // and
 area: 3, //
 radius: 3, //
 altitude: 4, // very
 median: 5, // very
 bisector: 6 //
 };
 Object.keys(params).forEach(key => {
 const type = this.getParamType(key);
 score += weights[type] || 2;
 });
 if (score <= 4) return 'low';
 if (score <= 8) return 'medium';
 return 'high';
 }
 static getParamType(key) {
 if (key.includes('angle')) return 'angle';
 if (key.includes('side')) return 'side';
 if (key.includes('altitude')) return 'altitude';
 if (key.includes('median')) return 'median';
 if (key.includes('bisector')) return 'bisector';
 if (key === 'area') return 'area';
 if (key === 'inradius' || key === 'circumradius') return 'radius';
 return 'other';
 }
 static hasParameterType(params, type) {
 return Object.keys(params).some(key => this.getParamType(key) === type);
 }
 static hasSpecialParameters(params) {
 return Object.keys(params).some(key =>
 this.getParamType(key) === 'altitude' ||
 this.getParamType(key) === 'median' ||
 this.getParamType(key) === 'bisector'
 );
 }
 static getValueRanges(params) {
 const ranges = {};
 Object.keys(params).forEach(key => {
 ranges[key] = {
 value: params[key],
 type: this.getParamType(key),
 normalized: this.normalizeValue(key, params[key])
 };
 });
 return ranges;
 }
 static normalizeValue(key, value) {
 if (key.includes('angle')) {
 return value / 180; // andand
 } else if (key === 'circumradius') {
 return value / 5.0; // and and in andnot
 } else if (key.includes('side')) {
 return value / 5.0; // and side
 }
 return value / 10.0; // and
 }
 static predictBehavior(params) {
 // , "and"
 let sensitivity = 0;
 let nonlinearity = 0;
 if (this.hasSpecialParameters(params)) {
 sensitivity += 2; // and andandand and
 nonlinearity += 1;
 }
 if (this.hasParameterType(params, 'angle') && this.hasParameterType(params, 'side')) {
 sensitivity += 1; // and not
 }
 return {
 sensitivity: Math.min(3, sensitivity),
 nonlinearity: Math.min(2, nonlinearity),
 expectedStagnation: sensitivity > 1 ? 'high' : 'low'
 };
 }
 static generateConfig(analysis, timeBudgetMs = 5000) {
 const baseConfig = {
 // SA
 initialTemperature: 1000,
 coolingSchedule: 'exponential',
 coolingRate: 0.985,
 minTemperature: 0.01,
 maxIterations: 10000,
 // Parameter and
 markovChainLength: 100,
 innerIterations: 10,
 // (in and for , and for and)
 stepSizes: {
 Œ±: 0.15, // ~8.6¬∞
 Œ≤: 0.15,
 R: 0.08 // 8% from and
 },
 // and
 adaptiveSteps: true,
 adaptationRate: 0.99,
 minStepSize: 0.001,
 // and
 enableRestarts: true,
 restartAfterStagnation: 500,
 restartProbability: 0.3,
 // and
 localRefinement: true,
 refinementThreshold: 2.0
 };
 // and on and
 switch (analysis.complexity) {
 case 'low':
 baseConfig.initialTemperature = 500;
 baseConfig.coolingRate = 0.96;
 baseConfig.markovChainLength = 50;
 baseConfig.maxIterations = 3000;
 baseConfig.stepSizes = { Œ±: 0.2, Œ≤: 0.2, R: 0.1 };
 break;
 case 'high':
 baseConfig.initialTemperature = 2000;
 baseConfig.coolingRate = 0.995;
 baseConfig.markovChainLength = 200;
 baseConfig.maxIterations = 20000;
 baseConfig.stepSizes = { Œ±: 0.1, Œ≤: 0.1, R: 0.05 };
 baseConfig.enableRestarts = true;
 baseConfig.restartAfterStagnation = 300;
 break;
 default: // medium
 // and
 break;
 }
 // and andand
 if (analysis.hasSpecial) {
 baseConfig.initialTemperature *= 1.5;
 baseConfig.coolingRate = 0.99;
 baseConfig.markovChainLength = 150;
 }
 if (!analysis.hasAngles && analysis.hasSides) {
 // - and
 baseConfig.stepSizes.Œ± *= 1.5;
 baseConfig.stepSizes.Œ≤ *= 1.5;
 }
 // and and
 const estimatedMsPerIter = 0.3;
 const affordableIterations = timeBudgetMs / estimatedMsPerIter;
 if (affordableIterations < baseConfig.maxIterations) {
 baseConfig.maxIterations = Math.floor(affordableIterations * 0.9);
 // and for and
 baseConfig.coolingRate = Math.max(0.95, baseConfig.coolingRate * 0.99);
 }
 return baseConfig;
 }
 static calibrateInitialTemperature(targetParams, samples = 20) {
 // and
 let totalPositiveDelta = 0;
 let positiveCount = 0;
 const currentState = {
 Œ±: Math.random() * Math.PI,
 Œ≤: Math.random() * Math.PI,
 R: 1.0
 };
 currentState.params = calculateAllParamsFromAngles(currentState.Œ±, currentState.Œ≤, currentState.R);
 currentState.error = calculateErrorWithScale(currentState.params, targetParams);
 for (let i = 0; i < samples; i++) {
 const neighbor = this.generateRandomNeighbor(currentState, { Œ±: 0.2, Œ≤: 0.2, R: 0.1 });
 neighbor.params = calculateAllParamsFromAngles(neighbor.Œ±, neighbor.Œ≤, neighbor.R);
 neighbor.error = calculateErrorWithScale(neighbor.params, targetParams);
 const delta = neighbor.error - currentState.error;
 if (delta > 0) {
 totalPositiveDelta += delta;
 positiveCount++;
 }
 }
 if (positiveCount === 0) return 1000; // Value and
 const avgPositiveDelta = totalPositiveDelta / positiveCount;
 // ~80% and andand not and
 const desiredAcceptance = 0.8;
 const T0 = -avgPositiveDelta / Math.log(desiredAcceptance);
 return Math.max(100, Math.min(5000, T0));
 }
 static generateRandomNeighbor(state, stepSizes) {
 const neighbor = { ...state };
 // and and
 neighbor.Œ± += (Math.random() - 0.5) * 2 * stepSizes.Œ±;
 neighbor.Œ≤ += (Math.random() - 0.5) * 2 * stepSizes.Œ≤;
 neighbor.R += (Math.random() - 0.5) * 2 * stepSizes.R;
 // andand
 neighbor.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, neighbor.Œ±));
 neighbor.Œ≤ = Math.max(0.01, Math.min(Math.PI - neighbor.Œ± - 0.01, neighbor.Œ≤));
 neighbor.R = Math.max(0.001, Math.min(10.0, neighbor.R));
 return neighbor;
 }
 }
 // and and
 class AdaptiveSimulatedAnnealing {
 constructor(targetParams, progressCallback) {
 this.targetParams = targetParams;
 this.progressCallback = progressCallback;
 // and and and
 this.analysis = AutoSAConfigurator.analyzeProblem(targetParams);
 this.config = AutoSAConfigurator.generateConfig(this.analysis);
 // and
 this.config.initialTemperature = AutoSAConfigurator.calibrateInitialTemperature(targetParams);
 // andandandand
 this.currentState = this.initializeState();
 this.bestState = { ...this.currentState };
 this.temperature = this.config.initialTemperature;
 // andand
 this.iterations = 0;
 this.acceptedMoves = 0;
 this.improvements = 0;
 this.stagnationCounter = 0;
 this.lastImprovementIteration = 0;
 // and
 this.currentStepSizes = { ...this.config.stepSizes };
 this.acceptanceHistory = [];
 }
 initializeState() {
 // and andandandandandand
 const strategies = [
 // Equilateral
 () => ({ Œ±: Math.PI/3, Œ≤: Math.PI/3, R: 1.0 }),
 // Right
 () => ({ Œ±: Math.PI/2, Œ≤: Math.PI/4, R: 1.0 }),
 //
 () => ({ Œ±: Math.PI*0.4, Œ≤: Math.PI*0.4, R: 1.0 }),
 //
 () => ({
 Œ±: 0.1 + Math.random() * (Math.PI - 0.2),
 Œ≤: 0.1 + Math.random() * (Math.PI - 0.2),
 R: 0.5 + Math.random() * 2.0
 })
 ];
 // and and
 const initFunc = strategies[Math.floor(Math.random() * strategies.length)];
 const state = initFunc();
 // and and
 state.Œ≤ = Math.min(state.Œ≤, Math.PI - state.Œ± - 0.01);
 state.R = Math.max(0.1, Math.min(5.0, state.R));
 // and and
 state.params = calculateAllParamsFromAngles(state.Œ±, state.Œ≤, state.R);
 state.error = calculateErrorWithScale(state.params, this.targetParams);
 return state;
 }
 generateNeighbor() {
 const neighbor = AutoSAConfigurator.generateRandomNeighbor(this.currentState, this.currentStepSizes);
 neighbor.params = calculateAllParamsFromAngles(neighbor.Œ±, neighbor.Œ≤, neighbor.R);
 neighbor.error = calculateErrorWithScale(neighbor.params, this.targetParams);
 return neighbor;
 }
 acceptanceProbability(deltaError) {
 if (deltaError < 0) return 1.0;
 return Math.exp(-deltaError / this.temperature);
 }
 coolDown() {
 // notand and
 this.temperature *= this.config.coolingRate;
 // not and andand
 if (this.temperature < this.config.minTemperature) {
 this.temperature = this.config.minTemperature;
 }
 }
 adaptStepSizes() {
 if (!this.config.adaptiveSteps) return;
 // andand andand andand and
 const recentAcceptance = this.getRecentAcceptanceRate();
 if (recentAcceptance < 0.2) {
 // and andand - and
 this.currentStepSizes.Œ± *= 0.9;
 this.currentStepSizes.Œ≤ *= 0.9;
 this.currentStepSizes.R *= 0.9;
 } else if (recentAcceptance > 0.6) {
 // and andand - andand and
 this.currentStepSizes.Œ± = Math.min(0.5, this.currentStepSizes.Œ± * 1.1);
 this.currentStepSizes.Œ≤ = Math.min(0.5, this.currentStepSizes.Œ≤ * 1.1);
 this.currentStepSizes.R = Math.min(0.3, this.currentStepSizes.R * 1.1);
 }
 // andand
 this.currentStepSizes.Œ± = Math.max(this.config.minStepSize, this.currentStepSizes.Œ±);
 this.currentStepSizes.Œ≤ = Math.max(this.config.minStepSize, this.currentStepSizes.Œ≤);
 this.currentStepSizes.R = Math.max(this.config.minStepSize * 0.5, this.currentStepSizes.R);
 }
 getRecentAcceptanceRate() {
 const historyLength = Math.min(100, this.acceptanceHistory.length);
 if (historyLength === 0) return 0.5;
 const recent = this.acceptanceHistory.slice(-historyLength);
 return recent.filter(a => a).length / historyLength;
 }
 checkForRestart() {
 if (!this.config.enableRestarts) return false;
 const stagnation = this.iterations - this.lastImprovementIteration;
 if (stagnation < this.config.restartAfterStagnation) return false;
 // andand
 const restartProb = this.config.restartProbability *
 (stagnation / this.config.restartAfterStagnation);
 return Math.random() < restartProb;
 }
 performRestart() {
 // and
 const savedBest = { ...this.bestState };
 // and
 this.currentState = this.initializeState();
 // and (not )
 this.temperature = Math.max(
 this.config.minTemperature * 10,
 this.temperature * 2.0
 );
 // andtoand
 this.stagnationCounter = 0;
 this.acceptanceHistory = [];
 // and and, and
 if (savedBest.error < this.currentState.error) {
 this.currentState = { ...savedBest };
 this.bestState = { ...savedBest };
 }
 return true;
 }
 localRefinement(state) {
 // notand and and and
 if (!this.config.localRefinement || !Number.isFinite(state.error) || state.error > this.config.refinementThreshold) {
 return state;
 }
 // or andand
 const EPS = 1e-12;
 const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
 // and (Œ±, Œ≤, logR) -> error
 const objective = (x) => {
 let Œ± = x[0], Œ≤ = x[1];
 const logR = x[2];
 if (!Number.isFinite(Œ±) || !Number.isFinite(Œ≤) || !Number.isFinite(logR)) return Infinity;
 // andand and: Œ±>0, Œ≤>0, Œ≥>0
 const lim = Math.PI - 1e-9;
 Œ± = clamp(Œ±, 1e-9, lim);
 Œ≤ = clamp(Œ≤, 1e-9, lim);
 if (Œ± + Œ≤ >= lim) {
 // ¬´and¬ª in and
 const scale = (lim - 1e-9) / (Œ± + Œ≤);
 Œ± *= scale;
 Œ≤ *= scale;
 }
 const R = Math.exp(logR);
 if (!Number.isFinite(R) || R <= 0) return Infinity;
 const params = calculateAllParamsFromAngles(Œ±, Œ≤, R);
 if (!params) return Infinity;
 const err = calculateErrorWithScale(params, this.targetParams);
 return Number.isFinite(err) ? err : Infinity;
 };
 // Nelder‚ÄìMead ( and notand)
 const nelderMead = (x0, step, maxIter) => {
 const n = x0.length;
 // andandandand and
 const simplex = [];
 simplex.push({ x: x0.slice(), f: objective(x0) });
 for (let i = 0; i < n; i++) {
 const xi = x0.slice();
 xi[i] += step[i];
 simplex.push({ x: xi, f: objective(xi) });
 }
 const Œ±c = 1.0; // reflection
 const Œ≥c = 2.0; // expansion
 const œÅc = 0.5; // contraction
 const œÉc = 0.5; // shrink
 let best = simplex[0];
 for (let iter = 0; iter < maxIter; iter++) {
 simplex.sort((a, b) => a.f - b.f);
 if (simplex[0].f < best.f) best = { x: simplex[0].x.slice(), f: simplex[0].f };
 // andand : ¬´andandon¬ª f
 const f0 = simplex[0].f, fn = simplex[n].f;
 if (Number.isFinite(f0) && Number.isFinite(fn) && Math.abs(fn - f0) < 1e-12) break;
 if (best.f < 1e-8) break;
 // and and
 const centroid = new Array(n).fill(0);
 for (let i = 0; i < n; i++) {
 for (let j = 0; j < n; j++) centroid[j] += simplex[i].x[j];
 }
 for (let j = 0; j < n; j++) centroid[j] /= n;
 const worst = simplex[n];
 const secondWorst = simplex[n - 1];
 // and
 const xr = centroid.map((c, j) => c + Œ±c * (c - worst.x[j]));
 const fr = objective(xr);
 if (fr < simplex[0].f) {
 // andand
 const xe = centroid.map((c, j) => c + Œ≥c * (xr[j] - c));
 const fe = objective(xe);
 simplex[n] = (fe < fr) ? { x: xe, f: fe } : { x: xr, f: fr };
 continue;
 }
 if (fr < secondWorst.f) {
 simplex[n] = { x: xr, f: fr };
 continue;
 }
 // and
 let xc;
 if (fr < worst.f) {
 // innotnot
 xc = centroid.map((c, j) => c + œÅc * (xr[j] - c));
 } else {
 // not
 xc = centroid.map((c, j) => c - œÅc * (c - worst.x[j]));
 }
 const fc = objective(xc);
 if (fc < worst.f) {
 simplex[n] = { x: xc, f: fc };
 continue;
 }
 // and and to
 const bestX = simplex[0].x;
 for (let i = 1; i < simplex.length; i++) {
 const xs = bestX.map((bx, j) => bx + œÉc * (simplex[i].x[j] - bx));
 simplex[i] = { x: xs, f: objective(xs) };
 }
 }
 // and best
 simplex.sort((a, b) => a.f - b.f);
 return (simplex[0].f < best.f) ? simplex[0] : best;
 };
 // : and
 const xStart = [state.Œ±, state.Œ≤, Math.log(Math.max(state.R, 1e-12))];
 // and (and from )
 const baseStep = [
 Math.max(1e-4, Math.abs(state.Œ±) * 1e-3),
 Math.max(1e-4, Math.abs(state.Œ≤) * 1e-3),
 1e-3
 ];
 let bestNM = nelderMead(xStart, baseStep, 700);
 // and (for and andand)
 const restarts = 10;
 for (let k = 0; k < restarts; k++) {
 const s = Math.exp(-k / 3);
 const x0 = [
 bestNM.x[0] + (Math.random() * 2 - 1) * baseStep[0] * 10 * s,
 bestNM.x[1] + (Math.random() * 2 - 1) * baseStep[1] * 10 * s,
 bestNM.x[2] + (Math.random() * 2 - 1) * baseStep[2] * 5 * s
 ];
 const step = [baseStep[0] * 5 * s, baseStep[1] * 5 * s, baseStep[2] * 2 * s];
 const cand = nelderMead(x0, step, 450);
 if (cand.f < bestNM.f) bestNM = cand;
 if (bestNM.f < 1e-8) break;
 }
 // and or ‚Äî state
 if (Number.isFinite(bestNM.f) && bestNM.f + 1e-15 < state.error) {
 const Œ± = bestNM.x[0], Œ≤ = bestNM.x[1], R = Math.exp(bestNM.x[2]);
 const params = calculateAllParamsFromAngles(Œ±, Œ≤, R);
 const improved = {
 ...state,
 Œ±, Œ≤, R,
 params,
 error: bestNM.f
 };
 return improved;
 }
 return state;
 }
 async optimize() {
 const startTime = Date.now();
 let lastProgressUpdate = 0;
 for (this.iterations = 0; this.iterations < this.config.maxIterations; this.iterations++) {
 // Check
 if (this.checkForRestart()) {
 this.performRestart();
 continue;
 }
 // notand not and
 const neighbor = this.generateNeighbor();
 // andand andnotand andand
 const deltaError = neighbor.error - this.currentState.error;
 // and and
 const acceptanceProb = this.acceptanceProbability(deltaError);
 const accepted = deltaError < 0 || Math.random() < acceptanceProb;
 // and in andand
 this.acceptanceHistory.push(accepted);
 if (this.acceptanceHistory.length > 1000) {
 this.acceptanceHistory.shift();
 }
 if (accepted) {
 this.acceptedMoves++;
 this.currentState = neighbor;
 // Check on and
 if (this.currentState.error < this.bestState.error) {
 this.bestState = { ...this.currentState };
 this.improvements++;
 this.lastImprovementIteration = this.iterations;
 this.stagnationCounter = 0;
 } else {
 this.stagnationCounter++;
 }
 }
 // and
 this.coolDown();
 // and
 if (this.iterations % 100 === 0) {
 this.adaptStepSizes();
 }
 //
 const currentTime = Date.now();
 if (currentTime - lastProgressUpdate > 100) { // not in 100
 const progress = (this.iterations / this.config.maxIterations) * 100;
 this.progressCallback(progress, this.iterations, this.bestState.error);
 lastProgressUpdate = currentTime;
 }
 // Check andand and
 if (this.shouldStop()) {
 break;
 }
 // for notand UI
 if (this.iterations % 100 === 0) {
 await new Promise(resolve => setTimeout(resolve, 0));
 }
 }
 // and andandand
 this.bestState = this.localRefinement(this.bestState);
 // and
 const totalTime = Date.now() - startTime;
 this.progressCallback(100, this.iterations, this.bestState.error);
 return {
 state: this.bestState,
 stats: {
 iterations: this.iterations,
 acceptedMoves: this.acceptedMoves,
 improvements: this.improvements,
 finalTemperature: this.temperature,
 finalError: this.bestState.error,
 totalTime: totalTime,
 config: this.config
 }
 };
 }
 shouldStop() {
 // 1. and
 if (this.bestState.error < 1e-6) return true;
 // 2. and and for andnotand
 if (this.temperature < this.config.minTemperature * 10) {
 const recentAcceptance = this.getRecentAcceptanceRate();
 if (recentAcceptance < 0.01) return true;
 }
 // 3. and not and
 const stagnation = this.iterations - this.lastImprovementIteration;
 if (stagnation > this.config.maxIterations * 0.5) return true;
 return false;
 }
 }
 // ========== ==========
 async function optimizeTriangleWithSimulatedAnnealing(targetParams, progressCallback) {
 try {
 showStatusMessage(' and and...', 'info');
 // and and and and
 const sa = new AdaptiveSimulatedAnnealing(targetParams, progressCallback);
 const result = await sa.optimize();
 // and in
 const solution = {
 points: calculateTrianglePoints(result.state.Œ±, result.state.Œ≤, result.state.R),
 params: result.state.params,
 scale: result.state.R,
 angles: {
 Œ±: result.state.Œ± * 180 / Math.PI,
 Œ≤: result.state.Œ≤ * 180 / Math.PI,
 Œ≥: (Math.PI - result.state.Œ± - result.state.Œ≤) * 180 / Math.PI
 },
 type: determineTriangleType(result.state.params),
 error: result.state.error,
 iterations: result.stats.iterations,
 stats: result.stats
 };
 // andand andandand
 solution.metadata = {
 algorithm: 'Adaptive Simulated Annealing',
 config: result.stats.config,
 autoConfigured: true,
 complexity: sa.analysis.complexity
 };
 // ====== andand ( and) ======
 try {
 await progressCallback(95, result.iteration || 0, result.state.error, " notand...");
 const hpSolution = await optimizeTriangleHighPrecision(targetParams, progressCallback, result.state);
 if (hpSolution && Number.isFinite(hpSolution.error) && hpSolution.error < solution.error) {
 // and on
 solution.points = hpSolution.points;
 solution.params = hpSolution.params;
 solution.scale = hpSolution.scale;
 solution.angles = hpSolution.angles;
 solution.type = hpSolution.type;
 solution.error = hpSolution.error;
 solution.metadata = Object.assign({}, solution.metadata, { refined: true, refinement: 'HighPrecision (Nelder-Mead + LM + golden)' });
 }
 } catch (refineErr) {
 console.warn(' notand not notbut:', refineErr);
 }
 showStatusMessage(`and and : ${result.stats.iterations} andand, ${(100 - result.state.error * 100).toFixed(2)}%`, 'success');
 return solution;
 } catch (error) {
 console.error('and in and and:', error);
 throw error;
 }
 }
 // ========== ( and) ==========
 class HighPrecisionOptimizer {
 constructor(targetParams, progressCallback, seedState = null) {
 this.targetParams = targetParams;
 this.progressCallback = progressCallback;
 this.seedState = seedState;
 this.bestSolution = null;
 this.bestError = Infinity;
 this.stats = {
 totalIterations: 0,
 startTime: Date.now(),
 convergenceHistory: []
 };
 }
 async optimize() {
 try {
 // 0: check and andandand (10%)
 await this.progressCallback(5, 0, Infinity, "andandandand...");
 const initialGuess = this.generateInitialGuesses();
 // 1: and -and (30%)
 await this.progressCallback(10, 0, Infinity, " and...");
 const nmSolutions = await this.nelderMeadMultiStart(initialGuess, 20);
 // 2: notand - (40%)
 await this.progressCallback(40, 0, nmSolutions.bestError, " andandand...");
 const lmSolution = await this.levenbergMarquardt(nmSolutions.bestState, 30);
 // 3: and-andand and (15%)
 await this.progressCallback(70, 0, lmSolution.error, "and-andand...");
 const refinedSolution = await this.goldenSectionRefinement(lmSolution, 10);
 // 4: and check and (5%)
 await this.progressCallback(90, 0, refinedSolution.error, "Check and...");
 const finalSolution = await this.finalPrecisionCheck(refinedSolution, 5);
 return this.prepareFinalSolution(finalSolution);
 } catch (error) {
 console.error('and andandandand:', error);
 throw error;
 }
 }
 generateInitialGuesses() {
 const guesses = [];
 // 0. Seed from previous optimizer (if provided)
 if (this.seedState && Number.isFinite(this.seedState.Œ±) && Number.isFinite(this.seedState.Œ≤)) {
 guesses.push({
 Œ±: this.seedState.Œ±,
 Œ≤: this.seedState.Œ≤,
 R: Number.isFinite(this.seedState.R) ? this.seedState.R : 1.0
 });
 }
 // 1. on (and angles)
 if (this.targetParams.angleA && this.targetParams.angleB) {
 guesses.push({
 Œ±: this.targetParams.angleA * Math.PI / 180,
 Œ≤: this.targetParams.angleB * Math.PI / 180,
 R: this.targetParams.circumradius || 1.0
 });
 }
 // 2. Equilateral andto
 guesses.push({
 Œ±: Math.PI/3,
 Œ≤: Math.PI/3,
 R: 1.0
 });
 // 3. Right andto
 guesses.push({
 Œ±: Math.PI/2,
 Œ≤: Math.PI/4,
 R: 1.0
 });
 // 4. and
 for (let i = 0; i < 5; i++) {
 guesses.push({
 Œ±: 0.2 + Math.random() * (Math.PI - 0.4),
 Œ≤: 0.2 + Math.random() * (Math.PI - 0.4),
 R: 0.5 + Math.random() * 2.0
 });
 }
 return guesses;
 }
 async nelderMeadMultiStart(initialGuesses, maxIterations = 100) {
 const solutions = [];
 for (const guess of initialGuesses) {
 const solution = await this.nelderMeadOptimization(guess, maxIterations);
 solutions.push(solution);
 // and and andandand and
 if (solution.error < 1e-8) {
 break;
 }
 }
 // and and
 let bestIndex = 0;
 let bestError = Infinity;
 solutions.forEach((sol, idx) => {
 if (sol.error < bestError) {
 bestError = sol.error;
 bestIndex = idx;
 }
 });
 return {
 bestState: solutions[bestIndex].state,
 bestError: bestError,
 allSolutions: solutions
 };
 }
 async nelderMeadOptimization(initialState, maxIterations) {
 const Œ± = 1.0; // Reflection coefficient
 const Œ≥ = 2.0; // Expansion coefficient
 const œÅ = 0.5; // Contraction coefficient
 const œÉ = 0.5; // Shrink coefficient
 // and
 let simplex = [initialState];
 // and
 for (let i = 0; i < 3; i++) {
 const point = {
 Œ±: Math.max(0.01, Math.min(Math.PI - 0.02, initialState.Œ± + (Math.random() - 0.5) * 0.2)),
 Œ≤: Math.max(0.01, Math.min(Math.PI - initialState.Œ± - 0.01, initialState.Œ≤ + (Math.random() - 0.5) * 0.2)),
 R: Math.max(0.001, Math.min(10.0, initialState.R * (1 + (Math.random() - 0.5) * 0.2)))
 };
 point.params = calculateAllParamsFromAngles(point.Œ±, point.Œ≤, point.R);
 point.error = this.calculateError(point);
 simplex.push(point);
 }
 let iteration = 0;
 while (iteration < maxIterations) {
 iteration++;
 this.stats.totalIterations++;
 // and and and
 simplex.sort((a, b) => a.error - b.error);
 // , and and
 const best = simplex[0];
 const worst = simplex[simplex.length - 1];
 const secondWorst = simplex[simplex.length - 2];
 // and ( and)
 const centroid = this.calculateCentroid(simplex.slice(0, -1));
 // and
 const reflected = this.reflectPoint(worst, centroid, Œ±);
 reflected.error = this.calculateError(reflected);
 if (reflected.error < best.error) {
 // andand
 const expanded = this.reflectPoint(worst, centroid, Œ≥);
 expanded.error = this.calculateError(expanded);
 if (expanded.error < reflected.error) {
 simplex[simplex.length - 1] = expanded;
 } else {
 simplex[simplex.length - 1] = reflected;
 }
 } else if (reflected.error < secondWorst.error) {
 simplex[simplex.length - 1] = reflected;
 } else {
 // and
 if (reflected.error < worst.error) {
 // innotnot and
 const contracted = this.reflectPoint(worst, centroid, œÅ);
 contracted.error = this.calculateError(contracted);
 if (contracted.error < reflected.error) {
 simplex[simplex.length - 1] = contracted;
 } else {
 this.shrinkSimplex(simplex, best, œÉ);
 }
 } else {
 // not and
 const contracted = this.reflectPoint(worst, centroid, -œÅ);
 contracted.error = this.calculateError(contracted);
 if (contracted.error < worst.error) {
 simplex[simplex.length - 1] = contracted;
 } else {
 this.shrinkSimplex(simplex, best, œÉ);
 }
 }
 }
 // and
 if (iteration % 10 === 0) {
 const progress = 10 + (iteration / maxIterations) * 20;
 await this.progressCallback(
 progress,
 iteration,
 best.error,
 `-and: ${best.error.toExponential(3)}`
 );
 // andand and
 const errorRange = simplex[simplex.length - 1].error - simplex[0].error;
 if (errorRange < 1e-12) break;
 }
 }
 simplex.sort((a, b) => a.error - b.error);
 return {
 state: simplex[0],
 error: simplex[0].error,
 iterations: iteration
 };
 }
 async levenbergMarquardt(initialState, maxIterations = 50) {
 let state = { ...initialState };
 let Œª = 0.001; // Parameter andand
 let iteration = 0;
 let prevError = state.error;
 while (iteration < maxIterations) {
 iteration++;
 this.stats.totalIterations++;
 // andand and and not
 const { J, residuals } = this.calculateJacobianAndResiduals(state);
 // andand andandand : H = J·µÄJ + ŒªI
 const JT = this.matrixTranspose(J);
 const JTJ = this.matrixMultiply(JT, J);
 const H = this.addDiagonal(JTJ, Œª);
 // and: g = J·µÄr
 const g = this.matrixVectorMultiply(JT, residuals);
 // and HŒî = -g
 const Œî = this.solveLinearSystem(H, this.vectorNegate(g));
 if (!Œî) {
 Œª *= 10;
 continue;
 }
 //
 const newState = {
 Œ±: state.Œ± + Œî[0],
 Œ≤: state.Œ≤ + Œî[1],
 R: state.R * (1 + Œî[2] * 0.1) // and for and
 };
 // andand
 newState.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, newState.Œ±));
 newState.Œ≤ = Math.max(0.01, Math.min(Math.PI - newState.Œ± - 0.01, newState.Œ≤));
 newState.R = Math.max(0.001, Math.min(10.0, newState.R));
 // and andand
 newState.params = calculateAllParamsFromAngles(newState.Œ±, newState.Œ≤, newState.R);
 newState.error = this.calculateError(newState);
 // and Œª
 if (newState.error < state.error) {
 //
 state = newState;
 Œª *= 0.1;
 prevError = state.error;
 // andand andand
 this.stats.convergenceHistory.push({
 iteration: this.stats.totalIterations,
 error: state.error,
 Œª: Œª
 });
 } else {
 //
 Œª *= 10;
 }
 // and
 if (iteration % 5 === 0) {
 const progress = 40 + (iteration / maxIterations) * 30;
 await this.progressCallback(
 progress,
 iteration,
 state.error,
 `-: ${state.error.toExponential(6)}`
 );
 // andandand and
 if (state.error < 1e-12) break;
 if (Œª > 1e6) break;
 if (Math.abs(prevError - state.error) < 1e-15) break;
 }
 }
 return {
 state: state,
 error: state.error,
 iterations: iteration
 };
 }
 async goldenSectionRefinement(solution, maxIterations = 20) {
 let state = { ...solution.state };
 const œÜ = (1 + Math.sqrt(5)) / 2; // and
 const tolerance = 1e-10;
 //
 // 1. notand Œ±
 let [a, b] = [state.Œ± * 0.999, state.Œ± * 1.001];
 let [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
 for (let i = 0; i < maxIterations; i++) {
 const stateC = { ...state, Œ±: c };
 stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
 stateC.error = this.calculateError(stateC);
 const stateD = { ...state, Œ±: d };
 stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
 stateD.error = this.calculateError(stateD);
 if (stateC.error < stateD.error) {
 b = d;
 } else {
 a = c;
 }
 c = b - (b - a) / œÜ;
 d = a + (b - a) / œÜ;
 if (Math.abs(c - d) < tolerance) break;
 }
 state.Œ± = (a + b) / 2;
 // 2. notand Œ≤
 [a, b] = [state.Œ≤ * 0.999, state.Œ≤ * 1.001];
 [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
 for (let i = 0; i < maxIterations; i++) {
 const stateC = { ...state, Œ≤: c };
 stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
 stateC.error = this.calculateError(stateC);
 const stateD = { ...state, Œ≤: d };
 stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
 stateD.error = this.calculateError(stateD);
 if (stateC.error < stateD.error) {
 b = d;
 } else {
 a = c;
 }
 c = b - (b - a) / œÜ;
 d = a + (b - a) / œÜ;
 if (Math.abs(c - d) < tolerance) break;
 }
 state.Œ≤ = (a + b) / 2;
 // 3. notand R
 [a, b] = [state.R * 0.999, state.R * 1.001];
 [c, d] = [b - (b - a) / œÜ, a + (b - a) / œÜ];
 for (let i = 0; i < maxIterations; i++) {
 const stateC = { ...state, R: c };
 stateC.params = calculateAllParamsFromAngles(stateC.Œ±, stateC.Œ≤, stateC.R);
 stateC.error = this.calculateError(stateC);
 const stateD = { ...state, R: d };
 stateD.params = calculateAllParamsFromAngles(stateD.Œ±, stateD.Œ≤, stateD.R);
 stateD.error = this.calculateError(stateD);
 if (stateC.error < stateD.error) {
 b = d;
 } else {
 a = c;
 }
 c = b - (b - a) / œÜ;
 d = a + (b - a) / œÜ;
 if (Math.abs(c - d) < tolerance) break;
 }
 state.R = (a + b) / 2;
 // and
 state.params = calculateAllParamsFromAngles(state.Œ±, state.Œ≤, state.R);
 state.error = this.calculateError(state);
 return {
 state: state,
 error: state.error
 };
 }
 async finalPrecisionCheck(solution, maxIterations = 10) {
 let state = { ...solution.state };
 let bestState = { ...state };
 let bestError = state.error;
 // and-andand
 for (let i = 0; i < maxIterations; i++) {
 // and-andandand
 const variations = [];
 for (let j = 0; j < 8; j++) {
 const variation = {
 Œ±: state.Œ± * (1 + (Math.random() - 0.5) * 1e-6),
 Œ≤: state.Œ≤ * (1 + (Math.random() - 0.5) * 1e-6),
 R: state.R * (1 + (Math.random() - 0.5) * 1e-6)
 };
 // andand
 variation.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, variation.Œ±));
 variation.Œ≤ = Math.max(0.01, Math.min(Math.PI - variation.Œ± - 0.01, variation.Œ≤));
 variation.R = Math.max(0.001, Math.min(10.0, variation.R));
 variation.params = calculateAllParamsFromAngles(variation.Œ±, variation.Œ≤, variation.R);
 variation.error = this.calculateError(variation);
 variations.push(variation);
 }
 // and andand
 variations.sort((a, b) => a.error - b.error);
 if (variations[0].error < bestError) {
 bestState = variations[0];
 bestError = variations[0].error;
 state = bestState;
 }
 // and
 await this.progressCallback(
 90 + (i / maxIterations) * 5,
 i,
 bestError,
 `and check: ${bestError.toExponential(8)}`
 );
 if (bestError < 1e-12) break;
 }
 return {
 state: bestState,
 error: bestError
 };
 }
 calculateError(state) {
 return calculateErrorWithScale(state.params, this.targetParams);
 }
 calculateCentroid(points) {
 const centroid = { Œ±: 0, Œ≤: 0, R: 0 };
 points.forEach(point => {
 centroid.Œ± += point.Œ±;
 centroid.Œ≤ += point.Œ≤;
 centroid.R += point.R;
 });
 centroid.Œ± /= points.length;
 centroid.Œ≤ /= points.length;
 centroid.R /= points.length;
 return centroid;
 }
 reflectPoint(point, centroid, coefficient) {
 const reflected = {
 Œ±: centroid.Œ± + coefficient * (centroid.Œ± - point.Œ±),
 Œ≤: centroid.Œ≤ + coefficient * (centroid.Œ≤ - point.Œ≤),
 R: centroid.R + coefficient * (centroid.R - point.R)
 };
 // andand
 reflected.Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, reflected.Œ±));
 reflected.Œ≤ = Math.max(0.01, Math.min(Math.PI - reflected.Œ± - 0.01, reflected.Œ≤));
 reflected.R = Math.max(0.001, Math.min(10.0, reflected.R));
 return reflected;
 }
 shrinkSimplex(simplex, best, coefficient) {
 for (let i = 1; i < simplex.length; i++) {
 simplex[i] = {
 Œ±: best.Œ± + coefficient * (simplex[i].Œ± - best.Œ±),
 Œ≤: best.Œ≤ + coefficient * (simplex[i].Œ≤ - best.Œ≤),
 R: best.R + coefficient * (simplex[i].R - best.R)
 };
 // andand
 simplex[i].Œ± = Math.max(0.01, Math.min(Math.PI - 0.02, simplex[i].Œ±));
 simplex[i].Œ≤ = Math.max(0.01, Math.min(Math.PI - simplex[i].Œ± - 0.01, simplex[i].Œ≤));
 simplex[i].R = Math.max(0.001, Math.min(10.0, simplex[i].R));
 simplex[i].params = calculateAllParamsFromAngles(simplex[i].Œ±, simplex[i].Œ≤, simplex[i].R);
 simplex[i].error = this.calculateError(simplex[i]);
 }
 }
 calculateJacobianAndResiduals(state) {
 const paramKeys = Object.keys(this.targetParams);
 const J = [];
 const residuals = [];
 // andandandand and (3 x N)
 for (let i = 0; i < 3; i++) {
 J.push(new Array(paramKeys.length).fill(0));
 }
 const Œ¥ = 1e-7; // very and for and
 const currentParams = state.params;
 paramKeys.forEach((key, col) => {
 const targetValue = this.targetParams[key];
 const currentValue = parseFloat(currentParams[key]);
 // andand notand
 let residual;
 if (key.includes('angle')) {
 const diff = Math.abs(currentValue - targetValue);
 residual = Math.min(diff, 360 - diff) / 180.0;
 } else {
 residual = Math.abs(currentValue - targetValue) / Math.max(Math.abs(targetValue), 1e-10);
 }
 residuals.push(residual);
 // and Œ±
 const stateŒ± = { ...state, Œ±: state.Œ± + Œ¥ };
 stateŒ±.params = calculateAllParamsFromAngles(stateŒ±.Œ±, stateŒ±.Œ≤, stateŒ±.R);
 const valueŒ± = parseFloat(stateŒ±.params[key]);
 J[0][col] = (valueŒ± - currentValue) / Œ¥;
 // and Œ≤
 const stateŒ≤ = { ...state, Œ≤: state.Œ≤ + Œ¥ };
 stateŒ≤.params = calculateAllParamsFromAngles(stateŒ≤.Œ±, stateŒ≤.Œ≤, stateŒ≤.R);
 const valueŒ≤ = parseFloat(stateŒ≤.params[key]);
 J[1][col] = (valueŒ≤ - currentValue) / Œ¥;
 // and R
 const stateR = { ...state, R: state.R * (1 + Œ¥) };
 stateR.params = calculateAllParamsFromAngles(stateR.Œ±, stateR.Œ≤, stateR.R);
 const valueR = parseFloat(stateR.params[key]);
 J[2][col] = (valueR - currentValue) / (Œ¥ * state.R);
 });
 return { J, residuals };
 }
 // and andand
 matrixTranspose(M) {
 const rows = M.length, cols = M[0].length;
 const result = new Array(cols);
 for (let j = 0; j < cols; j++) {
 result[j] = new Array(rows);
 for (let i = 0; i < rows; i++) {
 result[j][i] = M[i][j];
 }
 }
 return result;
 }
 matrixMultiply(A, B) {
 const rowsA = A.length, colsA = A[0].length, colsB = B[0].length;
 const result = new Array(rowsA);
 for (let i = 0; i < rowsA; i++) {
 result[i] = new Array(colsB);
 for (let j = 0; j < colsB; j++) {
 let sum = 0;
 for (let k = 0; k < colsA; k++) {
 sum += A[i][k] * B[k][j];
 }
 result[i][j] = sum;
 }
 }
 return result;
 }
 matrixVectorMultiply(M, v) {
 const rows = M.length;
 const result = new Array(rows);
 for (let i = 0; i < rows; i++) {
 let sum = 0;
 for (let j = 0; j < v.length; j++) {
 sum += M[i][j] * v[j];
 }
 result[i] = sum;
 }
 return result;
 }
 addDiagonal(M, Œª) {
 const n = M.length;
 const result = [];
 for (let i = 0; i < n; i++) {
 result[i] = [...M[i]];
 result[i][i] += Œª;
 }
 return result;
 }
 vectorNegate(v) {
 return v.map(x => -x);
 }
 solveLinearSystem(A, b) {
 const n = A.length;
 const Ab = [];
 // and and
 for (let i = 0; i < n; i++) {
 Ab[i] = [...A[i], b[i]];
 }
 //
 for (let i = 0; i < n; i++) {
 // and and
 let maxRow = i;
 let maxVal = Math.abs(Ab[i][i]);
 for (let j = i + 1; j < n; j++) {
 if (Math.abs(Ab[j][i]) > maxVal) {
 maxRow = j;
 maxVal = Math.abs(Ab[j][i]);
 }
 }
 if (maxVal < 1e-15) return null;
 //
 if (maxRow !== i) {
 [Ab[i], Ab[maxRow]] = [Ab[maxRow], Ab[i]];
 }
 // and
 const pivot = Ab[i][i];
 for (let j = i; j <= n; j++) {
 Ab[i][j] /= pivot;
 }
 // and
 for (let j = i + 1; j < n; j++) {
 const factor = Ab[j][i];
 for (let k = i; k <= n; k++) {
 Ab[j][k] -= factor * Ab[i][k];
 }
 }
 }
 //
 const x = new Array(n);
 for (let i = n - 1; i >= 0; i--) {
 x[i] = Ab[i][n];
 for (let j = i + 1; j < n; j++) {
 x[i] -= Ab[i][j] * x[j];
 }
 }
 return x;
 }
 prepareFinalSolution(solution) {
 const finalPoints = calculateTrianglePoints(solution.state.Œ±, solution.state.Œ≤, solution.state.R);
 const finalSolution = {
 points: finalPoints,
 params: solution.state.params,
 scale: solution.state.R,
 angles: {
 Œ±: solution.state.Œ± * 180 / Math.PI,
 Œ≤: solution.state.Œ≤ * 180 / Math.PI,
 Œ≥: (Math.PI - solution.state.Œ± - solution.state.Œ≤) * 180 / Math.PI
 },
 type: determineTriangleType(solution.state.params),
 error: solution.error,
 iterations: this.stats.totalIterations,
 stats: {
 ...this.stats,
 totalTime: Date.now() - this.stats.startTime,
 finalPrecision: 100 - solution.error * 100
 }
 };
 return finalSolution;
 }
 }
 async function optimizeTriangleHighPrecision(targetParams, progressCallback, seedState = null) {
 showStatusMessage(' and...', 'info');
 const optimizer = new HighPrecisionOptimizer(targetParams,
 async (progress, iteration, error, status) => {
 progressCallback(progress, iteration, error, status);
 }
 , seedState);
 const solution = await optimizer.optimize();
 // and in
 const accuracy = Math.max(0, 100 - solution.error * 100);
 if (accuracy >= 99.999) {
 showStatusMessage(`‚úÖ -: ${accuracy.toFixed(6)}%`, 'success');
 } else if (accuracy >= 99.99) {
 showStatusMessage(`‚úÖ very : ${accuracy.toFixed(4)}%`, 'success');
 } else if (accuracy >= 99.9) {
 showStatusMessage(`‚úÖ : ${accuracy.toFixed(3)}%`, 'success');
 } else if (accuracy >= 99.0) {
 showStatusMessage(`‚ö† : ${accuracy.toFixed(2)}%`, 'warning');
 } else {
 showStatusMessage(`‚ùå : ${accuracy.toFixed(2)}%`, 'error');
 }
 return solution;
 }
 // ========== ==========
 function calculateErrorWithScale(currentParams, targetParams) {
 let totalError = 0;
 let weight = 0;
 const Œµ = 1e-10;
 for (const [key, targetValue] of Object.entries(targetParams)) {
 const currentValue = parseFloat(currentParams[key]);
 if (isNaN(currentValue)) {
 totalError += 1.0;
 weight += 1;
 continue;
 }
 let error;
 if (key.includes('angle')) {
 const diff = Math.abs(currentValue - targetValue);
 error = Math.min(diff, 360 - diff) / 180.0;
 } else if (key === 'circumradius') {
 const denominator = Math.max(Math.abs(targetValue), Œµ);
 error = Math.abs((currentValue - targetValue) / denominator);
 } else {
 const denominator = Math.max(Math.abs(targetValue), Œµ);
 error = Math.abs((currentValue - targetValue) / denominator);
 }
 const paramWeight = key.includes('angle') ? 2.0 :
 key === 'circumradius' ? 4.0 : 1.0;
 totalError += error * paramWeight;
 weight += paramWeight;
 }
 return weight > 0 ? totalError / weight : Infinity;
 }
 // ========== for ==========
 function preValidateParametersEnhanced(params) {
 // check andand
 const compatibility = checkParameterCompatibility(params);
 if (!compatibility.passed) {
 const errorMessages = compatibility.errors.map(e => e.message).join('\n‚Ä¢ ');
 return {
 valid: false,
 message: `Parameter notand:\n‚Ä¢ ${errorMessages}`
 };
 }
 // Check and andand
 const practicalCheck = checkPracticalFeasibility(params);
 if (!practicalCheck.feasible) {
 const errorMessages = practicalCheck.errors.join('\n‚Ä¢ ');
 return {
 valid: false,
 message: `Parameter notand on and:\n‚Ä¢ ${errorMessages}`
 };
 }
 // Check and andand
 const numericalCheck = checkNumericalFeasibility(params);
 if (!numericalCheck.feasible) {
 const errorMessages = numericalCheck.issues.join('\n‚Ä¢ ');
 return {
 valid: false,
 message: `Parameter and notand:\n‚Ä¢ ${errorMessages}`
 };
 }
 // Check on " not" andandand
 const vertexChecks = [
 { v: 'A', h: params.altitudeA, m: params.medianA, b: params.bisectorA },
 { v: 'B', h: params.altitudeB, m: params.medianB, b: params.bisectorB },
 { v: 'C', h: params.altitudeC, m: params.medianC, b: params.bisectorC }
 ];
 for (const check of vertexChecks) {
 // and and and altitudes
 if (check.m && check.h && check.m < check.h) {
 return {
 valid: false,
 message: `Median from vertex ${check.v} (${check.m.toFixed(3)}) altitudes (${check.h.toFixed(3)}). this not in and.`
 };
 }
 // and andand and altitudes
 if (check.b && check.h && check.b < check.h) {
 return {
 valid: false,
 message: `Angle bisector from vertex ${check.v} (${check.b.toFixed(3)}) altitudes (${check.h.toFixed(3)}). this not in and.`
 };
 }
 }
 // Check on and and/and and
 const maxReasonableValue = 1e6;
 const minReasonableValue = 1e-6;
 for (const [key, value] of Object.entries(params)) {
 if (value !== undefined) {
 if (Math.abs(value) > maxReasonableValue) {
 return {
 valid: false,
 message: `Parameter ${getParameterName(key)} (${value.toExponential(2)}) and for and andand`
 };
 }
 if (Math.abs(value) < minReasonableValue && !key.includes('angle')) {
 return {
 valid: false,
 message: `Parameter ${getParameterName(key)} (${value.toExponential(2)}) is too small for and andand`
 };
 }
 }
 }
 // and and
 const allWarnings = [
 ...compatibility.warnings.map(w => w.message),
 ...practicalCheck.warnings,
 ...numericalCheck.issues.filter(issue => !issue.includes('and') && !issue.includes('notand'))
 ];
 if (allWarnings.length > 0) {
 return {
 valid: true,
 message: 'Parameter and ',
 warnings: allWarnings
 };
 }
 return {
 valid: true,
 message: 'Parameter and '
 };
 }
 // ========== ==========
 function showErrorMessage(message, persist = false) {
 const errorDiv = document.getElementById('errorMessage');
 errorDiv.innerHTML = `
 <div style="display: flex; align-items: flex-start; gap: 10px;">
 <span style="font-size: 20px; color: #e74c3c;">‚ùå</span>
 <div style="flex: 1;">
 <strong style="color: #e74c3c;">and:</strong>
 <div style="white-space: pre-line; margin-top: 5px;">${message}</div>
 </div>
 ${persist ? '<button onclick="hideErrorMessage()" style="background: none; border: none; color: #e74c3c; cursor: pointer; font-size: 18px;">√ó</button>' : ''}
 </div>
 `;
 errorDiv.classList.remove('hidden');
 // and and not , 10
 if (!persist) {
 setTimeout(hideErrorMessage, 10000);
 }
 }
 function hideErrorMessage() {
 const errorDiv = document.getElementById('errorMessage');
 errorDiv.classList.add('hidden');
 errorDiv.innerHTML = '';
 }
 function showStatusMessage(message, type = 'info') {
 currentStatusMessages.push({ message, type, timestamp: Date.now() });
 updateStatusPanel();
 }
 function updateStatusPanel() {
 const panel = document.getElementById('statusPanel');
 const messagesDiv = document.getElementById('statusMessages');
 const inlinePanel = document.getElementById('statusMessagesInline');
 const inlineContent = document.getElementById('inlineStatusContent');
 if (!messagesDiv || !inlineContent) return;
 // and and ( 5 and)
 const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;
 currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp > fiveMinutesAgo);
 if (currentStatusMessages.length === 0) {
 panel.style.display = 'none';
 inlinePanel.style.display = 'none';
 return;
 }
 // and and (andand )
 currentStatusMessages.sort((a, b) => {
 const typeOrder = { 'error': 0, 'warning': 1, 'info': 2, 'success': 3 };
 return (typeOrder[a.type] || 3) - (typeOrder[b.type] || 3);
 });
 // and
 messagesDiv.innerHTML = '';
 inlineContent.innerHTML = '';
 const icons = {
 'error': '‚ùå',
 'warning': '‚ö†Ô∏è',
 'info': '‚ÑπÔ∏è',
 'success': '‚úÖ'
 };
 currentStatusMessages.forEach(msg => {
 const messageDiv = document.createElement('div');
 messageDiv.className = `status-message status-${msg.type}`;
 const icon = icons[msg.type] || '‚ÑπÔ∏è';
 const timeAgo = Math.floor((Date.now() - msg.timestamp) / 1000);
 const timeText = timeAgo < 60 ? `${timeAgo} ` :
 timeAgo < 3600 ? `${Math.floor(timeAgo/60)} and ` :
 `${Math.floor(timeAgo/3600)} `;
 messageDiv.innerHTML = `
 <div style="display: flex; align-items: flex-start; gap: 10px;">
 <span style="font-size: 16px;">${icon}</span>
 <div style="flex: 1;">
 <div style="white-space: pre-line;">${msg.message}</div>
 <div style="font-size: 10px; color: #666; margin-top: 3px;">${timeText}</div>
 </div>
 <button onclick="removeStatusMessage(${msg.timestamp})" style="background: none; border: none; color: #666; cursor: pointer; font-size: 14px;">√ó</button>
 </div>
 `;
 messagesDiv.appendChild(messageDiv.cloneNode(true));
 inlineContent.appendChild(messageDiv);
 });
 panel.style.display = 'block';
 inlinePanel.style.display = 'block';
 }
 function removeStatusMessage(timestamp) {
 currentStatusMessages = currentStatusMessages.filter(msg => msg.timestamp !== timestamp);
 updateStatusPanel();
 }
 function clearStatusMessages() {
 currentStatusMessages = [];
 updateStatusPanel();
 }
 // ========== ==========
 function startSolvingEnhanced() {
 if (isFindingAll) return;
 closeSolutionsPanel();
 hideCompatibilityPanel();
 // and and - and
 const solveBtn = document.getElementById('solveBtn');
 if (solveBtn.textContent === 'andand...') {
 return;
 }
 if (!validateParameterSelection()) return;
 // check
 const preCheck = preValidateParametersEnhanced(selectedParameters);
 if (!preCheck.valid) {
 showErrorMessage(preCheck.message, true);
 clearSolutionOnInvalidParams();
 return;
 }
 // and and
 if (preCheck.warnings && preCheck.warnings.length > 0) {
 preCheck.warnings.forEach(warning => {
 showStatusMessage(warning, 'warning');
 });
 }
 solveBtn.disabled = true;
 solveBtn.textContent = 'andand...';
 const progressContainer = document.getElementById('progressContainer');
 const progressBar = document.getElementById('progressBar');
 const progressText = document.getElementById('progressText');
 const statusText = document.getElementById('statusText');
 progressContainer.style.display = 'block';
 progressText.textContent = ' and and and...';
 statusText.textContent = 'andandand...';
 statusText.style.color = '#f39c12';
 // and
 if (autoCalculateTimer) {
 clearTimeout(autoCalculateTimer);
 autoCalculateTimer = null;
 }
 setTimeout(async () => {
 try {
 const solution = await optimizeTriangleWithSimulatedAnnealing(selectedParameters, (progress, iteration, error) => {
 progressBar.style.width = progress + '%';
 let status = 'and and';
 if (error > 1.0) status = ' and';
 else if (error > 0.1) status = ' andandand';
 else status = ' ';
 progressText.textContent = `${status}: ${iteration} andand, and: ${error.toFixed(6)}`;
 });
 displaySolution(solution);
 } catch (error) {
 showErrorMessage(`and andandandand: ${error.message}`, true);
 clearSolutionOnInvalidParams();
 } finally {
 solveBtn.disabled = false;
 solveBtn.textContent = 'Solve';
 progressText.textContent = 'Ready';
 setTimeout(() => {
 progressContainer.style.display = 'none';
 progressBar.style.width = '0%';
 }, 2000);
 }
 }, 100);
 }
 function initChart() {
 const ctx = document.getElementById('triangleChart').getContext('2d');
 chart = new Chart(ctx, {
 type: 'scatter',
 data: { datasets: [] },
 options: {
 responsive: true,
 maintainAspectRatio: false,
 scales: {
 x: {
 min: -3.5, max: 3.5,
 grid: { color: 'rgba(0,0,0,0.1)' },
 title: { display: true, text: 'x' }
 },
 y: {
 min: -3.5, max: 3.5,
 grid: { color: 'rgba(0,0,0,0.1)' },
 title: { display: true, text: 'y' }
 }
 },
 plugins: {
 legend: {
 display: true,
 position: 'top',
 labels: { font: { size: 10 }, boxWidth: 12 }
 },
 tooltip: { enabled: true }
 }
 }
 });
 applyTriangleYscale();
 }
 let triYscale = parseFloat(localStorage.getItem("triangle_yScale") || "100");
 const triBaseYmin = -3.5;
 const triBaseYmax = 3.5;
 function applyTriangleYscale() {
 if (!chart) return;
 const k = triYscale / 100;
 chart.options.scales.y.min = triBaseYmin * k;
 chart.options.scales.y.max = triBaseYmax * k;
 chart.update();
 }
 function initVerticalScaleControl() {
 const slider = document.getElementById("yScale");
 const label = document.getElementById("yScaleLabel");
 if (!slider || !label) return;
 slider.value = triYscale;
 label.textContent = triYscale + "%";
 slider.addEventListener("input", () => {
 triYscale = parseFloat(slider.value);
 label.textContent = triYscale + "%";
 localStorage.setItem("triangle_yScale", triYscale);
 applyTriangleYscale();
 });
 }
 function generateCirclePoints(radius, points = 100) {
 const circlePoints = [];
 for (let i = 0; i <= points; i++) {
 const angle = (i / points) * 2 * Math.PI;
 circlePoints.push({
 x: radius * Math.cos(angle),
 y: radius * Math.sin(angle)
 });
 }
 return circlePoints;
 }
 function setupEventListeners() {
 ['value1', 'value2', 'value3'].forEach(id => {
 const input = document.getElementById(id);
 input.addEventListener('keypress', function(e) {
 if (e.key === 'Enter' && !document.getElementById('solveBtn').disabled) {
 startSolvingEnhanced();
 }
 });
 input.addEventListener('blur', function() {
 const index = parseInt(id.replace('value', ''));
 const paramKey = document.getElementById(`param${index}`).value;
 if (!paramKey) return;
 const range = paramRanges[paramKey];
 if (!range) return;
 const value = parseFloat(this.value);
 if (isNaN(value)) return;
 const clampedValue = Math.max(range.min, Math.min(range.max, value));
 if (Math.abs(value - clampedValue) > 0.001) {
 if (paramKey.includes('angle')) {
 this.value = clampedValue.toFixed(1);
 } else {
 this.value = clampedValue.toFixed(3);
 }
 }
 updateSliderFromInput(index, this.value);
 });
 });
 }
 function updateSliderFromInput(paramIndex, inputValue) {
 const paramKey = document.getElementById(`param${paramIndex}`).value;
 if (!paramKey) return;
 const range = paramRanges[paramKey];
 if (!range) return;
 const value = parseFloat(inputValue);
 if (isNaN(value)) return;
 const clampedValue = Math.max(range.min, Math.min(range.max, value));
 const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
 const slider = document.getElementById(`slider${paramIndex}`);
 const valueDisplay = document.getElementById(`sliderValue${paramIndex}`);
 const input = document.getElementById(`value${paramIndex}`);
 if (slider && valueDisplay && input) {
 slider.value = normalizedValue;
 let displayValue;
 if (paramKey.includes('angle')) {
 displayValue = clampedValue.toFixed(1) + '¬∞';
 } else {
 displayValue = clampedValue.toFixed(3);
 }
 valueDisplay.textContent = displayValue;
 const currentInputValue = parseFloat(input.value);
 if (isNaN(currentInputValue) || Math.abs(currentInputValue - clampedValue) > 0.001) {
 if (paramKey.includes('angle')) {
 input.value = clampedValue.toFixed(1);
 } else {
 input.value = clampedValue.toFixed(3);
 }
 }
 }
 }
 // ========== for ==========
 function calculateAllParamsFromAngles(Œ±, Œ≤, R = 1) {
 const Œ≥ = Math.PI - Œ± - Œ≤;
 if (!isValidTriangle(Œ±, Œ≤, Œ≥)) {
 return {
 sideBC: "0", sideAC: "0", sideAB: "0",
 angleA: "0", angleB: "0", angleC: "0",
 altitudeA: "0", altitudeB: "0", altitudeC: "0",
 bisectorA: "0", bisectorB: "0", bisectorC: "0",
 medianA: "0", medianB: "0", medianC: "0",
 circumradius: "0", inradius: "0", area: "0"
 };
 }
 const a = 2 * R * Math.sin(Œ±);
 const b = 2 * R * Math.sin(Œ≤);
 const c = 2 * R * Math.sin(Œ≥);
 const p = (a + b + c) / 2;
 const S = Math.sqrt(p * (p - a) * (p - b) * (p - c));
 const ha = 2 * S / a;
 const hb = 2 * S / b;
 const hc = 2 * S / c;
 const la = (2 * b * c * Math.cos(Œ± / 2)) / (b + c);
 const lb = (2 * a * c * Math.cos(Œ≤ / 2)) / (a + c);
 const lc = (2 * a * b * Math.cos(Œ≥ / 2)) / (a + b);
 const ma = 0.5 * Math.sqrt(2 * b * b + 2 * c * c - a * a);
 const mb = 0.5 * Math.sqrt(2 * a * a + 2 * c * c - b * b);
 const mc = 0.5 * Math.sqrt(2 * a * a + 2 * b * b - c * c);
 const r = S / p;
 const params = {};
 params.sideBC = a.toFixed(8);
 params.sideAC = b.toFixed(8);
 params.sideAB = c.toFixed(8);
 params.angleA = (Œ± * 180 / Math.PI).toFixed(8);
 params.angleB = (Œ≤ * 180 / Math.PI).toFixed(8);
 params.angleC = (Œ≥ * 180 / Math.PI).toFixed(8);
 params.altitudeA = ha.toFixed(8);
 params.altitudeB = hb.toFixed(8);
 params.altitudeC = hc.toFixed(8);
 params.bisectorA = la.toFixed(8);
 params.bisectorB = lb.toFixed(8);
 params.bisectorC = lc.toFixed(8);
 params.medianA = ma.toFixed(8);
 params.medianB = mb.toFixed(8);
 params.medianC = mc.toFixed(8);
 params.circumradius = R.toFixed(8);
 params.inradius = r.toFixed(8);
 params.area = S.toFixed(8);
 return params;
 }
 function calculateTrianglePoints(Œ±, Œ≤, R = 1) {
 const Œ≥ = Math.PI - Œ± - Œ≤;
 const A = { x: R, y: 0 };
 const Œ∏_B = 2 * Œ≥;
 const B = {
 x: R * Math.cos(Œ∏_B),
 y: R * Math.sin(Œ∏_B)
 };
 const Œ∏_C = -2 * Œ≤;
 const C = {
 x: R * Math.cos(Œ∏_C),
 y: R * Math.sin(Œ∏_C)
 };
 return { A, B, C };
 }
 function isValidTriangle(Œ±, Œ≤, Œ≥) {
 const Œµ = 1e-6;
 return (
 Œ± > Œµ && Œ≤ > Œµ && Œ≥ > Œµ &&
 Math.abs(Œ± + Œ≤ + Œ≥ - Math.PI) < Œµ
 );
 }
 // ========== ==========
 function displaySolution(solution) {
 if (!solution) return;
 const normalized = normalizeSolutionOrientation(solution);
 currentSolution = normalized;
 const statusText = document.getElementById('statusText');
 const accuracyText = document.getElementById('accuracyText');
 const iterationsText = document.getElementById('iterationsText');
 const scaleText = document.getElementById('scaleText');
 const angleAText = document.getElementById('angleAText');
 const angleBText = document.getElementById('angleBText');
 const angleCText = document.getElementById('angleCText');
 const triangleTypeText = document.getElementById('triangleTypeText');
 statusText.textContent = 'and !';
 statusText.style.color = '#2ecc71';
 const accuracy = normalized.error ? Math.max(0, 100 - normalized.error * 100) : 100;
 accuracyText.textContent = accuracy >= 99.99 ? '>99.99%' : accuracy.toFixed(2) + '%';
 iterationsText.textContent = normalized.iterations || '0';
 scaleText.textContent = normalized.scale.toFixed(4);
 angleAText.textContent = `${normalized.angles.Œ±.toFixed(2)}¬∞`;
 angleBText.textContent = `${normalized.angles.Œ≤.toFixed(2)}¬∞`;
 angleCText.textContent = `${normalized.angles.Œ≥.toFixed(2)}¬∞`;
 triangleTypeText.textContent = getTriangleTypeName(normalized.type);
 updateChart(normalized);
 updateAllParamsTable(normalized);
 showStatusMessage(`and ${accuracy.toFixed(2)}%`, 'success');
 if (accuracy < 95) {
 showStatusMessage(`and ${accuracy.toFixed(2)}%`, 'warning');
 }
 }
 function normalizeSolutionOrientation(solution) {
 if (!solution || !solution.points) return solution;
 const points = solution.points;
 const A = points.A;
 const B = points.B;
 const C = points.C;
 if (!A || !B || !C) return solution;
 const cross = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
 if (cross > 0) {
 return solution;
 }
 const newPoints = { A: A, B: C, C: B };
 const newAngles = solution.angles ? {
 Œ±: solution.angles.Œ±,
 Œ≤: solution.angles.Œ≥,
 Œ≥: solution.angles.Œ≤
 } : solution.angles;
 let newParams = solution.params ? { ...solution.params } : solution.params;
 if (newParams) {
 const oldSideAB = newParams.sideAB;
 const oldSideBC = newParams.sideBC;
 const oldSideAC = newParams.sideAC;
 newParams.sideAB = oldSideAC;
 newParams.sideBC = oldSideBC;
 newParams.sideAC = oldSideAB;
 if ('altitudeB' in newParams && 'altitudeC' in newParams) {
 const oldAltB = newParams.altitudeB;
 const oldAltC = newParams.altitudeC;
 newParams.altitudeB = oldAltC;
 newParams.altitudeC = oldAltB;
 }
 if ('medianB' in newParams && 'medianC' in newParams) {
 const oldMedB = newParams.medianB;
 const oldMedC = newParams.medianC;
 newParams.medianB = oldMedC;
 newParams.medianC = oldMedB;
 }
 if ('bisectorB' in newParams && 'bisectorC' in newParams) {
 const oldBisB = newParams.bisectorB;
 const oldBisC = newParams.bisectorC;
 newParams.bisectorB = oldBisC;
 newParams.bisectorC = oldBisB;
 }
 }
 return {
 ...solution,
 points: newPoints,
 angles: newAngles,
 params: newParams
 };
 }
 // ========== ==========
 function updateChart(solution) {
 if (!solution || !chart) return;
 const { A, B, C } = solution.points;
 const R = solution.scale;
 // and and
 const Œ± = solution.angles.Œ± * Math.PI / 180;
 const Œ≤ = solution.angles.Œ≤ * Math.PI / 180;
 const Œ≥ = solution.angles.Œ≥ * Math.PI / 180;
 const a = parseFloat(solution.params.sideBC);
 const b = parseFloat(solution.params.sideAC);
 const c = parseFloat(solution.params.sideAB);
 const S = parseFloat(solution.params.area);
 // and and
 const incenter = {
 x: (a * A.x + b * B.x + c * C.x) / (a + b + c),
 y: (a * A.y + b * B.y + c * C.y) / (a + b + c)
 };
 const r = parseFloat(solution.params.inradius);
 const unitCirclePoints = generateCirclePoints(1, 100);
 const circumCirclePoints = generateCirclePoints(R, 100);
 const inCirclePoints = generateCirclePoints(r, 100).map(p => ({
 x: p.x + incenter.x,
 y: p.y + incenter.y
 }));
 const datasets = [
 {
 label: 'andand ',
 data: unitCirclePoints,
 borderColor: '#3498db',
 backgroundColor: 'transparent',
 pointRadius: 0,
 showLine: true,
 fill: false,
 borderDash: [5, 5],
 borderWidth: 1
 },
 {
 label: 'and ',
 data: circumCirclePoints,
 borderColor: '#9b59b6',
 backgroundColor: 'rgba(155, 89, 182, 0.05)',
 pointRadius: 0,
 showLine: true,
 fill: false,
 borderWidth: 2
 },
 {
 label: 'and ',
 data: inCirclePoints,
 borderColor: '#2ecc71',
 backgroundColor: 'rgba(46, 204, 113, 0.1)',
 pointRadius: 0,
 showLine: true,
 fill: true,
 borderWidth: 1.5
 },
 {
 label: 'andto',
 data: [A, B, C, A],
 borderColor: '#e74c3c',
 backgroundColor: 'rgba(231, 76, 60, 0.2)',
 pointRadius: 0,
 showLine: true,
 fill: true,
 borderWidth: 2
 },
 {
 label: 'andon A',
 data: [A],
 backgroundColor: '#e74c3c',
 pointRadius: 8,
 showLine: false,
 pointStyle: 'circle'
 },
 {
 label: 'andon B',
 data: [B],
 backgroundColor: '#e74c3c',
 pointRadius: 8,
 showLine: false,
 pointStyle: 'circle'
 },
 {
 label: 'andon C',
 data: [C],
 backgroundColor: '#e74c3c',
 pointRadius: 8,
 showLine: false,
 pointStyle: 'circle'
 },
 {
 label: '',
 data: [incenter],
 backgroundColor: '#2ecc71',
 pointRadius: 6,
 showLine: false,
 pointStyle: 'rect'
 }
 ];
 chart.data.datasets = datasets;
 chart.options.plugins.annotation = {
 annotations: {
 labelA: {
 type: 'label',
 xValue: A.x,
 yValue: A.y,
 content: 'A',
 font: { size: 16, weight: 'bold' },
 color: '#2c3e50',
 xAdjust: 20,
 yAdjust: 20
 },
 labelB: {
 type: 'label',
 xValue: B.x,
 yValue: B.y,
 content: 'B',
 font: { size: 16, weight: 'bold' },
 color: '#2c3e50',
 xAdjust: 20,
 yAdjust: 20
 },
 labelC: {
 type: 'label',
 xValue: C.x,
 yValue: C.y,
 content: 'C',
 font: { size: 16, weight: 'bold' },
 color: '#2c3e50',
 xAdjust: 20,
 yAdjust: 20
 }
 }
 };
 applyTriangleYscale();
 }
 // ========== ==========
 function checkCompatibility() {
 if (Object.keys(selectedParameters).length === 0) {
 showStatusMessage(' and ', 'warning');
 return;
 }
 const compatibility = checkParameterCompatibility(selectedParameters);
 const panel = document.getElementById('compatibilityPanel');
 const resultsDiv = document.getElementById('compatibilityResults');
 resultsDiv.innerHTML = '';
 if (compatibility.passed) {
 const div = document.createElement('div');
 div.className = 'compatibility-result validation-ok';
 div.innerHTML = `
 <div><strong>‚úì Parameter and</strong></div>
 <div> and</div>
 `;
 resultsDiv.appendChild(div);
 if (compatibility.warnings.length > 0) {
 compatibility.warnings.forEach(warning => {
 const warnDiv = document.createElement('div');
 warnDiv.className = 'compatibility-result validation-warning';
 warnDiv.innerHTML = `
 <div><strong>‚ö† and:</strong></div>
 <div>${warning.message}</div>
 `;
 resultsDiv.appendChild(warnDiv);
 });
 }
 } else {
 const div = document.createElement('div');
 div.className = 'compatibility-result validation-error';
 div.innerHTML = `
 <div><strong>‚úó Parameter notand</strong></div>
 <div> and andto and and</div>
 `;
 resultsDiv.appendChild(div);
 compatibility.errors.forEach(error => {
 const errorDiv = document.createElement('div');
 errorDiv.className = 'compatibility-result validation-error';
 errorDiv.innerHTML = `
 <div><strong>‚úó and:</strong></div>
 <div>${error.message}</div>
 `;
 resultsDiv.appendChild(errorDiv);
 });
 }
 panel.style.display = 'block';
 panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
 }
 function hideCompatibilityPanel() {
 document.getElementById('compatibilityPanel').style.display = 'none';
 }
 function debugCoordinates() {
 if (!currentSolution) {
 showStatusMessage(' and for and', 'warning');
 return;
 }
 const panel = document.getElementById('debugPanel');
 const resultsDiv = document.getElementById('debugResults');
 const { A, B, C } = currentSolution.points;
 const { Œ±, Œ≤, Œ≥ } = currentSolution.angles;
 const R = currentSolution.scale;
 const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
 const a_actual = dist(B, C);
 const b_actual = dist(A, C);
 const c_actual = dist(A, B);
 const angleFromCoords = (p1, p2, p3) => {
 const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
 const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
 const dot = v1.x * v2.x + v1.y * v2.y;
 const mag1 = Math.sqrt(v1.x**2 + v1.y**2);
 const mag2 = Math.sqrt(v2.x**2 + v2.y**2);
 const cosAngle = dot / (mag1 * mag2);
 const clamped = Math.max(-1, Math.min(1, cosAngle));
 return Math.acos(clamped) * 180 / Math.PI;
 };
 const Œ±_actual = angleFromCoords(B, A, C);
 const Œ≤_actual = angleFromCoords(A, B, C);
 const Œ≥_actual = angleFromCoords(A, C, B);
 resultsDiv.innerHTML = '';
 const coordsDiv = document.createElement('div');
 coordsDiv.innerHTML = '<strong>and and:</strong>';
 resultsDiv.appendChild(coordsDiv);
 addDebugRow('A (andon Œ±)', `(${A.x.toFixed(4)}, ${A.y.toFixed(4)})`, resultsDiv);
 addDebugRow('B (andon Œ≤)', `(${B.x.toFixed(4)}, ${B.y.toFixed(4)})`, resultsDiv);
 addDebugRow('C (andon Œ≥)', `(${C.x.toFixed(4)}, ${C.y.toFixed(4)})`, resultsDiv);
 addDebugRow('and R', R.toFixed(4), resultsDiv);
 const sidesDiv = document.createElement('div');
 sidesDiv.innerHTML = '<br><strong>andand and and:</strong>';
 resultsDiv.appendChild(sidesDiv);
 addDebugRow('AB (c)', `${c_actual.toFixed(4)} (and: ${parseFloat(currentSolution.params.sideAB).toFixed(4)})`, resultsDiv);
 addDebugRow('BC (a)', `${a_actual.toFixed(4)} (and: ${parseFloat(currentSolution.params.sideBC).toFixed(4)})`, resultsDiv);
 addDebugRow('AC (b)', `${b_actual.toFixed(4)} (and: ${parseFloat(currentSolution.params.sideAC).toFixed(4)})`, resultsDiv);
 const anglesDiv = document.createElement('div');
 anglesDiv.innerHTML = '<br><strong>andand angles and and:</strong>';
 resultsDiv.appendChild(anglesDiv);
 addDebugRow('‚à†A (Œ±)', `${Œ±_actual.toFixed(2)}¬∞ (and: ${Œ±.toFixed(2)}¬∞)`, resultsDiv);
 addDebugRow('‚à†B (Œ≤)', `${Œ≤_actual.toFixed(2)}¬∞ (and: ${Œ≤.toFixed(2)}¬∞)`, resultsDiv);
 addDebugRow('‚à†C (Œ≥)', `${Œ≥_actual.toFixed(2)}¬∞ (and: ${Œ≥.toFixed(2)}¬∞)`, resultsDiv);
 const sumAnglesActual = Œ±_actual + Œ≤_actual + Œ≥_actual;
 addDebugRow('Sum of angles', `${sumAnglesActual.toFixed(2)}¬∞ (and 180¬∞)`, resultsDiv);
 panel.style.display = 'block';
 panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
 }
 function addDebugRow(label, value, container) {
 const row = document.createElement('div');
 row.className = 'debug-row';
 row.innerHTML = `
 <span class="debug-label">${label}:</span>
 <span class="debug-value">${value}</span>
 `;
 container.appendChild(row);
 }
 function validateTriangleGeometry(params) {
 const results = [];
 const Œµ = 1e-6;
 const a = parseFloat(params.sideBC);
 const b = parseFloat(params.sideAC);
 const c = parseFloat(params.sideAB);
 const Œ± = parseFloat(params.angleA);
 const Œ≤ = parseFloat(params.angleB);
 const Œ≥ = parseFloat(params.angleC);
 const R = parseFloat(params.circumradius);
 const S = parseFloat(params.area);
 const r = parseFloat(params.inradius);
 const sumAngles = Œ± + Œ≤ + Œ≥;
 const angleError = Math.abs(sumAngles - 180);
 results.push({
 test: 'Sum of angles',
 value: sumAngles.toFixed(6),
 expected: '180.000000',
 error: angleError,
 passed: angleError < 0.001
 });
 const sinRatioA = a / Math.sin(Œ± * Math.PI / 180);
 const sinRatioB = b / Math.sin(Œ≤ * Math.PI / 180);
 const sinRatioC = c / Math.sin(Œ≥ * Math.PI / 180);
 const sinError = Math.max(
 Math.abs(sinRatioA - sinRatioB),
 Math.abs(sinRatioB - sinRatioC),
 Math.abs(sinRatioA - sinRatioC)
 );
 results.push({
 test: ' and',
 value: `${sinRatioA.toFixed(3)} ‚âà ${sinRatioB.toFixed(3)} ‚âà ${sinRatioC.toFixed(3)}`,
 expected: ' and',
 error: sinError,
 passed: sinError < 0.01
 });
 const R_from_sides = (a * b * c) / (4 * S);
 const R_error = Math.abs(R - R_from_sides);
 results.push({
 test: 'Circumradius and',
 value: R.toFixed(6),
 expected: R_from_sides.toFixed(6),
 error: R_error,
 passed: R_error < 0.001
 });
 const p = (a + b + c) / 2;
 const r_from_sides = S / p;
 const r_error = Math.abs(r - r_from_sides);
 results.push({
 test: 'Inradius and',
 value: r.toFixed(6),
 expected: r_from_sides.toFixed(6),
 error: r_error,
 passed: r_error < 0.001
 });
 const triangleInequality = (a + b > c) && (a + c > b) && (b + c > a);
 results.push({
 test: ' and',
 value: triangleInequality ? 'notbut' : '',
 expected: 'notbut',
 error: triangleInequality ? 0 : 1,
 passed: triangleInequality
 });
 return {
 results: results,
 passed: results.every(r => r.passed),
 score: results.filter(r => r.passed).length / results.length * 100
 };
 }
 function validateCurrentTriangleEnhanced() {
 if (!currentSolution) {
 showStatusMessage(' and for and', 'warning');
 return;
 }
 const validation = validateTriangleGeometry(currentSolution.params);
 const practicalCheck = checkPracticalFeasibility(currentSolution.params);
 const numericalCheck = checkNumericalFeasibility(currentSolution.params);
 const panel = document.getElementById('validationPanel');
 const resultsDiv = document.getElementById('validationResults');
 resultsDiv.innerHTML = '';
 //
 const header = document.createElement('div');
 header.className = 'validation-result';
 header.style.backgroundColor = '#34495e';
 header.style.color = 'white';
 header.style.fontWeight = 'bold';
 header.innerHTML = '<div style="text-align: center;"> triangle</div>';
 resultsDiv.appendChild(header);
 // andand and
 validation.results.forEach(result => {
 const div = document.createElement('div');
 div.className = `validation-result ${result.passed ? 'validation-ok' : 'validation-error'}`;
 let status = result.passed ? '‚úì' : '‚úó';
 div.innerHTML = `
 <div><strong>${status} ${result.test}:</strong></div>
 <div>Obtained: ${result.value}</div>
 <div>and: ${result.expected}</div>
 <div style="font-size: 11px; color: #666;">and: ${result.error.toExponential(2)}</div>
 `;
 resultsDiv.appendChild(div);
 });
 // Check and andand
 if (practicalCheck.allIssues.length > 0) {
 const practicalDiv = document.createElement('div');
 practicalDiv.className = `validation-result ${practicalCheck.feasible ? 'validation-warning' : 'validation-error'}`;
 practicalDiv.innerHTML = `
 <div><strong>${practicalCheck.feasible ? '‚ö†' : '‚úó'} and and:</strong></div>
 <div>${practicalCheck.feasible ? ' and' : ' andandand '}</div>
 `;
 resultsDiv.appendChild(practicalDiv);
 practicalCheck.allIssues.forEach((issue, index) => {
 if (index < 3) {
 const issueDiv = document.createElement('div');
 issueDiv.className = 'validation-result validation-warning';
 issueDiv.style.marginLeft = '20px';
 issueDiv.style.fontSize = '12px';
 issueDiv.innerHTML = `‚Ä¢ ${issue}`;
 resultsDiv.appendChild(issueDiv);
 }
 });
 }
 //
 const overallPassed = validation.passed && practicalCheck.feasible && numericalCheck.feasible;
 const summary = document.createElement('div');
 summary.className = `validation-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
 summary.innerHTML = `
 <div><strong>${overallPassed ? '‚úì triangle ' : '‚úó '}</strong></div>
 <div>and: ${validation.results.filter(r => r.passed).length}/${validation.results.length}</div>
 <div>: ${validation.score.toFixed(1)}%</div>
 <div>and and: ${practicalCheck.feasible ? '‚úì' : '‚úó'}</div>
 <div>and and: ${numericalCheck.feasible ? '‚úì' : '‚úó'}</div>
 `;
 resultsDiv.appendChild(summary);
 panel.style.display = 'block';
 updateAllParamsTable(currentSolution);
 }
 function determineTriangleType(params) {
 const a = parseFloat(params.sideBC);
 const b = parseFloat(params.sideAC);
 const c = parseFloat(params.sideAB);
 const Œ± = parseFloat(params.angleA);
 const Œ≤ = parseFloat(params.angleB);
 const Œ≥ = parseFloat(params.angleC);
 const Œµ = 0.01;
 if (Math.abs(a - b) < Œµ && Math.abs(b - c) < Œµ &&
 Math.abs(Œ± - 60) < 1 && Math.abs(Œ≤ - 60) < 1 && Math.abs(Œ≥ - 60) < 1) {
 return 'equilateral';
 }
 if (Math.abs(Œ± - 90) < 1 || Math.abs(Œ≤ - 90) < 1 || Math.abs(Œ≥ - 90) < 1) {
 return 'right';
 }
 if (Math.abs(a - b) < Œµ || Math.abs(a - c) < Œµ || Math.abs(b - c) < Œµ) {
 return 'isosceles';
 }
 return 'scalene';
 }
 function updateAllParamsTable(solution = null) {
 const tbody = document.getElementById('paramsTableBody');
 tbody.innerHTML = '';
 let validation = null;
 if (solution && solution.params) {
 validation = validateTriangleGeometry(solution.params);
 }
 allParameters.forEach((param, index) => {
 let value = '-';
 let isGiven = false;
 let isValid = true;
 let validationInfo = '';
 if (solution && solution.params && solution.params[param.key] !== undefined) {
 value = solution.params[param.key];
 if (validation) {
 const numValue = parseFloat(value);
 if (param.key.includes('side')) {
 const a = parseFloat(solution.params.sideBC);
 const b = parseFloat(solution.params.sideAC);
 const c = parseFloat(solution.params.sideAB);
 isValid = (a + b > c && a + c > b && b + c > a);
 if (!isValid) validationInfo = ' not and';
 } else if (param.key.includes('angle')) {
 const sum = parseFloat(solution.params.angleA || 0) +
 parseFloat(solution.params.angleB || 0) +
 parseFloat(solution.params.angleC || 0);
 isValid = Math.abs(sum - 180) < 0.001;
 if (!isValid) validationInfo = `Sum of angles: ${sum.toFixed(2)}¬∞`;
 }
 }
 }
 if (selectedParameters && selectedParameters[param.key] !== undefined) {
 isGiven = true;
 value = selectedParameters[param.key].toFixed(6);
 }
 const row = document.createElement('tr');
 if (isGiven) {
 row.style.backgroundColor = '#e8f6f3';
 }
 const numValue = parseFloat(value);
 const cellClass = !isNaN(numValue) && numValue <= 0 ? 'invalid' : 'valid';
 row.innerHTML = `
 <td>${index + 1}</td>
 <td>${param.name}</td>
 <td>${param.designation}</td>
 <td class="${cellClass}"><strong>${value}</strong></td>
 <td>${isGiven ? '‚úì' : ''} ${validationInfo ? `<span style="color: #e74c3c; font-size: 10px;">${validationInfo}</span>` : ''}</td>
 `;
 tbody.appendChild(row);
 });
 }
 function getTriangleTypeName(type) {
 const names = {
 'equilateral': 'and',
 'right': '',
 'isosceles': '',
 'scalene': 'and'
 };
 return names[type] || type;
 }
 function generateTriangleByType(type) {
 clearAll();
 let solution;
 switch(type) {
 case 'equilateral':
 solution = generateEquilateralTriangle();
 break;
 case 'right':
 solution = generateRightTriangle();
 break;
 case 'isosceles':
 solution = generateIsoscelesTriangle();
 break;
 default:
 solution = generateRandomTriangle();
 }
 displayGeneratedTriangle(solution);
 showStatusMessage(`notand ${getTriangleTypeName(solution.type)} andto`, 'info');
 }
 function generateEquilateralTriangle() {
 const Œ± = 60, Œ≤ = 60, Œ≥ = 60;
 const R = 1;
 const Œ±Rad = Œ± * Math.PI / 180;
 const Œ≤Rad = Œ≤ * Math.PI / 180;
 const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
 const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
 return {
 points: points,
 params: params,
 scale: R,
 angles: { Œ±, Œ≤, Œ≥ },
 type: 'equilateral'
 };
 }
 function generateRightTriangle() {
 const Œ± = 90, Œ≤ = 45, Œ≥ = 45;
 const R = 1;
 const Œ±Rad = Œ± * Math.PI / 180;
 const Œ≤Rad = Œ≤ * Math.PI / 180;
 const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
 const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
 return {
 points: points,
 params: params,
 scale: R,
 angles: { Œ±, Œ≤, Œ≥ },
 type: 'right'
 };
 }
 function generateIsoscelesTriangle() {
 const Œ± = 70, Œ≤ = 70, Œ≥ = 40;
 const R = 1;
 const Œ±Rad = Œ± * Math.PI / 180;
 const Œ≤Rad = Œ≤ * Math.PI / 180;
 const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
 const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
 return {
 points: points,
 params: params,
 scale: R,
 angles: { Œ±, Œ≤, Œ≥ },
 type: 'isosceles'
 };
 }
 function generateRandomTriangle() {
 let Œ±, Œ≤;
 do {
 Œ± = 10 + Math.random() * 160;
 Œ≤ = 10 + Math.random() * (160 - Œ±);
 } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
 const Œ≥ = 180 - Œ± - Œ≤;
 const R = 1.0 + Math.random() * 1.5;
 const Œ±Rad = Œ± * Math.PI / 180;
 const Œ≤Rad = Œ≤ * Math.PI / 180;
 const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
 const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
 const type = determineTriangleType(params);
 return {
 points: points,
 params: params,
 scale: R,
 angles: { Œ±, Œ≤, Œ≥ },
 type: type,
 validated: validateTriangleGeometry(params)
 };
 }
 function displayGeneratedTriangle(solution) {
 if (!solution) return;
 currentSolution = solution;
 updateChart(solution);
 updateAllParamsTable(solution);
 document.getElementById('statusText').textContent = `andto: ${getTriangleTypeName(solution.type)}`;
 document.getElementById('statusText').style.color = '#9b59b6';
 document.getElementById('accuracyText').textContent = '100%';
 document.getElementById('iterationsText').textContent = '0';
 document.getElementById('scaleText').textContent = solution.scale.toFixed(2);
 document.getElementById('angleAText').textContent = `${solution.angles.Œ±.toFixed(2)}¬∞`;
 document.getElementById('angleBText').textContent = `${solution.angles.Œ≤.toFixed(2)}¬∞`;
 document.getElementById('angleCText').textContent = `${solution.angles.Œ≥.toFixed(2)}¬∞`;
 document.getElementById('triangleTypeText').textContent = getTriangleTypeName(solution.type);
 }
 function generateRandomProblem() {
 clearAll();
 const R = 1.0 + Math.random() * 1.5;
 let Œ±, Œ≤;
 do {
 Œ± = 10 + Math.random() * 160;
 Œ≤ = 10 + Math.random() * (160 - Œ±);
 } while (Œ± + Œ≤ >= 170 || Œ± <= 0 || Œ≤ <= 0);
 const Œ≥ = 180 - Œ± - Œ≤;
 if (Œ≥ < 10 || Œ≥ > 170) {
 return generateRandomProblem();
 }
 const Œ±Rad = Œ± * Math.PI / 180;
 const Œ≤Rad = Œ≤ * Math.PI / 180;
 const params = calculateAllParamsFromAngles(Œ±Rad, Œ≤Rad, R);
 const points = calculateTrianglePoints(Œ±Rad, Œ≤Rad, R);
 const type = determineTriangleType(params);
 const solution = {
 points: points,
 params: params,
 scale: R,
 angles: { Œ±, Œ≤, Œ≥ },
 type: type,
 validated: validateTriangleGeometry(params)
 };
 const allKeys = Object.keys(solution.params).filter(key => {
 const value = parseFloat(solution.params[key]);
 return !isNaN(value) && value > 0;
 });
 let selectedKeys = [];
 let attempts = 0;
 const maxAttempts = 100;
 while (selectedKeys.length < 3 && attempts < maxAttempts) {
 const shuffled = [...allKeys].sort(() => Math.random() - 0.5);
 const candidateKeys = shuffled.slice(0, 3);
 const hasAngle = candidateKeys.some(k => k.includes('angle'));
 const hasSide = candidateKeys.some(k => k.includes('side'));
 const hasOther = candidateKeys.some(k => !k.includes('angle') && !k.includes('side'));
 if ((hasAngle && hasSide) || (hasAngle && hasOther) || (hasSide && hasOther)) {
 selectedKeys = candidateKeys;
 break;
 }
 attempts++;
 }
 if (selectedKeys.length < 3) {
 selectedKeys = allKeys.slice(0, 3);
 }
 selectedKeys.forEach((key, index) => {
 const value = solution.params[key];
 if (value) {
 const select = document.getElementById(`param${index + 1}`);
 select.value = key;
 const numValue = parseFloat(value);
 const input = document.getElementById(`value${index + 1}`);
 if (key.includes('angle')) {
 input.value = numValue.toFixed(1);
 } else {
 input.value = numValue.toFixed(3);
 }
 updateSliderForParam(index + 1, key);
 const range = paramRanges[key];
 if (range) {
 const clampedValue = Math.max(range.min, Math.min(range.max, numValue));
 const normalizedValue = ((clampedValue - range.min) / (range.max - range.min)) * 100;
 const slider = document.getElementById(`slider${index + 1}`);
 const valueDisplay = document.getElementById(`sliderValue${index + 1}`);
 if (slider && valueDisplay) {
 slider.value = normalizedValue;
 let displayValue;
 if (key.includes('angle')) {
 displayValue = clampedValue.toFixed(1) + '¬∞';
 } else {
 displayValue = clampedValue.toFixed(3);
 }
 valueDisplay.textContent = displayValue;
 }
 }
 }
 });
 displayGeneratedTriangle(solution);
 validateParameterSelection();
 showStatusMessage(`notand ${getTriangleTypeName(solution.type)} and`, 'info');
 }
 function testAndDisplayFormulas() {
 console.clear();
 console.log('=== ===');
 const equilateral = generateEquilateralTriangle();
 console.log('\n1. Equilateral andto (Œ±=Œ≤=Œ≥=60¬∞, R=1):');
 console.log(' (and ~1.732):',
 equilateral.params.sideAB, equilateral.params.sideBC, equilateral.params.sideAC);
 const right = generateRightTriangle();
 console.log('\n2. Right andto (Œ±=90¬∞, Œ≤=Œ≥=45¬∞, R=1):');
 console.log(':', right.params.sideAB, right.params.sideBC, right.params.sideAC);
 const validation = validateTriangleGeometry(equilateral.params);
 console.log('\n3. Geometry validation an equilateral triangle:');
 console.log(` : ${validation.results.filter(r => r.passed).length}/${validation.results.length}`);
 console.log(`: ${validation.score.toFixed(1)}%`);
 displayGeneratedTriangle(equilateral);
 setTimeout(() => {
 debugCoordinates();
 }, 500);
 showStatusMessage('andand . (F12).', 'info');
 }
 function clearAll() {
 closeSolutionsPanel();
 hideCompatibilityPanel();
 allSolutions = [];
 currentSolutionIndex = 0;
 currentStatusMessages = [];
 for (let i = 1; i <= 3; i++) {
 document.getElementById(`param${i}`).value = '';
 document.getElementById(`value${i}`).value = '';
 document.getElementById(`sliderContainer${i}`).style.display = 'none';
 document.getElementById(`param${i}`).style.borderColor = '#ddd';
 document.getElementById(`value${i}`).style.borderColor = '#ddd';
 document.getElementById(`fixParam${i}`).checked = false;
 document.getElementById(`paramRow${i}`).classList.remove('fixed');
 }
 selectedParameters = {};
 currentSolution = null;
 document.getElementById('solveBtn').disabled = true;
 document.getElementById('solveAllBtn').disabled = true;
 document.getElementById('randomParamsBtn').disabled = true;
 document.getElementById('solveBtn').textContent = 'Solve';
 document.getElementById('statusText').textContent = 'Waiting for input';
 document.getElementById('statusText').style.color = '#7f8c8d';
 document.getElementById('accuracyText').textContent = '-';
 document.getElementById('iterationsText').textContent = '0';
 document.getElementById('scaleText').textContent = '1.00';
 document.getElementById('angleAText').textContent = '-';
 document.getElementById('angleBText').textContent = '-';
 document.getElementById('angleCText').textContent = '-';
 document.getElementById('triangleTypeText').textContent = '-';
 hideErrorMessage();
 updateStatusPanel();
 document.getElementById('validationPanel').style.display = 'none';
 document.getElementById('debugPanel').style.display = 'none';
 // and
 if (autoCalculateTimer) {
 clearTimeout(autoCalculateTimer);
 autoCalculateTimer = null;
 }
 if (chart) {
 chart.data.datasets = [
 {
 label: 'andand ',
 data: generateCirclePoints(1, 100),
 borderColor: '#3498db',
 backgroundColor: 'transparent',
 pointRadius: 0,
 showLine: true,
 fill: false,
 borderDash: [5, 5],
 borderWidth: 1
 }
 ];
 chart.options.scales.x.min = -3.5;
 chart.options.scales.x.max = 3.5;
 chart.options.scales.y.min = -3.5;
 chart.options.scales.y.max = 3.5;
 chart.options.plugins.annotation = { annotations: {} };
 applyTriangleYscale();
 }
 updateAllParamsTable();
 }
 function clearSolutionOnInvalidParams() {
 const statusText = document.getElementById('statusText');
 const accuracyText = document.getElementById('accuracyText');
 const iterationsText = document.getElementById('iterationsText');
 statusText.textContent = 'and ';
 statusText.style.color = '#e74c3c';
 accuracyText.textContent = '-';
 iterationsText.textContent = '0';
 document.getElementById('scaleText').textContent = '1.00';
 document.getElementById('angleAText').textContent = '-';
 document.getElementById('angleBText').textContent = '-';
 document.getElementById('angleCText').textContent = '-';
 document.getElementById('triangleTypeText').textContent = '-';
 currentSolution = null;
 if (chart) {
 chart.data.datasets = [{
 label: 'andand ',
 data: generateCirclePoints(1, 100),
 borderColor: '#3498db',
 backgroundColor: 'transparent',
 pointRadius: 0,
 showLine: true,
 fill: false,
 borderDash: [5, 5],
 borderWidth: 1
 }];
 chart.update();
 }
 updateAllParamsTable();
 }
 async function findAllSolutionsEnhanced() {
 if (!validateParameterSelection()) return;
 const preCheck = preValidateParametersEnhanced(selectedParameters);
 if (!preCheck.valid) {
 showErrorMessage(preCheck.message, true);
 clearSolutionOnInvalidParams();
 return;
 }
 const solveAllBtn = document.getElementById('solveAllBtn');
 solveAllBtn.disabled = true;
 solveAllBtn.textContent = 'and...';
 isFindingAll = true;
 const progressContainer = document.getElementById('progressContainer');
 const progressBar = document.getElementById('progressBar');
 const progressText = document.getElementById('progressText');
 progressContainer.style.display = 'block';
 progressText.textContent = 'and and (and and)...';
 try {
 const mainSolution = await optimizeTriangleWithSimulatedAnnealing(selectedParameters, (progress, iteration, error) => {
 progressBar.style.width = Math.min(50, progress) + '%';
 progressText.textContent = ` and: ${iteration} andand, and: ${error.toFixed(6)}`;
 });
 allSolutions = generateAllTriangleVariantsEnhanced(mainSolution);
 displaySolutionsPanel(allSolutions);
 if (allSolutions.length > 0) {
 showSolution(0);
 }
 showStatusMessage(` ${allSolutions.length} and`, 'success');
 } catch (error) {
 showErrorMessage(`and and: ${error.message}`, true);
 clearSolutionOnInvalidParams();
 } finally {
 solveAllBtn.disabled = false;
 solveAllBtn.textContent = 'All solutions';
 progressContainer.style.display = 'none';
 progressBar.style.width = '0%';
 isFindingAll = false;
 }
 }
 function generateAllTriangleVariantsEnhanced(mainSolution) {
 if (!mainSolution) return [];
 const variants = [mainSolution];
 if (mainSolution.type !== 'equilateral') {
 // and
 const mirrored = createMirroredTriangle(mainSolution);
 if (mirrored) {
 variants.push({
 ...mirrored,
 isMirror: true,
 displayName: "andand"
 });
 }
 // and (for not and and)
 const rotated1 = rotateTriangle(mainSolution, 120);
 if (rotated1 && !isDuplicateSolution(variants, rotated1)) {
 variants.push({
 ...rotated1,
 displayName: " 120¬∞"
 });
 }
 const rotated2 = rotateTriangle(mainSolution, 240);
 if (rotated2 && !isDuplicateSolution(variants, rotated2)) {
 variants.push({
 ...rotated2,
 displayName: " 240¬∞"
 });
 }
 }
 return variants.map(s => normalizeSolutionOrientation(s));
 }
 function createMirroredTriangle(original) {
 if (!original || !original.points) return null;
 const { A, B, C } = original.points;
 return {
 ...original,
 points: {
 A: { x: A.x, y: -A.y },
 B: { x: B.x, y: -B.y },
 C: { x: C.x, y: -C.y }
 },
 isMirror: true
 };
 }
 function rotateTriangle(solution, angleDeg) {
 if (!solution || !solution.points) return null;
 const angleRad = angleDeg * Math.PI / 180;
 const cosA = Math.cos(angleRad);
 const sinA = Math.sin(angleRad);
 const rotatePoint = (p) => ({
 x: p.x * cosA - p.y * sinA,
 y: p.x * sinA + p.y * cosA
 });
 return {
 ...solution,
 points: {
 A: rotatePoint(solution.points.A),
 B: rotatePoint(solution.points.B),
 C: rotatePoint(solution.points.C)
 }
 };
 }
 function isDuplicateSolution(solutions, newSolution) {
 if (!newSolution || !newSolution.points) return true;
 return solutions.some(existing => {
 if (!existing || !existing.points) return false;
 const dist = (p1, p2) => Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
 const distances = [
 dist(existing.points.A, newSolution.points.A),
 dist(existing.points.B, newSolution.points.B),
 dist(existing.points.C, newSolution.points.C)
 ];
 return distances.every(d => d < 0.001);
 });
 }
 function displaySolutionsPanel(solutions) {
 if (!solutions || solutions.length === 0) return;
 const panel = document.getElementById('solutionsPanel');
 const grid = document.getElementById('solutionsGrid');
 const countDisplay = document.getElementById('solutionsCountDisplay');
 const infoSpan = document.getElementById('allSolutionsInfo');
 const solutionsCount = document.getElementById('solutionsCount');
 countDisplay.textContent = solutions.length;
 solutionsCount.textContent = solutions.length;
 infoSpan.style.display = 'inline';
 grid.innerHTML = '';
 solutions.forEach((solution, index) => {
 const thumb = document.createElement('div');
 thumb.className = `solution-thumb ${solution.isMirror ? 'mirror' : ''}`;
 thumb.onclick = () => showSolution(index);
 const typeName = getTriangleTypeName(solution.type);
 const errorPercent = solution.error ?
 Math.max(0, 100 - solution.error * 100).toFixed(1) : '100.0';
 let title = `and ${index + 1}`;
 if (solution.displayName) {
 title = solution.displayName;
 } else if (solution.isMirror) {
 title = "andand";
 }
 thumb.innerHTML = `
 <div class="thumb-title">${title}</div>
 <div class="thumb-info">
 Œ±=${solution.angles.Œ±.toFixed(1)}¬∞<br>
 Œ≤=${solution.angles.Œ≤.toFixed(1)}¬∞<br>
 ${typeName}<br>
 <small>Accuracy: ${errorPercent}%</small>
 </div>
 <div class="solution-actions">
 <button class="solution-btn view-btn" onclick="event.stopPropagation(); showSolution(${index})">
 üëÅ
 </button>
 <button class="solution-btn animate-btn" onclick="event.stopPropagation(); animateToSolution(${index})">
 ‚Üí andand
 </button>
 </div>
 `;
 grid.appendChild(thumb);
 });
 panel.style.display = 'block';
 }
 function showSolution(index) {
 if (!allSolutions || index < 0 || index >= allSolutions.length) return;
 document.querySelectorAll('.solution-thumb').forEach((thumb, i) => {
 thumb.classList.toggle('active', i === index);
 });
 const solution = allSolutions[index];
 displaySolution(solution);
 currentSolution = solution;
 currentSolutionIndex = index;
 updateSolutionIndicator();
 }
 function showPreviousSolution() {
 if (allSolutions.length <= 1) return;
 const newIndex = (currentSolutionIndex - 1 + allSolutions.length) % allSolutions.length;
 showSolution(newIndex);
 }
 function showNextSolution() {
 if (allSolutions.length <= 1) return;
 const newIndex = (currentSolutionIndex + 1) % allSolutions.length;
 showSolution(newIndex);
 }
 function animateToSolution(targetIndex) {
 if (!allSolutions || targetIndex === currentSolutionIndex || allSolutions.length <= 1) return;
 const steps = 20;
 const duration = 800;
 const stepTime = duration / steps;
 const startSolution = allSolutions[currentSolutionIndex];
 const endSolution = allSolutions[targetIndex];
 let currentStep = 0;
 const animate = () => {
 if (currentStep > steps) {
 showSolution(targetIndex);
 return;
 }
 const t = currentStep / steps;
 const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
 const interpolatedPoints = {
 A: {
 x: startSolution.points.A.x + (endSolution.points.A.x - startSolution.points.A.x) * easeT,
 y: startSolution.points.A.y + (endSolution.points.A.y - startSolution.points.A.y) * easeT
 },
 B: {
 x: startSolution.points.B.x + (endSolution.points.B.x - startSolution.points.B.x) * easeT,
 y: startSolution.points.B.y + (endSolution.points.B.y - startSolution.points.B.y) * easeT
 },
 C: {
 x: startSolution.points.C.x + (endSolution.points.C.x - startSolution.points.C.x) * easeT,
 y: startSolution.points.C.y + (endSolution.points.C.y - startSolution.points.C.y) * easeT
 }
 };
 const intermediateSolution = {
 ...startSolution,
 points: interpolatedPoints
 };
 updateChart(intermediateSolution);
 currentStep++;
 setTimeout(animate, stepTime);
 };
 animate();
 }
 function updateSolutionIndicator() {
 const indicator = document.getElementById('solutionIndicator');
 if (!allSolutions || allSolutions.length <= 1) {
 indicator.textContent = '';
 return;
 }
 indicator.textContent = `[${currentSolutionIndex + 1}/${allSolutions.length}]`;
 }
 function closeSolutionsPanel() {
 const panel = document.getElementById('solutionsPanel');
 panel.style.display = 'none';
 const infoSpan = document.getElementById('allSolutionsInfo');
 infoSpan.style.display = 'none';
 allSolutions = [];
 currentSolutionIndex = 0;
 updateSolutionIndicator();
 }
 // ========== for " " ==========
 function setupFixCheckboxes() {
 for (let i = 1; i <= 3; i++) {
 const checkbox = document.getElementById(`fixParam${i}`);
 const paramRow = document.getElementById(`paramRow${i}`);
 checkbox.addEventListener('change', function() {
 if (this.checked) {
 paramRow.classList.add('fixed');
 } else {
 paramRow.classList.remove('fixed');
 }
 updateRandomParamsButtonState();
 });
 }
 }
 function updateRandomParamsButtonState() {
 const param1Selected = document.getElementById('param1').value !== '';
 const param2Selected = document.getElementById('param2').value !== '';
 const param3Selected = document.getElementById('param3').value !== '';
 const allParamsSelected = param1Selected && param2Selected && param3Selected;
 const fix1 = document.getElementById('fixParam1').checked;
 const fix2 = document.getElementById('fixParam2').checked;
 const fix3 = document.getElementById('fixParam3').checked;
 const allFixed = fix1 && fix2 && fix3;
 const randomParamsBtn = document.getElementById('randomParamsBtn');
 if (allParamsSelected && !allFixed) {
 randomParamsBtn.disabled = false;
 } else {
 randomParamsBtn.disabled = true;
 }
 }
 function randomizeNonFixedParameters() {
 if (!validateParameterSelection()) return;
 let changedAny = false;
 for (let i = 1; i <= 3; i++) {
 const paramKey = document.getElementById(`param${i}`).value;
 const isFixed = document.getElementById(`fixParam${i}`).checked;
 if (!paramKey || isFixed) continue;
 const range = paramRanges[paramKey];
 if (!range) continue;
 let randomValue;
 if (paramKey.includes('angle')) {
 const otherAngles = getOtherAngleValues(i);
 const maxAngle = 170 - otherAngles.reduce((a, b) => a + b, 0);
 if (maxAngle < 10) {
 continue;
 }
 randomValue = 10 + Math.random() * (maxAngle - 10);
 randomValue = Math.max(10, Math.min(maxAngle, randomValue));
 } else {
 randomValue = range.min + Math.random() * (range.max - range.min);
 }
 const input = document.getElementById(`value${i}`);
 const slider = document.getElementById(`slider${i}`);
 const valueDisplay = document.getElementById(`sliderValue${i}`);
 if (paramKey.includes('angle')) {
 input.value = randomValue.toFixed(1);
 } else {
 input.value = randomValue.toFixed(3);
 }
 const normalizedValue = ((randomValue - range.min) / (range.max - range.min)) * 100;
 if (slider) slider.value = normalizedValue;
 let displayValue;
 if (paramKey.includes('angle')) {
 displayValue = randomValue.toFixed(1) + '¬∞';
 } else {
 displayValue = randomValue.toFixed(3);
 }
 if (valueDisplay) valueDisplay.textContent = displayValue;
 changedAny = true;
 }
 if (changedAny) {
 validateParameterSelection();
 showStatusMessage('and notandand ', 'info');
 // andand andnotand
 triggerAutoCalculate();
 } else {
 showStatusMessage(' andand', 'warning');
 }
 }
 function getOtherAngleValues(currentIndex) {
 const otherAngles = [];
 for (let i = 1; i <= 3; i++) {
 if (i === currentIndex) continue;
 const paramKey = document.getElementById(`param${i}`).value;
 const isFixed = document.getElementById(`fixParam${i}`).checked;
 if (paramKey && paramKey.includes('angle') && isFixed) {
 const value = parseFloat(document.getElementById(`value${i}`).value);
 if (!isNaN(value)) {
 otherAngles.push(value);
 }
 }
 }
 return otherAngles;
 }
 // ========== for UI ==========
 function checkPracticalFeasibilityUI() {
 if (Object.keys(selectedParameters).length === 0) {
 showStatusMessage(' and ', 'warning');
 return;
 }
 const compatibility = checkParameterCompatibility(selectedParameters);
 const practicalCheck = checkPracticalFeasibility(selectedParameters);
 const numericalCheck = checkNumericalFeasibility(selectedParameters);
 const panel = document.getElementById('compatibilityPanel');
 const resultsDiv = document.getElementById('compatibilityResults');
 resultsDiv.innerHTML = '';
 //
 const header = document.createElement('div');
 header.className = 'compatibility-result';
 header.style.backgroundColor = '#34495e';
 header.style.color = 'white';
 header.style.fontWeight = 'bold';
 header.innerHTML = '<div style="text-align: center;"> check </div>';
 resultsDiv.appendChild(header);
 // 1. and
 const compatDiv = document.createElement('div');
 compatDiv.className = `compatibility-result ${compatibility.passed ? 'validation-ok' : 'validation-error'}`;
 compatDiv.innerHTML = `
 <div><strong>${compatibility.passed ? '‚úì' : '‚úó'} and :</strong></div>
 <div>${compatibility.passed ? 'Parameter and' : ' notand '}</div>
 <div style="font-size: 11px;">: ${compatibility.allChecks.length} and</div>
 `;
 resultsDiv.appendChild(compatDiv);
 // 2. and and
 const practicalDiv = document.createElement('div');
 practicalDiv.className = `compatibility-result ${practicalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
 practicalDiv.innerHTML = `
 <div><strong>${practicalCheck.feasible ? '‚úì' : '‚úó'} and and:</strong></div>
 <div>${practicalCheck.feasible ? 'Parameter and' : ' andand'}</div>
 <div style="font-size: 11px;">and: ${practicalCheck.errors.length}, and: ${practicalCheck.warnings.length}</div>
 `;
 resultsDiv.appendChild(practicalDiv);
 // 3. and and
 const numericalDiv = document.createElement('div');
 numericalDiv.className = `compatibility-result ${numericalCheck.feasible ? 'validation-ok' : 'validation-error'}`;
 numericalDiv.innerHTML = `
 <div><strong>${numericalCheck.feasible ? '‚úì' : '‚úó'} and and:</strong></div>
 <div>${numericalCheck.feasible ? 'Parameter and' : ' and andand'}</div>
 <div style="font-size: 11px;">: ${numericalCheck.issues.length}</div>
 `;
 resultsDiv.appendChild(numericalDiv);
 //
 const allProblems = [
 ...compatibility.errors.map(e => ({type: 'error', message: e.message})),
 ...practicalCheck.errors.map(e => ({type: 'error', message: e})),
 ...practicalCheck.warnings.map(w => ({type: 'warning', message: w})),
 ...numericalCheck.issues.map(i => ({type: i.includes('and') ? 'error' : 'warning', message: i}))
 ];
 if (allProblems.length > 0) {
 const problemsDiv = document.createElement('div');
 problemsDiv.className = 'compatibility-result';
 problemsDiv.style.backgroundColor = '#f8f9fa';
 problemsDiv.innerHTML = '<div><strong>and:</strong></div>';
 resultsDiv.appendChild(problemsDiv);
 allProblems.forEach(problem => {
 const problemDiv = document.createElement('div');
 problemDiv.className = `compatibility-result ${problem.type === 'error' ? 'validation-error' : 'validation-warning'}`;
 problemDiv.style.marginTop = '5px';
 problemDiv.innerHTML = `
 <div><strong>${problem.type === 'error' ? '‚úó' : '‚ö†'} ${problem.type === 'error' ? 'and' : 'and'}:</strong></div>
 <div>${problem.message}</div>
 `;
 resultsDiv.appendChild(problemDiv);
 });
 }
 // and
 const overallPassed = compatibility.passed && practicalCheck.feasible && numericalCheck.feasible;
 const verdictDiv = document.createElement('div');
 verdictDiv.className = `compatibility-result ${overallPassed ? 'validation-ok' : 'validation-error'}`;
 verdictDiv.style.fontWeight = 'bold';
 verdictDiv.style.fontSize = '14px';
 verdictDiv.innerHTML = `
 <div><strong>${overallPassed ? '‚úì to ' : '‚úó '}</strong></div>
 <div>${overallPassed ? ' and ' : ' , andand'}</div>
 `;
 resultsDiv.appendChild(verdictDiv);
 panel.style.display = 'block';
 panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
 }
 // ========== ==========
 function setupEnhancedEventListeners() {
 // andand and and
 ['value1', 'value2', 'value3'].forEach(id => {
 const input = document.getElementById(id);
 input.addEventListener('input', function() {
 const index = parseInt(id.replace('value', ''));
 const paramKey = document.getElementById(`param${index}`).value;
 if (!paramKey) return;
 const value = parseFloat(this.value);
 if (isNaN(value)) return;
 // Check and andand for and
 if (paramKey.includes('angle')) {
 if (value < 0.1 || value > 179.9) {
 this.style.borderColor = '#e74c3c';
 showStatusMessage(`angle is too close to and (${value}¬∞)`, 'warning');
 } else {
 this.style.borderColor = '#2ecc71';
 }
 } else {
 if (value < 0.001) {
 this.style.borderColor = '#e74c3c';
 showStatusMessage(`Value is too small (${value})`, 'warning');
 } else if (value > 1000) {
 this.style.borderColor = '#e74c3c';
 showStatusMessage(`Value and and (${value})`, 'warning');
 } else {
 this.style.borderColor = '#2ecc71';
 }
 }
 });
 });
 }
 // ========== check ==========
 function checkNumericalFeasibility(params) {
 const issues = [];
 // Check on NaN and notand
 Object.entries(params).forEach(([key, value]) => {
 if (value !== undefined && value !== null) {
 if (isNaN(value)) {
 issues.push(`Parameter ${getParameterName(key)} and NaN`);
 }
 if (!isFinite(value)) {
 issues.push(`Parameter ${getParameterName(key)} and not and`);
 }
 }
 });
 // Check and for and andand
 const definedAngles = [];
 let anglesSum = 0;
 if (params.angleA) {
 definedAngles.push('A');
 anglesSum += params.angleA;
 }
 if (params.angleB) {
 definedAngles.push('B');
 anglesSum += params.angleB;
 }
 if (params.angleC) {
 definedAngles.push('C');
 anglesSum += params.angleC;
 }
 if (definedAngles.length === 3) {
 const angleError = Math.abs(anglesSum - 180);
 if (angleError > 0.1) {
 issues.push(`Sum of angles (${anglesSum.toFixed(2)}¬∞) and and from 180¬∞ (and: ${angleError.toFixed(2)}¬∞)`);
 }
 }
 // Check on andand andto
 if (params.angleA && params.angleB && params.angleC) {
 const minAngle = Math.min(params.angleA, params.angleB, params.angleC);
 const maxAngle = Math.max(params.angleA, params.angleB, params.angleC);
 if (minAngle < 0.1) {
 issues.push(`andand angle (${minAngle.toFixed(2)}¬∞) is too small for and andand`);
 }
 if (maxAngle > 179.9) {
 issues.push(`and angle (${maxAngle.toFixed(2)}¬∞) is too close to 180¬∞`);
 }
 // Check on and andnot andto
 if (anglesSum > 179.9 && anglesSum < 180.1) {
 if (maxAngle > 179.5 || minAngle < 0.5) {
 issues.push("andto andand (and angle is very close to 180¬∞)");
 }
 }
 }
 return {
 feasible: issues.length === 0,
 issues: issues
 };
 }
 // and for
 function triggerAutoCalculate() {
 // and and
 if (autoCalculateTimer) {
 clearTimeout(autoCalculateTimer);
 }
 // 300 (and)
 autoCalculateTimer = setTimeout(() => {
 if (validateParameterSelection() && !document.getElementById('solveBtn').disabled) {
 startSolvingEnhanced();
 }
 }, 300);
 }
 // andand andon for and Chart.js
 if (typeof Chart !== 'undefined' && Chart.register) {
 Chart.register({
 id: 'annotation',
 afterDraw: function(chart) {
 const ctx = chart.ctx;
 const annotations = chart.options.plugins?.annotation?.annotations;
 if (!annotations) return;
 Object.values(annotations).forEach(annotation => {
 if (!annotation || !annotation.xValue || !annotation.yValue) return;
 const meta = chart.getDatasetMeta(0);
 const xScale = chart.scales.x;
 const yScale = chart.scales.y;
 const x = xScale.getPixelForValue(annotation.xValue);
 const y = yScale.getPixelForValue(annotation.yValue);
 ctx.save();
 ctx.font = annotation.font?.size + 'px ' + (annotation.font?.weight || 'normal') + ' Arial';
 ctx.fillStyle = annotation.color || '#2c3e50';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 const xAdj = annotation.xAdjust || 0;
 const yAdj = annotation.yAdjust || 0;
 ctx.fillText(annotation.content, x + xAdj, y + yAdj);
 ctx.restore();
 });
 }
 });
 }
 </script>
</body>
</html>